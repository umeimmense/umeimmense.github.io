<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2021-11-29T15:28:37.504Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[7 个可能需要的自定义 React Hook]]></title>
        <id>https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook</id>
        <link href="https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook">
        </link>
        <updated>2021-11-29T14:52:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要编制了一份清单，列出了在项目中可能会需要用到的的七个Hooks。<br>
<img src="https://umeimmense.github.io/post-images/1638197755400.jpeg" alt="" loading="lazy"></p>
<h2 id="1-usetoggle">1. useToggle</h2>
<p>这个hook很常见，它用于在 true 和 false 之间切换布尔值。当我们想要显示/隐藏模式或打开/关闭侧边菜单时，它很有用。这个hook的基本版本如下所示：</p>
<h3 id="实现v1">实现v1</h3>
<pre><code class="language-jsx">// useToggle.jsx
import { useState, useCallback } from 'react';

const useToggle = (initialValue = false) =&gt; {
  const [state, setState] = useState(initialValue);
  
  const toggle = useCallback(() =&gt; {
    setState((state) =&gt; !state);
  }, []);
  
  return [state, toggle];
};

export default useToggle;
</code></pre>
<h3 id="案例1">案例1</h3>
<pre><code class="language-jsx">import useToggle from './useToggle';
const App = () =&gt; {
  const [show, toggleShow] = useToggle();
  return (
    &lt;Modal show={show} onClose={toggleShow}&gt;
      &lt;h1&gt;Hello there&lt;/h1&gt;
    &lt;/Modal&gt;
  );
}
</code></pre>
<p>当我们想要显示/隐藏表中一行的模式时，可以稍微修改此hook以用于用例。我添加了一个 customToggle 方法，该方法将值设置为给定值，而不是切换先前的状态值。</p>
<h3 id="实现v2">实现v2</h3>
<pre><code class="language-jsx">// useToggle.jsx modified

import { useState, useCallback } from 'react';

const useToggle = (initialValue = false) =&gt; {
  const [state, setState] = useState(initialValue);

  const toggle = useCallback(() =&gt; {
    setState((state) =&gt; !state);
  }, []);

  const customToggle = useCallback((value) =&gt; {
    setState(value);
  }, []);

  return [state, toggle, customToggle];
};

export default useToggle;
</code></pre>
<h3 id="案例2">案例2</h3>
<p>假设我们在一个表格中有一堆行，我们想提供一个删除行的选项。单击删除按钮应打开一个确认模式。<br>
对于这种类型的功能，我们需要状态中的两个变量。首先，保存一个布尔值来确定是否显示删除确认模式，其次保存必须显示删除模式的行 ID。<br>
使用这个hook，我们可以用一个状态变量来完成。这是如何做到的：</p>
<pre><code class="language-jsx">import useToggle from './useToggle';

// initial data
const rows = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Doe' }
];

const App = () =&gt; {
  // using hook
  const [delModal, toggleDelModal, setDelModalCustom] = useToggle();

  return (
    &lt;div&gt;
      &lt;table&gt;
        {rows.map(row =&gt; (
          &lt;tr&gt;
            &lt;td&gt;{row.id}&lt;/td&gt;
            &lt;td&gt;{row.name}&lt;/td&gt;
            &lt;td onClick={() =&gt; setDelModalCustom(row.id)}&gt;Delete&lt;/td&gt;
          &lt;/tr&gt;
        ))}
      &lt;/table&gt;

      &lt;DeleteModal
        show={Boolean(delModal)}
        onClose={toggleDelModal}
        itemToDelete={delModal} // it will hold the current row id
      &gt;
        &lt;h1&gt;
          Are you sure you want to delete row with id {delModal}
        &lt;/h1&gt;
      &lt;/DeleteModal&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="2-usepagebottom">2. usePageBottom</h2>
<p>使用此hook，您可以确定用户是否已滚动到页面底部。非常适合无限滚动的应用程序，当用户滚动到页面底部时，您需要获取更多数据。</p>
<pre><code class="language-jsx">// usePageBottom.jsx

import { useState, useEffect } from 'react';

const usePageBottom = () =&gt; {
  const [reachedBottom, setReachedBottom] = useState(false);
  
  // event handler for determining if the user reached bottom
  const handleScroll = () =&gt; {
    const offsetHeight = document.documentElement.offsetHeight;
    const innerHeight = window.innerHeight;
    const scrollTop = document.documentElement.scrollTop;

    // if current scroll from bottom is less than equal to 10px
    const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10;

    setReachedBottom(reachingBottom);
  };

  // effect for binding event listener on window scroll
  useEffect(() =&gt; {
    window.addEventListener('scroll', handleScroll);
    
    return () =&gt; {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);
  
  return reachedBottom;
}
</code></pre>
<h3 id="案例">案例</h3>
<pre><code class="language-jsx">import usePageBottom from './usePageBottom';
const App = (props) =&gt; {
  // hook usage
  const scrolledBottom = usePageBottom();
  return (
    &lt;div className=&quot;App&quot; style={{ height: '150vh' }}&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
      &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="节流版本可选">节流版本（可选）</h3>
<p>减少像窗口滚动事件这样多次触发的事件的通知是最佳实践，我们可以使用节流设置事件侦听器。我正在使用 <code>lodash</code> 的<code>throttle</code>；你也可以使用去<code>debounce</code>。</p>
<pre><code class="language-jsx">// usePageBottom with throttle

import { useState, useEffect, useMemo } from 'react';
import { throttle } from 'lodash';

const usePageBottom = () =&gt; {
  const [reachedBottom, setReachedBottom] = useState(false);
  
  // event handler for determining if the user reached bottom
 const handleScroll = useMemo(() =&gt; {
    return throttle(() =&gt; {
      const offsetHeight = document.documentElement.offsetHeight;
      const innerHeight = window.innerHeight;
      const scrollTop = document.documentElement.scrollTop;

      // if current scroll from bottom is less than equal to 10px
      const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10;
      
      setReachedBottom(reachingBottom);
    }, 1000);
  }, []);

  // effect for binding event listener on window scroll
  useEffect(() =&gt; {
    window.addEventListener('scroll', handleScroll);
    
    return () =&gt; {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);
  
  return reachedBottom;
}
</code></pre>
<h2 id="3-useelementbottom">3. useElementBottom</h2>
<p>就像页面底部一样，我们也可以确定用户是否已经滚动到元素的底部。在这个hook中，传递了对元素的引用，因此我们可以使用元素的高度和当前滚动位置来确定元素是否滚动到底部。</p>
<pre><code class="language-jsx">// useElementBottom.jsx

import { useState, useEffect, useMemo } from 'react';
import { throttle } from 'lodash';

const useElementBottom = (element) =&gt; {
  const [reachedBottom, setReachedBottom] = useState(false);

  // event handler for determining if the user reached bottom
  const handleScroll = useMemo(() =&gt; {
    return throttle(() =&gt; {
      const { current } = element; // current holds the reference to element

      // if current scroll from bottom is less than equal to 10px
      const scrollBottom =
        current.scrollHeight - current.scrollTop - current.clientHeight;

      const reachingBottom = scrollBottom &lt;= 10;
      setReachedBottom(reachingBottom);
    }, 1000);
  }, []);

  // effect for binding event listener on element scroll
  useEffect(() =&gt; {
    const { current } = element;
    current.addEventListener('scroll', handleScroll);

    return () =&gt; current.removeEventListener('scroll', handleScroll);
  }, []);

  return reachedBottom;
};

export default useElementBottom;
</code></pre>
<h3 id="案例-2">案例</h3>
<pre><code class="language-jsx">import useElementBottom from './useElementBottom';
const App = (props) =&gt; {
  const element = useRef();
  // hook usage
  const scrolledBottom = useElementBottom(element);
  return (
    &lt;div ref={element} style={{ height: '150vh' }}&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
      &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="4-useprevious">4. usePrevious</h2>
<p>我们可以制作一个自定义hook来获取 prop 或 state 的先前值。使用 React 类组件，可以使用 componentDidUpdate 生命周期来获取之前的 prop 和 state 值。对于功能组件，我们可以使用自定义hook来完成，如下所示：</p>
<pre><code class="language-jsx">// usePrevious.jsx

import { useEffect, useRef } from 'react';

const usePrevious = (value) =&gt; {
  const ref = useRef();

  // store current value in ref
  useEffect(() =&gt; {
    ref.current = value;
  }, [value]);

  // return previous value (happens before update in useEffect above)
  return ref.current;
};

export default usePrevious;
</code></pre>
<p>我们使用 useRef hook来存储先前的值。我们的hook在 useEffect 中更新引用对象之前返回先前的值。</p>
<pre><code class="language-jsx">import usePrevious from './usePrevious';

const App = () =&gt; {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="5-usewindowsize">5. useWindowSize</h2>
<p>这个hook返回窗口的宽度和高度。我们在调整窗口大小时设置了一个受限制的 set 事件侦听器，以便我们每次都能获得正确的宽度和高度。</p>
<pre><code class="language-jsx">// useWindowSize

import { useState, useEffect, useCallback } from 'react';
import { throttle } from 'throttle';

const useWindowSize = () =&gt; {
  const [size, setSize] = useState({
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight,
  });

  // throttled set listener that runs on window resize
  const throttledSetResizeListner = useCallback(
    throttle(() =&gt; {
      // set size in state
      setSize({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight,
      });
    }, 1000),
    []
  );

  // effect for binding resize event on window
  useEffect(() =&gt; {
    // add throtelled set window resize event listener
    window.addEventListener('resize', throttledSetResizeListner);

    // remove throttled set window resize event listener
    return () =&gt;
      window.removeEventListener('resize', throttledSetResizeListner);
  }, [throttledSetResizeListner]);

  return size;
};

export default useWindowSize;
</code></pre>
<h3 id="案例-3">案例</h3>
<p>当你想根据窗口的宽度或高度在你的 JS 代码中做一些事情时，它很有用。</p>
<pre><code class="language-jsx">import useWindowSize from './useWindowSize';
const App = () =&gt; {
  const { innerWidth, innerHeight } = useWindowSize();
  return (
    &lt;div&gt;
      {innerWidth &lt;= 768 ?
        'I am on small screen' : 'I am on large screen'}
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="6-useeventlistener">6. useEventListener</h2>
<p>使用此hook可以轻松地将事件侦听器绑定到窗口或窗口元素。在hook的effect中，我们检查元素是否是来自 useRef 的引用。如果没有，我们将事件侦听器添加到全局窗口对象。</p>
<pre><code class="language-jsx">import { useEffect } from 'react';

const useEventListener = (event, handler, referencedElement) =&gt; {
  // effect for binding event handler to the element
  useEffect(() =&gt; {
    const element = referencedElement?.current || window;

    const isSupported = element &amp;&amp; element.addEventListener;

    if (!isSupported) return;

    // bind event to the element
    element.addEventListener(event, handler);

    return () =&gt; element.removeEventListener(event, handler);
  }, [referencedElement, event, handler]);

  return;
};

export default useEventListener;
</code></pre>
<pre><code class="language-jsx">import useEventListener from './useEventListener';

const App = (props) =&gt; {
  const element = useRef();
  useEventListener('mouseover', handler, element);
  const handler =&gt; () =&gt; {
    console.log('Event triggered');
  }
  return (
    &lt;div ref={element}&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
    &lt;div&gt;
  );
}
</code></pre>
<p>我们还可以使用相同的hook将事件添加到窗口</p>
<pre><code class="language-jsx">import useEventListener from './useEventListener';
const App = (props) =&gt; {
  // adding event listener on window scroll
  useEventListener('scroll', handler);
  const handler =&gt; () =&gt; {
    console.log('Event triggered');
  }
  return (
    &lt;div&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
    &lt;div&gt;
  );
}
</code></pre>
<h2 id="7-uselocalstoragestate">7. useLocalStorageState</h2>
<p>有时，可能需要在本地存储和状态之间同步一个值。这个hook的作用完全一样。我们正在使用 useState 并检查指定的键是否在本地存储中具有某个值，以便我们可以将其用作初始值。这允许我们在页面刷新时保持值与状态同步。</p>
<pre><code class="language-jsx">// useLocalStorageState

import { useState, useEffect } from 'react';

const useLocalStorageState = (key, defaultValue) =&gt; {
  const [value, setValue] = useState(() =&gt; {
    let val;

    try {
      // if there is a value in local storage for given key, set it as initial state
      val = JSON.parse(localStorage.getItem(key) || String(defaultValue));
    } catch (error) {
      // otherwise, set default value as initial state
      val = defaultValue;
    }

    return val;
  });

  // effect to update local storage when state changes
  useEffect(() =&gt; {
    localStorage.setItem(key, JSON.stringify(value));
  }, [value]);

  return [value, setValue];
};

export default useLocalStorageState;
</code></pre>
<p>当值更新时，会运行一个effect ，更新本地存储中的值。</p>
<h3 id="案例-4">案例</h3>
<p>假设你想在本地存储中存储用户主题首选项</p>
<pre><code class="language-jsx">import useLocalStorageState from './useLocalStorageState';
const App = (props) =&gt; {
  // setting default theme to light
  const [theme, setTheme] = useLocalStorageState('theme', 'light');
  return (
    &lt;div&gt;
      &lt;p&gt;Current theme is {theme}&lt;/p&gt;
      &lt;button onClick={() =&gt; setTheme('dark')}&gt;
        Change theme to dark
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>当你点击更改主题按钮时，状态和本地存储中的值都会更新。页面刷新后，你将获得存储在本地存储中的最后一个值。</p>
<h2 id="结语">结语</h2>
<p>感谢你阅读到最后。我希望这些自定义hook对你有用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10个常用的JavaScript使用技巧]]></title>
        <id>https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao</id>
        <link href="https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao">
        </link>
        <updated>2021-11-23T07:48:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>编写简短、简洁和干净的 JavaScript 代码的技巧😎<br>
<img src="https://umeimmense.github.io/post-images/1638169801723.png" alt="" loading="lazy"><br>
JavaScript 有很多很酷的特性，大多数初学者和中级开发人员都不知道。我挑选了 10 个我在日常 JavaScript 项目中使用的技巧。</p>
<h2 id="1-有条件的向对象中添加属性">1. 有条件的向对象中添加属性</h2>
<p>我们可以使用扩展运算符 <code>...</code> 来有条件地向 JavaScript 对象快速添加属性。</p>
<pre><code class="language-javascript">const condition = true;
const person = {
  id: 1,
  name: 'John Doe',
  ...(condition &amp;&amp; { age: 16 }),
};
</code></pre>
<p>如果每个操作数的计算结果都为true， &amp;&amp; 运算符将返回最后计算的表达式。因此返回一个对象 { age: 16 }，然后将其作为 person 对象的一部分。</p>
<p>如果条件为 false，则 JavaScript 将执行以下操作：</p>
<pre><code class="language-javascript">const person = {
  id: 1,
  name: 'John Doe',
  ...(false), // evaluates to false
};
// spreading false has no effect on the object
console.log(person); // { id: 1, name: 'John Doe' }
</code></pre>
<h2 id="2-检查一个属性是否存在于一个对象中">2. 检查一个属性是否存在于一个对象中</h2>
<p>我们可以使用<code>in</code>关键字来检查 JavaScript 对象中是否存在属性</p>
<pre><code class="language-javascript">const person = { name: 'John Doe', salary: 1000 };
console.log('salary' in person); // returns true
console.log('age' in person); // returns false
</code></pre>
<h2 id="3-对象中的动态属性名称">3. 对象中的动态属性名称</h2>
<p>使用动态键设置对象属性很简单。只需使用 ['key_name'] 符号添加属性</p>
<pre><code class="language-javascript">const dynamic = 'flavour';
var item = {
  name: 'Biscuit',
  [dynamic]: 'Chocolate'
}
console.log(item); // { name: 'Biscuit', flavour: 'Chocolate' }
</code></pre>
<p>同样的技巧也可用于使用动态键引用对象属性：</p>
<pre><code class="language-javascript">const keyName = 'name';
console.log(item[keyName]); // returns 'Biscuit'
</code></pre>
<h2 id="4-使用动态键进行对象解构">4. 使用动态键进行对象解构</h2>
<p>你可能知道你可以解构一个变量并立即用 : 符号重命名它。但是你知道当你不知道键名或键名是动态的时，你也可以解构对象的属性吗？<br>
首先，让我们看看如何在解构（用别名解构）时重命名变量。</p>
<pre><code class="language-javascript">const person = { id: 1, name: 'John Doe' };
const { name: personName } = person;
console.log(personName); // returns 'John Doe'
</code></pre>
<p>现在，让我们使用动态键来解构属性：</p>
<pre><code class="language-javascript">const templates = {
  'hello': 'Hello there',
  'bye': 'Good bye'
};
const templateName = 'bye';
const { [templateName]: template } = templates;
console.log(template) // returns 'Good bye'
</code></pre>
<h2 id="5-运算符">5. ?? 运算符</h2>
<p>这 <code>??</code>当你要检查变量是 null 还是 undefined 时，运算符很有用。当其左侧操作数为空或未定义时，它返回右侧操作数，否则返回其左侧操作数。</p>
<pre><code class="language-javascript">const foo = null ?? 'Hello';
console.log(foo); // returns 'Hello'
const bar = 'Not null' ?? 'Hello';
console.log(bar); // returns 'Not null'
const baz = 0 ?? 'Hello';
console.log(baz); // returns 0
</code></pre>
<p>在第三个示例中，返回 0 是因为即使 0 在 JavaScript 中被认为是假的，但它不是 null 或未定义的。你可能认为我们可以使用 ||运算符在这里，但这两者之间存在差异：</p>
<pre><code class="language-javascript">const cannotBeZero = 0 || 5;
console.log(cannotBeZero); // returns 5
const canBeZero = 0 ?? 5;
console.log(canBeZero); // returns 0
</code></pre>
<h2 id="6-可选链">6. ?. 可选链</h2>
<p>我们都可能曾经遇到过TypeError：无法读取 null 的属性“foo”之类的错误。这对每个 JavaSript 开发人员来说都是头疼的问题。引入了可选链就是为了解决这个问题。让我们来看看：</p>
<pre><code class="language-javascript">const book = { id:1, title: 'Title', author: null };
// normally, you would do this
console.log(book.author.age) // throws error
console.log(book.author &amp;&amp; book.author.age); // returns null (no error)
// with optional chaining
console.log(book.author?.age); // returns undefined
// or deep optional chaining
console.log(book.author?.address?.city); // returns undefined
</code></pre>
<p>你还可以使用具有以下功能的可选链：</p>
<pre><code class="language-javascript">const person = {
  firstName: 'Haseeb',
  lastName: 'Anwar',
  printName: function () {
    return `${this.firstName} ${this.lastName}`;
  },
};
console.log(person.printName()); // returns 'Haseeb Anwar'
console.log(persone.doesNotExist?.()); // returns undefined
</code></pre>
<h2 id="7-使用-的布尔转换符">7. 使用 !! 的布尔转换符</h2>
<p>这 <code>!!</code>运算符可用于将表达式的结果快速转换为布尔值 <code>true</code> 或 <code>false</code>。就是这样：</p>
<pre><code class="language-javascript">const greeting = 'Hello there!';
console.log(!!greeting) // returns true
const noGreeting = '';
console.log(!!noGreeting); // returns false
</code></pre>
<h2 id="8-字符串和整数转换">8. 字符串和整数转换</h2>
<p>使用 + 运算符快速将字符串转换为数字，如下所示：</p>
<pre><code class="language-javascript">const stringNumer = '123';
console.log(+stringNumer); // returns integer 123
console.log(typeof +stringNumer); // returns 'number'
</code></pre>
<p>要将数字快速转换为字符串，请使用 + 运算符后跟空字符串 &quot;&quot;：</p>
<pre><code class="language-javascript">const myString = 25 + '';
console.log(myString); // returns '25'
console.log(typeof myString); // returns 'string'
</code></pre>
<p>这些类型转换非常方便，但它们的清晰度和代码可读性较差。因此，在生产中使用它们之前，你可能需要考虑一下。不过可以用才<code>code golf</code>中。</p>
<h2 id="9-检查数组中的假值">9. 检查数组中的假值</h2>
<p>你熟悉 filter、some 和 every 数组方法。但你也应该知道，你可以仅使用布尔方法来测试真值：</p>
<pre><code class="language-javascript">const myArray = [null, false, 'Hello', undefined, 0];
// filter falsy values
const filtered = myArray.filter(Boolean);
console.log(filtered); // returns ['Hello']
// check if at least one value is truthy
const anyTruthy = myArray.some(Boolean);
console.log(anyTruthy); // returns true
// check if all values are truthy
const allTruthy = myArray.every(Boolean);
console.log(allTruthy); // returns false
</code></pre>
<p>这是它的工作原理。众所周知，这些数组方法采用回调函数，因此我们将布尔值作为回调函数传递。 <code>Boolean</code> 本身接受一个参数并根据参数的真实性返回<code>true</code>或 <code>false</code>。所以我们可以这样说：</p>
<pre><code class="language-javascript">myArray.filter(val =&gt; Boolean(val));
</code></pre>
<p>是不是和这个一样：</p>
<pre><code class="language-javascript">myArray.filter(Boolean);
</code></pre>
<h2 id="10展平数组">10.展平数组</h2>
<p>原型 Array 上有一个方法 flat 可以让你从数组的数组中创建一个数组：</p>
<pre><code class="language-javascript">const myArray = [{ id: 1 }, [{ id: 2 }], [{ id: 3 }]];
const flattedArray = myArray.flat(); 
// returns [ { id: 1 }, { id: 2 }, { id: 3 } 
</code></pre>
<p>你还可以定义一个深度级别，指定嵌套数组结构应展平的深度。例如：</p>
<pre><code class="language-javascirpt">const arr = [0, 1, 2, [[[3, 4]]]];
console.log(arr.flat(2)); // returns [0, 1, 2, [3,4]]
</code></pre>
<h2 id="结语">结语</h2>
<p>感谢你阅读到最后。我希望这些技巧对你有用。</p>
]]></content>
    </entry>
</feed>