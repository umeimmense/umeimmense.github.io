<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2022-05-03T14:18:39.172Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[数据整理]]></title>
        <id>https://umeimmense.github.io/post/shu-ju-zheng-li</id>
        <link href="https://umeimmense.github.io/post/shu-ju-zheng-li">
        </link>
        <updated>2022-05-01T15:57:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据整理">数据整理</h1>
<blockquote>
<p>课程链接：<a href="https://missing-semester-cn.github.io/2020/data-wrangling/">数据整理 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
</blockquote>
<p>[toc]</p>
<p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！<br>
这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p>
<p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p>
<p>例如这样一条命令 <code>journalctl | grep -i intel</code>，它会找到所有包含intel(区分大小写)的系统日志。您可能并不认为是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p>
<p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p>
<pre><code class="language-bash">ssh myserver journalctl
</code></pre>
<p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p>
<pre><code class="language-bash">ssh myserver journalctl | grep sshd
</code></pre>
<p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 <code>grep</code> 程序！<br>
<code>ssh</code> 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 <code>ssh</code> 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p>
<pre><code class="language-bash">ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' | less
</code></pre>
<p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 <code>less</code> 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p>
<pre><code class="language-console">$ ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' &gt; ssh.log
$ less ssh.log
</code></pre>
<p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 <code>sed</code> 这个非常强大的工具。</p>
<p><code>sed</code> 是一个基于文本编辑器<code>ed</code>构建的&quot;流编辑器&quot; 。在 <code>sed</code> 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 <code>s</code>，即<em>替换</em>命令，例如我们可以这样写：</p>
<pre><code class="language-bash">ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed 's/.*Disconnected from //'
</code></pre>
<p>上面这段命令中，我们使用了一段简单的<em>正则表达式</em>。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code> 命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中 <code>REGEX</code> 部分是我们需要使用的正则表达式，而 <code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p>
<h2 id="正则表达式">正则表达式</h2>
<p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： <code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code>  除空格之外的&quot;任意单个字符&quot;</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<p><code>sed</code> 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加<code>\</code>才能使其具有特殊含义。或者，您也可以添加<code>-E</code>选项来支持这些匹配。</p>
<p>回过头我们再看<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含&quot;Disconnected from &quot;的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 &quot;Disconnected from&quot; 作为自己的用户名会怎样呢？</p>
<pre><code>Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]
</code></pre>
<p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code> 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p>
<pre><code>46.97.239.16 port 55920 [preauth]
</code></pre>
<p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给 <code>*</code> 或 <code>+</code> 增加一个<code>?</code> 后缀使其变成非贪婪模式，但是很可惜 <code>sed</code> 并不支持该后缀。不过，我们可以切换到<br>
perl 的命令行模式，该模式支持编写这样的正则表达式：</p>
<pre><code class="language-bash">perl -pe 's/.*?Disconnected from //'
</code></pre>
<p>让我们回到 <code>sed</code> 命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>是最常见的工具。<code>sed</code> 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code> 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p>
<p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p>
<p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配<em>一整行</em>：</p>
<pre><code class="language-bash"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//'
</code></pre>
<p>让我们借助正则表达式在线调试工具<a href="https://regex101.com/r/qqbZqh/2">regex debugger</a> 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code> 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀<code>[preauth]</code>，最后再匹配行尾。</p>
<p>注意，这样做的话，即使用户名是“Disconnected from”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p>
<p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名<em>保留</em>下来。对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如<code>\1</code>、 <code>\2</code>、<code>\3</code>等等，因此可以使用如下命令：</p>
<pre><code class="language-bash"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章<a href="https://www.regular-expressions.info/email.html">e-mail address</a>，匹配电子邮箱可一点<a href="https://emailregex.com/">也不简单</a>。网络上还有很多关于如何匹配电子邮箱地址的<a href="https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression/1917982">讨论</a>。人们还为其编写了<a href="https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php">测试用例</a>及 <a href="https://mathiasbynens.be/demo/url-regex">测试矩阵</a>。您甚至可以编写一个用于判断一个数<a href="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">是否为质数</a>的正则表达式。</p>
<p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p>
<h2 id="回到数据整理">回到数据整理</h2>
<p>OK，现在我们有如下表达式：</p>
<pre><code class="language-bash">ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用 <code>i</code> 命令)，打印特定的行 (使用 <code>p</code>命令)，基于索引选择特定行等等。详情请见<code>man sed</code>!</p>
<p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登陆我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p>
<pre><code class="language-bash">ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
</code></pre>
<p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常登陆的用户：</p>
<pre><code class="language-bash">ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
</code></pre>
<p><code>sort -n</code> 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序<br>
<code>-k1,1</code> 则表示“仅基于以空格分割的第一列进行排序”。<code>,n</code> 部分表示“仅排序到第n个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p>
<p>如果我们希望得到登陆次数最少的用户，我们可以使用 <code>head</code> 来代替<code>tail</code>。或者使用<code>sort -r</code>来进行倒序排序。</p>
<p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p>
<pre><code class="language-bash">ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | awk '{print $2}' | paste -sd,
</code></pre>
<p>我们可以利用 <code>paste</code>命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割 (<code>-d</code>)，那<code>awk</code>的作用又是什么呢？</p>
<h2 id="awk-另外一种编辑器">awk -- 另外一种编辑器</h2>
<p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code> 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p>
<p>首先， <code>{print $2}</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。<br>
在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p>
<p>让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登陆的用户。</p>
<pre><code class="language-bash"> | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l
</code></pre>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>{...}</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<pre><code class="language-awk">BEGIN { rows = 0 }
$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 }
END { print rows }
</code></pre>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 <code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以<a href="https://backreference.org/2010/02/10/idiomatic-awk">解决所有问题</a>。至于怎么做，就留给读者们做课后练习吧。</p>
<h2 id="分析数据">分析数据</h2>
<p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p>
<pre><code class="language-bash"> | paste -sd+ | bc -l
</code></pre>
<p>下面这种更加复杂的表达式也可以：</p>
<pre><code class="language-bash">echo &quot;2*($(data | paste -sd+))&quot; | bc -l
</code></pre>
<p>您可以通过多种方式获取统计数据。如果已经安装了R语言，<a href="https://github.com/nferraz/st"><code>st</code></a>是个不错的选择：</p>
<pre><code class="language-bash">ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | awk '{print $1}' | R --slave -e 'x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)'
</code></pre>
<p>R 也是一种编程语言，它非常适合被用来进行数据分析和<a href="https://ggplot2.tidyverse.org/">绘制图表</a>。这里我们不会讲的特别详细， 您只需要知道<code>summary</code> 可以打印统计结果。我们通过输入的信息计算出一个矩阵，然后R语言就可以得到我们想要的统计数据。</p>
<p>如果您希望绘制一些简单的图表， <code>gnuplot</code> 可以帮助到您：</p>
<pre><code class="language-bash">ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | gnuplot -p -e 'set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes'
</code></pre>
<h2 id="利用数据整理来确定参数">利用数据整理来确定参数</h2>
<p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 <code>xargs</code> 即可实现：</p>
<pre><code class="language-bash">rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed 's/-x86.*//' | xargs rustup toolchain uninstall
</code></pre>
<h2 id="整理二进制数据">整理二进制数据</h2>
<p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p>
<pre><code class="language-bash">ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -
 | convert - -colorspace gray -
 | gzip
 | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -'
</code></pre>
<h1 id="课后练习">课后练习</h1>
<ol>
<li>
<p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.✔️</p>
</li>
<li>
<p>统计words文件 (<code>/usr/share/dict/words</code>) 中包含至少三个<code>a</code> 且不以<code>'s</code> 结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code>的 <code>y</code>命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很有挑战性的问题：哪个组合从未出现过？✔️</p>
<pre><code class="language-shell"># 输出组合数
cat ./words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep &quot;.*a.*a.*a[a-z]*$&quot; | sed -E 's/.*(..)/\1/' | sort | uniq -c | sort -nk1,1 | wc -l


# 保存至word.txt
cat ./words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep &quot;.*a.*a.*a[a-z]*$&quot; | sed -E 's/.*(..)/\1/' | sort | uniq -c | sort -nk1,1 | awk '{print $2}' &gt; word.txt

# 编写python脚本输出全部组合
letter = &quot;abcdefghijklmnopqrstuvwxyz&quot;
for a in letter:
	for b in letter:
		print(a+b)
# 保存至allword.txt
python word.py &gt; allword.txt

# 删除匹配项
cat word.txt | xargs -n 1 -i sed -i '/{}/d
' ./allword.txt

# 打印剩余组合数
cat allword.txt | wc -l
</code></pre>
</li>
<li>
<p>进行原地替换听上去很有诱惑力，例如：<br>
<code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题</p>
<p>sed是一个面向行的文本流处理程序</p>
</li>
<li>
<p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：</p>
<pre><code>Logs begin at ...
</code></pre>
<p>和</p>
<pre><code>systemd[577]: Startup finished in ...
</code></pre>
<p>在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>
<pre><code>=== system boot:
</code></pre>
<p>和</p>
<pre><code>Previous shutdown cause: 5
</code></pre>
</li>
<li>
<p>查看之前三次重启启动信息中不同的部分 (参见 <code>journalctl</code>的<code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code> 来删除 <code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code> )。最后，删除所有出现过3次的内容（因为这些内容上三次启动日志中的重复部分）。</p>
</li>
<li>
<p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者 <a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从 <a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<a href="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。✔️</p>
<pre><code class="language-shell"># 数据集：https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm

# 以标签为依据提取数据，通过paste和sed格式化，截取需要的部分
cat ./tree.htm | pup --color 'tbody text{}' | paste -sd, | sed -E 's/([A-Z])/\n\1/g' | tail -n +1754 &gt; list.txt

# 按列提取并排列求最值
cat list.txt | awk -F , '{print $2}' | sort -n 

# 将分隔符替换为‘-’，使用bc命令即可求出两列之差
cat list.txt | awk -F , '{print $2,$3}'| sed 's/ /-/' | tail -n +3 | bc -l | paste -sd+ | bc -l
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kaiwen_xue_2689268634/img/raw/master/img/123.jpg" alt="pic" loading="lazy"></figure>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编辑器（Vim）]]></title>
        <id>https://umeimmense.github.io/post/bian-ji-qi-vim</id>
        <link href="https://umeimmense.github.io/post/bian-ji-qi-vim">
        </link>
        <updated>2022-05-01T15:56:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>课程链接：<a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim) · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
</blockquote>
<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如 微软的 Word 与 Visual Studio Code）</p>
<p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p>
<ul>
<li>阅读教程（比如这节课以及我们为您提供的资源）</li>
<li>坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li>
<li>随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有。</li>
</ul>
<p>如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。当学习时间累计达到20个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p>
<h1 id="该学哪个编辑器">该学哪个编辑器？</h1>
<p>程序员们对自己正在使用的文本编辑器通常有着 <a href="https://en.wikipedia.org/wiki/Editor_war">非常强的执念</a>。</p>
<p>现在最流行的编辑器是什么？ <a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow的调查</a>(这个调查可能并不如我们想象的那样客观，因为Stack Overflow 的用户并不能代表所有程序员 )显示， <a href="https://code.visualstudio.com/">Visual Studio Code</a>是目前最流行的代码编辑器。而<a href="https://www.vim.org/">Vim</a> 则是最流行的基于命令行的编辑器。</p>
<h2 id="vim">Vim</h2>
<p>这门课的所有教员都使用Vim作为编辑器。Vim有着悠久历史；它始于1976年的Vi编辑器，到现在还在 不断开发中。Vim有很多聪明的设计思想，所以很多其他工具也支持Vim模式（比如，140万人安装了 <a href="https://github.com/VSCodeVim/Vim">Vim emulation for VS code</a>）。即使你最后使用 其他编辑器，Vim也值得学习。</p>
<p>由于不可能在50分钟内教授Vim的所有功能， 我们会专注于解释Vim的设计哲学，教你基础知识， 展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p>
<h1 id="vim的哲学">Vim的哲学</h1>
<p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以， Vim 是一个 <em>多模态</em> 编辑 器： 它对于插入文字和操纵文字有不同的模式。 Vim 既是可编程的 （可以使用 Vimscript 或者像 Python 一样的其他程序语言）， Vim 的接口本身也是一个程序语言： 键入操作 （以及其助记名） 是命令， 这些命令也是可组合的。 Vim 避免了使用鼠标，因为那样太慢了； Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</p>
<p>这样的设计哲学的结果是一个能跟上你思维速度的编辑器。</p>
<h1 id="编辑模式">编辑模式</h1>
<p>Vim的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p>
<ul>
<li><em>正常模式</em>：在文件中四处移动光标进行修改</li>
<li><em>插入模式</em>：插入文本</li>
<li><em>替换模式</em>：替换文本</li>
<li><em>可视化（一般，行，块）模式</em>：选中文本块</li>
<li><em>命令模式</em>：用于执行命令</li>
</ul>
<p>在不同的操作模式下， 键盘敲击的含义也不同。比如，<code>x</code> 在插入模式会插入字母<code>x</code>，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p>
<p>在默认设置下，Vim会在左下角显示当前的模式。 Vim启动时的默认模式是正常模式。通常你会把大部分 时间花在正常模式和插入模式。</p>
<p>你可以按下 <code>&lt;ESC&gt;</code> （退出键） 从任何其他模式返回正常模式。 在正常模式，键入 <code>i</code> 进入插入 模式， <code>R</code> 进入替换模式， <code>v</code> 进入可视（一般）模式， <code>V</code> 进入可视（行）模式， <code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式， <code>:</code> 进入命令模式。</p>
<p>因为你会在使用 Vim 时大量使用 <code>&lt;ESC&gt;</code> 键，所以可以考虑把大小写锁定键重定义成 <code>&lt;ESC&gt;</code> 键 （<a href="https://vim.fandom.com/wiki/Map_caps_lock_to_escape_in_macOS">MacOS 教程</a> ）。</p>
<h1 id="基本操作">基本操作</h1>
<h2 id="插入文本">插入文本</h2>
<p>在正常模式， 键入 <code>i</code> 进入插入模式。 现在 Vim 跟很多其他的编辑器一样， 直到你键入<code>&lt;ESC&gt;</code> 返回正常模式。 你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p>
<h2 id="缓存-标签页-窗口">缓存， 标签页， 窗口</h2>
<p>Vim 会维护一系列打开的文件，称为 “缓存”。 一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口 （分隔面板）。每个窗口显示一个缓存。 跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系； 窗口只是视角。 一个缓存可以在 <em>多个</em> 窗口打开，甚至在同一 个标签页内的多个窗口打开。这个功能其实很好用， 比如在查看同一个文件的不同部分的时候。</p>
<p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p>
<h2 id="命令行">命令行</h2>
<p>在正常模式下键入 <code>:</code> 进入命令行模式。 在键入 <code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能， 包括打开， 保存， 关闭文件， 以及 <a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p>
<ul>
<li>
<p><code>:q</code> 退出 （关闭窗口）</p>
</li>
<li>
<p><code>:w</code> 保存 （写）</p>
</li>
<li>
<p><code>:wq</code> 保存然后退出</p>
</li>
<li>
<p><code>:e {文件名}</code> 打开要编辑的文件</p>
</li>
<li>
<p><code>:ls</code> 显示打开的缓存</p>
</li>
<li>
<pre><code class="language-plaintext">  :help {标题}
</code></pre>
<p>打开帮助文档</p>
<ul>
<li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li>
<li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li>
</ul>
</li>
</ul>
<h1 id="vim-的接口其实是一种编程语言">Vim 的接口其实是一种编程语言</h1>
<p>Vim 最重要的设计思想是 Vim 的界面本身是一个程序语言。 键入操作 （以及他们的助记名） 本身是命令， 这些命令可以组合使用。 这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p>
<h2 id="移动">移动</h2>
<p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。</p>
<ul>
<li>
<p>基本移动: <code>hjkl</code> （左， 下， 上， 右）</p>
</li>
<li>
<p>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</p>
</li>
<li>
<p>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</p>
</li>
<li>
<p>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</p>
</li>
<li>
<p>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻）</p>
</li>
<li>
<p>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</p>
</li>
<li>
<p>行数： <code>:{行数}&lt;CR&gt;</code> 或者 <code>{行数}G</code> ({行数}为行数)</p>
</li>
<li>
<p>杂项： <code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）</p>
</li>
<li>
<p>查找：</p>
<pre><code class="language-plaintext">f{字符}
</code></pre>
<p>，</p>
<pre><code class="language-plaintext">t{字符}
</code></pre>
<p>，</p>
<pre><code class="language-plaintext">F{字符}
</code></pre>
<p>，</p>
<pre><code class="language-plaintext">T{字符}
</code></pre>
<ul>
<li>查找/到 向前/向后 在本行的{字符}</li>
<li><code>,</code> / <code>;</code> 用于导航匹配</li>
</ul>
</li>
<li>
<p>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配</p>
</li>
</ul>
<h2 id="选择">选择</h2>
<p>可视化模式:</p>
<ul>
<li>可视化</li>
<li>可视化行</li>
<li>可视化块</li>
</ul>
<p>可以用移动命令来选中。</p>
<h2 id="编辑">编辑</h2>
<p>所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</p>
<ul>
<li>
<pre><code class="language-plaintext">  i
</code></pre>
<p>进入插入模式</p>
<ul>
<li>但是对于操纵/编辑文本，不单想用退格键完成</li>
</ul>
</li>
<li>
<p><code>O</code> / <code>o</code> 在之上/之下插入行</p>
</li>
<li>
<pre><code class="language-plaintext">  d{移动命令}
</code></pre>
<p>删除 {移动命令}</p>
<ul>
<li>例如， <code>dw</code> 删除词, <code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">  c{移动命令}
</code></pre>
<p>改变 {移动命令}</p>
<ul>
<li>例如， <code>cw</code> 改变词</li>
<li>比如 <code>d{移动命令}</code> 再 <code>i</code></li>
</ul>
</li>
<li>
<p><code>x</code> 删除字符 （等同于 <code>dl</code>）</p>
</li>
<li>
<p><code>s</code> 替换字符 （等同于 <code>xi</code>）</p>
</li>
<li>
<p>可视化模式 + 操作</p>
<ul>
<li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li>
</ul>
</li>
<li>
<p><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</p>
</li>
<li>
<p><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</p>
</li>
<li>
<p><code>p</code> 粘贴</p>
</li>
<li>
<p>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</p>
</li>
</ul>
<h2 id="计数">计数</h2>
<p>你可以用一个计数来结合“名词” 和 “动词”， 这会执行指定操作若干次。</p>
<ul>
<li><code>3w</code> 向前移动三个词</li>
<li><code>5j</code> 向下移动5行</li>
<li><code>7dw</code> 删除7个词</li>
</ul>
<h2 id="修饰语">修饰语</h2>
<p>你可以用修饰语改变 “名词” 的意义。修饰语有 <code>i</code>， 表示 “内部” 或者 “在内“， 和 <code>a</code>， 表示 ”周围“。</p>
<ul>
<li><code>ci(</code> 改变当前括号内的内容</li>
<li><code>ci[</code> 改变当前方括号内的内容</li>
<li><code>da'</code> 删除一个单引号字符串， 包括周围的单引号</li>
</ul>
<h1 id="演示">演示</h1>
<p>这里是一个有问题的 <a href="https://en.wikipedia.org/wiki/Fizz_buzz">fizz buzz</a> 实现：</p>
<pre><code>def fizz_buzz(limit):
    for i in range(limit):
        if i % 3 == 0:
            print('fizz')
        if i % 5 == 0:
            print('fizz')
        if i % 3 and i % 5:
            print(i)

def main():
    fizz_buzz(10)
</code></pre>
<p>我们会修复以下问题：</p>
<ul>
<li>主函数没有被调用</li>
<li>从 0 而不是 1 开始</li>
<li>在 15 的整数倍的时候在不用行打印 “fizz” 和 “buzz”</li>
<li>在 5 的整数倍的时候打印 “fizz”</li>
<li>采用硬编码的参数 10 而不是从命令控制行读取参数</li>
</ul>
<p>展示详情请观看课程视频。 比较上面用 Vim 的操作和你可能使用其他程序的操作。 值得一提的是 Vim 需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p>
<h1 id="自定义-vim">自定义 Vim</h1>
<p>Vim 由一个位于 <code>~/.vimrc</code> 的文本配置文件 （包含 Vim 脚本命令）。 你可能会启用很多基本 设置。</p>
<p>我们提供一个文档详细的基本设置， 你可以用它当作你的初始设置。 我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。 <strong>在 <a href="https://missing-semester-cn.github.io/2020/files/vimrc">这儿</a> 下载我们的设置， 然后将它保存成 <code>~/.vimrc</code>.</strong></p>
<p>Vim 能够被重度自定义， 花时间探索自定义选项是值得的。 你可以参考其他人的在 GitHub 上共享的设置文件， 比如， 你的授课人的 Vim 设置 (<a href="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>, <a href="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a> (uses <a href="https://neovim.io/">neovim</a>), <a href="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。 有很多好的博客文章也聊到了这个话题。 尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它， 然后采用对你有用的部分。</p>
<h1 id="扩展-vim">扩展 Vim</h1>
<p>Vim 有很多扩展插件。 跟很多互联网上已经过时的建议相反， 你 <em>不</em> 需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。 你可以使用内置的插件管理系统。 只需要创建一个 <code>~/.vim/pack/vendor/start/</code> 的文件夹， 然后把插件放到这里 （比如通过 <code>git clone</code>）。</p>
<p>以下是一些我们最爱的插件：</p>
<ul>
<li><a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>: 模糊文件查找</li>
<li><a href="https://github.com/mileszs/ack.vim">ack.vim</a>: 代码搜索</li>
<li><a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: 文件浏览器</li>
<li><a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>: 魔术操作</li>
</ul>
<p>我们尽量避免在这里提供一份冗长的插件列表。 你可以查看讲师们的开源的配置文件 (<a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/JJGO/dotfiles">Jose</a>) 来看看我们使用的其他插件。 浏览 <a href="https://vimawesome.com/">Vim Awesome</a> 来了解一些很棒的插件。 这个话题也有很多博客文章： 搜索 “best Vim plugins”。</p>
<h1 id="其他程序的-vim-模式">其他程序的 Vim 模式</h1>
<p>很多工具提供了 Vim 模式。 这些 Vim 模式的质量参差不齐； 取决于具体工具， 有的提供了 很多酷炫的 Vim 功能， 但是大多数对基本功能支持的很好。</p>
<h2 id="shell">Shell</h2>
<p>如果你是一个 Bash 用户， 用 <code>set -o vi</code>。 如果你用 Zsh： <code>bindkey -v</code>。 Fish 用 <code>fish_vi_key_bindings</code>。 另外， 不管利用什么 shell， 你可以 <code>export EDITOR=vim</code>。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如， <code>git</code> 会使用这个编辑器来编辑 commit 信息。</p>
<h2 id="readline">Readline</h2>
<p>很多程序使用 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a> 库来作为 它们的命令控制行界面。 Readline 也支持基本的 Vim 模式， 可以通过在 <code>~/.inputrc</code> 添加如下行开启：</p>
<pre><code>set editing-mode vi
</code></pre>
<p>比如， 在这个设置下， Python REPL 会支持 Vim 快捷键。</p>
<h2 id="其他">其他</h2>
<p>甚至有 Vim 的网页浏览快捷键 <a href="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>, 受欢迎的有 用于 Google Chrome 的 <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a> 和用于 Firefox 的 <a href="https://github.com/tridactyl/tridactyl">Tridactyl</a>。 你甚至可以在 <a href="https://github.com/lambdalisue/jupyter-vim-binding">Jupyter notebooks</a> 中用 Vim 快捷键。</p>
<h1 id="vim-进阶">Vim 进阶</h1>
<p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你， 但是你 可以在使用中学习。 一个好的对策是: 当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有： 上网搜寻一下。</p>
<h2 id="搜索和替换">搜索和替换</h2>
<p><code>:s</code> （替换） 命令 （<a href="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p>
<ul>
<li>
<pre><code class="language-plaintext">  %s/foo/bar/g
</code></pre>
<ul>
<li>在整个文件中将 foo 全局替换成 bar</li>
</ul>
</li>
<li>
<pre><code class="language-plaintext">  %s/\[.*\](\(.*\))/\1/g
</code></pre>
<ul>
<li>将有命名的 Markdown 链接替换成简单 URLs</li>
</ul>
</li>
</ul>
<h2 id="多窗口">多窗口</h2>
<ul>
<li>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口</li>
<li>同一个缓存可以在多个窗口中显示。</li>
</ul>
<h2 id="宏">宏</h2>
<ul>
<li>
<p><code>q{字符}</code> 来开始在寄存器 <code>{字符}</code> 中录制宏</p>
</li>
<li>
<p><code>q</code> 停止录制</p>
</li>
<li>
<p><code>@{字符}</code> 重放宏</p>
</li>
<li>
<p>宏的执行遇错误会停止</p>
</li>
<li>
<p><code>{计数}@{字符}</code> 执行一个宏 {计数} 次</p>
</li>
<li>
<p>宏可以递归</p>
<ul>
<li>首先用 <code>q{字符}q</code> 清除宏</li>
<li>录制该宏， 用 <code>@{字符}</code> 来递归调用该宏 （在录制完成之前不会有任何操作）</li>
</ul>
</li>
<li>
<p>例子： 将 xml 转成 json (</p>
<p>file</p>
<p>)</p>
<ul>
<li>
<p>一个有 “name” / “email” 键对象的数组</p>
</li>
<li>
<p>用一个 Python 程序？</p>
</li>
<li>
<p>用 sed / 正则表达式</p>
<ul>
<li><code>g/people/d</code></li>
<li><code>%s/&lt;person&gt;/{/g</code></li>
<li><code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/&quot;name&quot;: &quot;\1&quot;,/g</code></li>
<li>…</li>
</ul>
</li>
<li>
<p>Vim 命令 / 宏</p>
<ul>
<li>
<p><code>Gdd</code>, <code>ggdd</code> 删除第一行和最后一行</p>
</li>
<li>
<p>格式化最后一个元素的宏 （寄存器</p>
<pre><code class="language-plaintext">e
</code></pre>
<p>）</p>
<ul>
<li>跳转到有 <code>&lt;name&gt;</code> 的行</li>
<li><code>qe^r&quot;f&gt;s&quot;: &quot;&lt;ESC&gt;f&lt;C&quot;&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>
<p>格式化一个人的宏</p>
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>
<p>格式化一个人然后转到另外一个人的宏</p>
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qq@pjq</code></li>
</ul>
</li>
<li>
<p>执行宏到文件尾</p>
<ul>
<li><code>999@q</code></li>
</ul>
</li>
<li>
<p>手动移除最后的 <code>,</code> 然后加上 <code>[</code> 和 <code>]</code> 分隔符</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="扩展资料">扩展资料</h1>
<ul>
<li><code>vimtutor</code> 是一个 Vim 安装时自带的教程</li>
<li><a href="https://vim-adventures.com/">Vim Adventures</a> 是一个学习使用 Vim 的游戏</li>
<li><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim Tips Wiki</a></li>
<li><a href="https://vimways.org/2019/">Vim Advent Calendar</a> 有很多 Vim 小技巧</li>
<li><a href="http://www.vimgolf.com/">Vim Golf</a> 是用 Vim 的用户界面作为程序语言的 <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li>
<li><a href="https://vi.stackexchange.com/">Vi/Vim Stack Exchange</a></li>
<li><a href="http://vimcasts.org/">Vim Screencasts</a></li>
<li><a href="https://pragprog.com/book/dnvim2/practical-vim-second-edition">Practical Vim</a> （书）</li>
</ul>
<h1 id="课后练习">课后练习</h1>
<ol>
<li>
<p>完成 <code>vimtutor</code>。 备注： 它在一个<br>
<a href="https://en.wikipedia.org/wiki/VT100">80x24</a> （80 列， 24 行）<br>
终端窗口看起来最好。✔️</p>
</li>
<li>
<p>下载我们的 <a href="/2020/files/vimrc">基本 vimrc</a>， 然后把它保存到 <code>~/.vimrc</code>。 通读这个注释详细的文件<br>
（用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。✔️</p>
</li>
<li>
<p>安装和配置一个插件：✔️<br>
<a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>.</p>
<ol>
<li>用 <code>mkdir -p ~/.vim/pack/vendor/start</code> 创建插件文件夹</li>
<li>下载这个插件： <code>cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim</code></li>
<li>读这个插件的<br>
<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。<br>
尝试用 CtrlP 来在一个工程文件夹里定位一个文件， 打开 Vim, 然后用 Vim 命令控制行开始<br>
<code>:CtrlP</code>.</li>
<li>自定义 CtrlP： 添加<br>
<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a><br>
到你的 <code>~/.vimrc</code> 来用按 Ctrl-P 打开 CtrlP</li>
</ol>
</li>
<li>
<p>练习使用 Vim, 在你自己的机器上重做 <a href="#demo">演示</a>。✔️</p>
<ul>
<li>main is never called
<ul>
<li><code>G</code> end of file</li>
<li><code>o</code> open new line below</li>
<li>type in &quot;if <strong>name</strong> ...&quot; thing</li>
</ul>
</li>
<li>starts at 0 instead of 1
<ul>
<li>search for <code>/range</code></li>
<li><code>ww</code> to move forward 2 words</li>
<li><code>i</code> to insert text, &quot;1, &quot;</li>
<li><code>ea</code> to insert after limit, &quot;+1&quot;</li>
</ul>
</li>
<li>newline for &quot;fizzbuzz&quot;
<ul>
<li><code>jj$i</code> to insert text at end of line</li>
<li>add &quot;, end=''&quot;</li>
<li><code>jj.</code> to repeat for second print</li>
<li><code>jjo</code> to open line below if</li>
<li>add &quot;else: print()&quot;</li>
</ul>
</li>
<li>fizz fizz
<ul>
<li><code>ci'</code> to change fizz</li>
</ul>
</li>
<li>command-line argument
<ul>
<li><code>ggO</code> to open above</li>
<li>&quot;import sys&quot;</li>
<li><code>/10</code></li>
<li><code>ci(</code> to &quot;int(sys.argv[1])&quot;</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># fizz_buzz.py
import sys

def fizz_buzz(limit):
    for i in range(1, limit+1):
        if i % 3 == 0:
            print('fizz', end='')
        if i % 5 == 0:
            print('buzz', end='')
        if i % 3 and i % 5:
            print(i)

def main():
    fizz_buzz(int(sys.argv[1]))

if __name__ == '__main__':
    main()
</code></pre>
</li>
<li>
<p>下个月用 Vim 做你 <em>所有</em> 文件编辑。 每当不够高效的时候, 或者你感觉 “一定有一个更好的方式”，<br>
尝试求助搜索引擎， 很有可能有一个更好的方式。 如果你遇到难题， 来我们的答疑时间或者给我们发邮件。✔️</p>
</li>
<li>
<p>在你的其他工具中设置 Vim 快捷键 （见上面的操作指南）。✔️</p>
</li>
<li>
<p>进一步自定义你的 <code>~/.vimrc</code> 和安装更多插件。✔️</p>
</li>
<li>
<p>（高阶） 用 Vim 宏将 XML 转换到 JSON (<a href="/2020/files/example-data.xml">例子文件</a>)。<br>
尝试着先完全自己做， 但是在你卡住的时候可以查看上面<br>
<a href="#macros">宏</a> 章节。✔️</p>
<ul>
<li>
<p>用 sed / 正则表达式</p>
<pre><code class="language-shell">cat example-data.xml | sed  '/people/d' | sed 's/&lt;person&gt;/{/g' | sed 's/&lt;\/person&gt;/},/g' | sed 's/&lt;name&gt;\(.*\)&lt;\/name&gt;/&quot;name&quot;: &quot;\1&quot;,/g' | sed 's/&lt;email&gt;\(.*\)&lt;\/email&gt;/&quot;email&quot;: &quot;\1&quot;/g' &gt;data_changed.json
# 手动移除最后的 , 然后加上 [ 和 ] 分隔符
</code></pre>
</li>
<li>
<p>Vim 命令 / 宏</p>
<ul>
<li><code>Gdd</code>, <code>ggdd</code> 删除第一行和最后一行</li>
<li>格式化name的宏 （寄存器e）
<ul>
<li>跳转到有 <code>&lt;name&gt;</code> 的行</li>
<li><code>qe^r&quot;f&gt;s&quot;: &quot;&lt;ESC&gt;f&lt;C&quot;&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>格式化person的宏
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>格式化一个人然后转到另外一个人的宏
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qq@pjq</code></li>
</ul>
</li>
<li>执行宏到文件尾
<ul>
<li><code>999@q</code></li>
</ul>
</li>
<li>手动移除最后的 <code>,</code> 然后加上 <code>[</code> 和 <code>]</code> 分隔符</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shell 工具和脚本]]></title>
        <id>https://umeimmense.github.io/post/shell-gong-ju-he-jiao-ben</id>
        <link href="https://umeimmense.github.io/post/shell-gong-ju-he-jiao-ben">
        </link>
        <updated>2022-05-01T15:50:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="shell-工具和脚本">Shell 工具和脚本</h1>
<blockquote>
<p>课程链接：<a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
</blockquote>
<h2 id="shell-脚本">Shell 脚本</h2>
<p>到目前为止，我们已经学习来如何在shell中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>
<p>shell脚本是一种更加复杂度的工具。</p>
<p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对shell所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是shell脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于bash脚本，因为它最流行，应用更为广泛。</p>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。<br>
需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。<br>
总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash中的字符串通过<code>'</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</p>
<pre><code class="language-bash">foo=bar
echo &quot;$foo&quot;
# 打印 bar
echo '$foo'
# 打印 $foo
</code></pre>
<p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地，<br>
, <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个函数并使用<code>cd</code>进入该文件夹。</p>
<pre><code class="language-bash">mcd () {
    mkdir -p &quot;$1&quot;
    cd &quot;$1&quot;
}
</code></pre>
<p>这里 <code>$1</code> 是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。<br>
返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p>
<p>退出码可以搭配<code>&amp;&amp;</code> (与操作符) 和 <code>||</code> (或操作符)使用，用来进行条件判断，决定是否执行其他程序。同一行的多个命令可以用<code>;</code>分隔。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。让我们看几个例子</p>
<pre><code class="language-bash">false || echo &quot;Oops, fail&quot;
# Oops, fail

true || echo &quot;Will not be printed&quot;
#

true &amp;&amp; echo &quot;Things went well&quot;
# Things went well

false &amp;&amp; echo &quot;Will not be printed&quot;
#

false ; echo &quot;This will always run&quot;
# This will always run
</code></pre>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em> (<em>command substitution</em>)实现。</p>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，然后它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<pre><code class="language-bash">#!/bin/bash

echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间

echo &quot;Running program $0 with $# arguments with pid $$&quot;

for file in $@; do
    grep foobar $file &gt; /dev/null 2&gt; /dev/null
    # 如果模式没有找到，则grep退出状态为 1
    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息
    if [[ $? -ne 0 ]]; then
        echo &quot;File $file does not have any foobar, adding one&quot;
        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;
    fi
done
</code></pre>
<p>在条件语句中，我们比较 <code>$?</code> 是否等于0。<br>
Bash实现了许多类似的比较操作，您可以查看 <a href="http://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。<br>
在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见<a href="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</p>
<p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 <em>通配</em>（ <em>globbing</em>）</p>
<ul>
<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
</ul>
<pre><code class="language-bash">convert image.{png,jpg}
# 会展开为
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# 会展开为
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# 也可以结合通配使用
mv *{.py,.sh} folder
# 会移动所有 *.py 和 *.sh 文件

mkdir foo bar

# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件
touch {foo,bar}/{a..h}
touch foo/x bar/y
# 显示foo和bar文件的不同
diff &lt;(ls foo) &lt;(ls bar)
# 输出
# &lt; x
# ---
# &gt; y
</code></pre>
<!-- Lastly, pipes `|` are a core feature of scripting. Pipes connect one program's output to the next program's input. We will cover them more in detail in the data wrangling lecture. -->
<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a>这样的工具可以帮助你定位sh/bash脚本中的错误。</p>
<p>注意，脚本并不一定只有用bash写才能在终端里调用。比如说，这是一段Python脚本，作用是将输入的参数倒序输出：</p>
<pre><code class="language-python">#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
</code></pre>
<p>shell知道去用python解释器而不是shell命令来运行这段脚本，是因为脚本的开头第一行的<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p>
<p>在 <code>shebang</code> 行中使用 <a href="http://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。<br>
例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code>。</p>
<p>shell函数和脚本有如下一些不同点：</p>
<ul>
<li>函数只能用与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="http://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ul>
<h1 id="shell-工具">Shell 工具</h1>
<h2 id="查看命令如何使用">查看命令如何使用</h2>
<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？<br>
一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>
<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<a href="http://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。<br>
事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code>来获取帮助。</p>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。<br>
<a href="https://tldr.sh/">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>
<p>例如，自己就常常在tldr上搜索<a href="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <a href="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a> 的用法。</p>
<h2 id="查找文件">查找文件</h2>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <a href="http://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a>的工具，它是shell上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p>
<pre><code class="language-bash"># 查找所有名称为src的文件夹
find . -name src -type d
# 查找所有文件夹路径中包含test的python文件
find . -path '**/test/**/*.py' -type f
# 查找前一天修改的所有文件
find . -mtime -1
# 查找所有大小在500k至10M的tar.gz文件
find . -size +500k -size -10M -name '*.tar.gz'
</code></pre>
<p>除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<pre><code class="language-bash"># Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;
# Find all PNG files and convert them to JPG
find . -name '*.png' -exec convert {} {}.jpg \;
</code></pre>
<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用alias设置别名来简化上述操作，但shell的哲学之一便是寻找（更好用的）替代方案。<br>
记住，shell最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如， <a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="http://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。<br>
<code>locate</code> 使用一个由 <a href="http://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="http://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">here</a>有一个更详细的对比。</p>
<h2 id="查找代码">查找代码</h2>
<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>
<p>为了实现这一点，很多类UNIX的系统都提供了<a href="http://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>
<p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p>
<p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>
<pre><code class="language-bash"># 查找所有使用了 requests 库的文件
rg -t py 'import requests'
# 查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match &quot;^#!&quot;
# 查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
# 打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN
</code></pre>
<p>与 <code>find</code>/<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>
<h2 id="查找-shell-命令">查找 shell 命令</h2>
<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。<br>
<code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a>中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。<br>
这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>最后，有一点值得注意，输入命令时，如果您在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
<h2 id="文件夹导航">文件夹导航</h2>
<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录<br>
间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <a href="http://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a>创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>
<p>对于本课程的主题来说，我们希望对常用的情况进行优化。使用<a href="https://github.com/clvv/fasd"><code>fasd</code></a>可以查找最常用和/或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en/The_Places_frecency_algorithm"><em>frecency</em></a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em> ）和时效（ <em>recency</em>）进行排序。</p>
<p>最直接的用法是自动跳转 （<em>autojump</em>），对于经常访问的目录，在目录名子串前加入一个命令 <code>z</code> 就可以快速切换命令到该目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<h1 id="课后练习">课后练习</h1>
<ol>
<li>
<p>阅读 <a href="http://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p>
<ul>
<li>所有文件（包括隐藏文件）</li>
<li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li>
<li>文件以最近访问顺序排序</li>
<li>以彩色文本显示输出结果</li>
</ul>
<p>典型输出如下：✔️</p>
<pre><code>-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
<pre><code class="language-shell">ls -lath --color=auto
</code></pre>
</li>
<li>
<p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。✔️</p>
<pre><code class="language-shell">marco(){
    export MARCO=$(pwd)  
}

polo(){
    cd &quot;$MARCO&quot;
}
</code></pre>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。✔️</p>
<pre><code class="language-shell"> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
    echo &quot;Something went wrong&quot;
    &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
    exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
<pre><code class="language-shell"># errcheck.sh
#! /bin/bash
./err.sh &gt; ./record.txt 2&gt; ./record.txt
m=1
while [ $? -eq 0 ]
do
    let m++
    ./err.sh &gt;&gt; ./record.txt 2&gt;&gt; ./record.txt
done
cat ./record.txt
echo &quot;run times: $m&quot;

</code></pre>
</li>
<li>
<p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="http://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p>
<p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>）✔️</p>
<ul>
<li>--delimiter=&quot;\n\b&quot; 以回车换行为分隔符</li>
</ul>
<pre><code class="language-shell"> find -name &quot;*.html&quot; | xargs --delimiter=&quot;\n\b&quot; zip -r taylorswift.zip
</code></pre>
<pre><code class="language-shell"> find . -type f -name &quot;*.html&quot; | xargs -d '\n'  tar -cvzf archive.tar.gz
</code></pre>
</li>
<li>
<p>(进阶) 编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？✔️</p>
<pre><code class="language-shell">find ./test/ -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head 
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[课程概览与 shell]]></title>
        <id>https://umeimmense.github.io/post/ke-cheng-gai-lan-yu-shell</id>
        <link href="https://umeimmense.github.io/post/ke-cheng-gai-lan-yu-shell">
        </link>
        <updated>2022-05-01T13:52:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>课程链接：<a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
</blockquote>
<h2 id="动机">动机</h2>
<p>作为计算机科学家，我们都知道计算机最擅长帮助我们完成重复性的工作。<br>
但是我们却常常忘记这一点也适用于我们使用计算机的方式，而不仅仅是利用计算机程序去帮我们求解问题。<br>
在从事与计算机相关的工作时，我们有很多触手可及的工具可以帮助我们更高效的解决问题。<br>
但是我们中的大多数人实际上只利用了这些工具中的很少一部分，我们常常只是死记硬背一些如咒语般的命令，<br>
或是当我们卡住的时候，盲目地从网上复制粘贴一些命令。</p>
<p>本课程意在帮你解决这一问题。</p>
<p>我们希望教会您如何挖掘现有工具的潜力，并向您介绍一些新的工具。也许我们还可以促使您想要去探索（甚至是去开发）更多的工具。<br>
我们认为这是大多数计算机科学相关课程中缺少的重要一环。</p>
<h2 id="课程结构">课程结构</h2>
<p>本课程包含 11 个时长在一小时左右的讲座，每一个讲座都会关注一个<br>
<a href="/missing-semester/2020/">特定的主题</a>。尽管这些讲座之间基本上是各自独立的，但随着课程的进行，我们会假定您已经掌握了之前的内容。<br>
每个讲座都有在线笔记供查阅，但是课上的很多内容并不会包含在笔记中。因此我们也会把课程录制下来发布到互联网上供大家观看学习。</p>
<p>我们希望能在这 11 个一小时讲座中涵盖大部分必须的内容，因此课程的信息密度是相当大的。为了能帮助您以自己的节奏来掌握讲座内容，每次课程都包含一组练习来帮助您掌握本节课的重点。<br>
课后我们会安排答疑的时间来回答您的问题。如果您参加的是在线课程，可以发送邮件到<br>
<a href="mailto:missing-semester@mit.edu">missing-semester@mit.edu</a> 来联系我们。</p>
<p>由于时长的限制，我们不可能达到那些专门课程一样的细致程度，我们会适时地将您介绍一些优秀的资源，帮助您深入的理解相关的工具或主题。<br>
但是如果您还有一些特别关注的话题，也请联系我们。</p>
<h1 id="shell-是什么">shell 是什么？</h1>
<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。<br>
这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。<br>
为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>
<p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>本节课我们会使用 Bourne Again SHell, 简称 &quot;bash&quot; 。<br>
这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开shell <em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>
<h2 id="使用-shell">使用 shell</h2>
<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>
<pre><code class="language-shell">missing:~$ 
</code></pre>
<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（&quot;current working directory&quot;）或者说您当前所在的位置是 <code>~</code> (表示 &quot;home&quot;)。 <code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入 <em>命令</em> ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p>
<pre><code class="language-shell">missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
</code></pre>
<p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日前和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em> ：</p>
<pre><code class="language-shell">missing:~$ echo hello
hello
</code></pre>
<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。<br>
shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em>  <code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p>
<pre><code class="language-shell">missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用<br>
<code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p>
<h2 id="在shell中导航">在shell中导航</h2>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如：<br>
<code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p>
<pre><code class="language-shell">missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
</code></pre>
<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>
<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>
<pre><code class="language-shell">missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
</code></pre>
<p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p>
<pre><code class="language-shell">  -l                         use a long listing format
</code></pre>
<pre><code class="language-shell">missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
</code></pre>
<p>这个参数可以打印出更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示<br>
<code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。<br>
（<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。</p>
<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <code>mv</code>（用于重命名或移动文件）、 <code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>
<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p>
<pre><code class="language-console">missing:~$ man ls
</code></pre>
<h2 id="在程序间创建连接">在程序间创建连接</h2>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。<br>
当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。<br>
通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。<br>
但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<pre><code class="language-sh">missing:~$ echo hello &gt; hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat &lt; hello.txt
hello
missing:~$ cat &lt; hello.txt &gt; hello2.txt
missing:~$ cat hello2.txt
hello
</code></pre>
<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。<br>
<code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<pre><code class="language-sh">missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
</code></pre>
<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>
<h2 id="一个功能全面又强大的工具">一个功能全面又强大的工具</h2>
<p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。<br>
您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。<br>
通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。<br>
取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。<br>
当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>
<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。<br>
因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p>
<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p>
<pre><code class="language-sh">/sys/class/backlight
</code></pre>
<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>
<pre><code class="language-sh">$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 &gt; brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
</code></pre>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了<br>
<code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。<br>
<code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。<br>
对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p>
<p>明白这一点后，我们可以这样操作：</p>
<pre><code class="language-sh">$ echo 3 | sudo tee brightness
</code></pre>
<p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。<br>
这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p>
<pre><code class="language-sh">$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
</code></pre>
<h2 id="接下来">接下来.....</h2>
<p>学到这里，您掌握的 shell 知识已经可以完成一些基础的任务了。您应该已经可以查找感兴趣的文件并使用大多数程序的基本功能了。<br>
在下一场讲座中，我们会探讨如何利用 shell 及其他工具执行并自动化更复杂的任务。</p>
<h1 id="课后练习">课后练习</h1>
<ol>
<li>
<p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。✔️</p>
<pre><code class="language-shell">mkdir missing
</code></pre>
</li>
<li>
<p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。✔️</p>
<pre><code class="language-shell">man touch
</code></pre>
</li>
<li>
<p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。✔️</p>
<pre><code class="language-shell">touch semester
</code></pre>
</li>
<li>
<p>将以下内容一行一行地写入<code>semester</code>文件：</p>
<pre><code class="language-shell"> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting手册</a>✔️</p>
<pre><code class="language-shell">echo \#'!'/bin/sh &gt; semester
echo curl --head --silent https://missing.csail.mit.edu &gt;&gt; semester
</code></pre>
</li>
<li>
<p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code>命令来获取信息并理解其不能执行的原因。✔️</p>
<blockquote>
<p>提示权限不够</p>
<p>执行<code>ls -l</code>命令</p>
<p>显示<code>-rw-r--r-- ...</code>显然没有可执行<code>x</code>权限</p>
</blockquote>
</li>
<li>
<p>查看 <code>chmod</code> 的手册(例如，使用<code>man chmod</code>命令)✔️</p>
<pre><code class="language-shell">man chmod
</code></pre>
</li>
<li>
<p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用<code>sh semester</code>来执行该程序。您的shell是如何知晓这个文件需要使用<code>sh</code>来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>✔️</p>
<pre><code class="language-shell">chmod ugo+x semester
./semester
</code></pre>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入根目录下的 <code>last-modified.txt</code> 的文件中✔️</p>
<pre><code class="language-shell">./semester | grep -i &quot;last-modified&quot; &gt; /home/last-modified.txt
</code></pre>
</li>
<li>
<p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机CPU的温度。注意：macOS并没有sysfs，所以mac用户可以跳过这一题✔️</p>
<pre><code class="language-shell">cat /sys/class/power_supply/battery/capacity
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是 DNS？ | DNS 的工作方式]]></title>
        <id>https://umeimmense.github.io/post/shi-me-shi-dns-or-dns-de-gong-zuo-fang-shi</id>
        <link href="https://umeimmense.github.io/post/shi-me-shi-dns-or-dns-de-gong-zuo-fang-shi">
        </link>
        <updated>2022-04-28T14:13:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>阅读本文后，你将能够了解到一下内容：</p>
<ul>
<li>定义 DNS</li>
<li>理解 DNS 的工作方式</li>
<li>区分递归和迭代 DNS 查找</li>
<li>将权威性域名服务器与递归 DNS 解析器分开</li>
<li>探索 DNS 高速缓存的工作方式</li>
</ul>
<h2 id="什么是-dns">什么是 DNS？</h2>
<p>域名系统 (DNS) 是互联网的电话簿。人们通过例如 nytimes.com 或 espn.com 等域名在线访问信息。Web 浏览器通过 互联网协议 （IP） 地址进行交互。DNS 将域名转换为 IP 地址，以便浏览器能够加载互联网资源。<br>
连接到 Internet 的每个设备都有一个唯一 IP 地址，其他计算机可使用该 IP 地址查找此设备。DNS 服务器使人们无需存储例如 192.168.1.1（IPv4 中）等 IP 地址或更复杂的较新字母数字 IP 地址，例如 2400:cb00:2048:1::c629:d7a2（IPv6 中）。</p>
<h2 id="dns-如何工作">DNS 如何工作？</h2>
<p>DNS 解析过程涉及将主机名（例如 www.example.com）转换为计算机友好的 IP 地址（例如 192.168.1.1）。Internet 上的每个设备都被分配了一个 IP 地址，必须有该地址才能找到相应的 Internet 设备 - 就像使用街道地址来查找特定住所一样。当用户想要加载网页时，用户在 Web 浏览器中键入的内容（example.com）与查找 example.com 网页所需的机器友好地址之间必须进行转换。</p>
<p>为理解 DNS 解析过程，务必了解 DNS 查询必须通过的各种硬件设备。对于 Web 浏览器而言，DNS 查询是“在幕后”发生的，除了初始请求外，不需要从用户的计算机进行任何交互。</p>
<h2 id="加载网页涉及-4-个-dns-服务器">加载网页涉及 4 个 DNS 服务器：</h2>
<ul>
<li><code>DNS 解析器</code> - 该解析器可被视为被要求去图书馆的某个地方查找特定图书的图书馆员。DNS 解析器是一种服务器，旨在通过 Web 浏览器等应用程序接收客户端计算机的查询。然后，解析器一般负责发出其他请求，以便满足客户端的 DNS 查询。</li>
<li><code>根域名服务器</code> - 根域名服务器是将人类可读的主机名转换（解析）为 IP 地址的第一步。可将其视为指向不同书架的图书馆中的索引 - 一般其作为对其他更具体位置的引用。</li>
<li><code>TLD 名称服务器</code> —— 顶级域名服务器（TLD）可看做是图书馆中一个特殊的书架。这个域名服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 example.com 中，TLD 服务器为 “com”）。</li>
<li><code>权威性域名服务器</code> - 可将这个最终域名服务器视为书架上的字典，其中特定名称可被转换成其定义。权威性域名服务器是域名服务器查询中的最后一站。如果权威性域名服务器能够访问请求的记录，则其会将已请求主机名的 IP 地址返回到发出初始请求的 DNS 解析器（图书管理员）。</li>
</ul>
<h2 id="权威性-dns-服务器与递归-dns-解析器之间的区别是什么">权威性 DNS 服务器与递归 DNS 解析器之间的区别是什么？</h2>
<p>这两个概念都是指 DNS 基础设施不可或缺的服务器（服务器组），但各自担当不同的角色，并且位于 DNS 查询管道内的不同位置。考虑二者差异的一种方式是，递归解析器位于 DNS 查询的开头，而权威性域名服务器位于末尾。</p>
<h3 id="递归-dns-解析器">递归 DNS 解析器</h3>
<p>递归解析器是一种计算机，其响应来自客户端的递归请求并花时间追踪 DNS 记录。为执行此操作，其发出一系列请求，直至到达用于所请求的记录的权威性 DNS 域名服务器为止（或者超时，或者如果未找到记录，则返回错误）。幸运的是，递归 DNS 解析器并不总是需要发出多个请求才能追踪响应客户端所需的记录；缓存是一种数据持久性过程，可通过在 DNS 查找中更早地服务于所请求的资源记录来为所需的请求提供捷径。</p>
<figure data-type="image" tabindex="1"><img src="https://umeimmense.github.io/post-images/1651069131124.webp" alt="" loading="lazy"></figure>
<h3 id="权威性-dns-服务器">权威性 DNS 服务器</h3>
<p>简言之，权威性 DNS 服务器是实际持有并负责 DNS 资源记录的服务器。这是位于 DNS 查找链底部的服务器，其将使用所查询的资源记录进行响应，从而最终允许发出请求的 Web 浏览器达到访问网站或其他 Web 资源所需的 IP 地址。权威性域名服务器从自身数据满足查询需求，无需查询其他来源，因为这是某些 DNS 记录的最终真实来源。<br>
<img src="https://umeimmense.github.io/post-images/1651069180375.webp" alt="" loading="lazy"><br>
值得一提的是，在查询对象为子域（例如 foo.example.com 或 blog.example.com）的情况下，将向权威性域名服务器之后的序列添加一个附加域名服务器，其负责存储该子域的 CNAME 记录。<br>
<img src="https://umeimmense.github.io/post-images/1651069212505.webp" alt="" loading="lazy"></p>
<h2 id="dns-查找有哪些步骤">DNS 查找有哪些步骤？</h2>
<p>大多数情况下，DNS 与正被转换为相应 IP 地址的域名有关。要了解此过程的工作方式，在 DNS 查找从 Web 浏览器经过 DNS 查找过程然后再返回时，跟踪 DNS 查找的路径会有所帮助。我们来看一下这些步骤。</p>
<p>注意：通常，DNS 查找信息将本地缓存在查询计算机内，或者远程缓存在 DNS 基础设施内。DNS 查找通常有 8 个步骤。缓存 DNS 信息时，将从 DNS 查找过程中跳过一些步骤，从而使该过程更快。以下示例概述了不缓存任何内容时的所有 8 个步骤。</p>
<h3 id="dns-查找的-8-个步骤">DNS 查找的 8 个步骤：</h3>
<ol>
<li>
<p>用户在 Web 浏览器中键入 “example.com”，查询传输到 Internet 中，并被 DNS 递归解析器接收。</p>
</li>
<li>
<p>接着，解析器查询 DNS 根域名服务器（.）。</p>
</li>
<li>
<p>然后，根服务器使用存储其域信息的顶级域（TLD）DNS 服务器（例如 .com 或 .net）的地址响应该解析器。在搜索 example.com 时，我们的请求指向 .com TLD。</p>
</li>
<li>
<p>然后，解析器向 .com TLD 发出请求。</p>
</li>
<li>
<p>TLD 服务器随后使用该域的域名服务器 example.com 的 IP 地址进行响应。</p>
</li>
<li>
<p>最后，递归解析器将查询发送到域的域名服务器。</p>
</li>
<li>
<p>example.com 的 IP 地址而后从域名服务器返回解析器。</p>
</li>
<li>
<p>然后 DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。<br>
DNS 查找的这 8 个步骤返回 example.com 的 IP 地址后，浏览器便能发出对该网页的请求：</p>
</li>
<li>
<p>浏览器向该 IP 地址发出 HTTP 请求。</p>
</li>
<li>
<p>位于该 IP 的服务器返回将在浏览器中呈现的网页（第 10 步）。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://umeimmense.github.io/post-images/1651069273938.webp" alt="" loading="lazy"></figure>
<h3 id="什么是-dns-解析器">什么是 DNS 解析器？</h3>
<p>DNS 解析器是 DNS 查找的第一站，其负责与发出初始请求的客户端打交道。解析器启动查询序列，最终使 URL 转换为必要的 IP 地址。</p>
<p>注意：典型的未缓存 DNS 查找将涉及递归查询和迭代查询。</p>
<p>务必区分递归 DNS 查询和递归 DNS 解析器。该查询是指向需要解析该查询的 DNS 解析器发出的请求。DNS 递归解析器是一种计算机，其接受递归查询并通过发出必要的请求来处理响应。<br>
<img src="https://umeimmense.github.io/post-images/1651069314691.webp" alt="" loading="lazy"></p>
<h2 id="dns-查询有哪些类型">DNS 查询有哪些类型？</h2>
<p>典型 DNS 查找中会出现三种类型的查询。通过组合使用这些查询，优化的 DNS 解析过程可缩短传输距离。在理想情况下，可以使用缓存的记录数据，从而使 DNS 域名服务器能够返回非递归查询。<br>
3 种 DNS 查询类型：</p>
<ol>
<li>递归查询 - 在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息。</li>
<li>迭代查询 - 在这种情况下，DNS 客户端将允许 DNS 服务器返回其能够给出的最佳应答。如果所查询的 DNS 服务器与查询名称不匹配，则其将返回对较低级别域名空间具有权威性的 DNS 服务器的引用。然后，DNS 客户端将对引用地址进行查询。此过程继续使用查询链中的其他 DNS 服务器，直至发生错误或超时为止。</li>
<li>非递归查询 - 当 DNS 解析器客户端查询 DNS 服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。DNS 服务器通常会缓存 DNS 记录，以防止更多带宽消耗和上游服务器上的负载。</li>
</ol>
<h2 id="什么是-dns-高速缓存dns-高速缓存发生在哪里">什么是 DNS 高速缓存？DNS 高速缓存发生在哪里？</h2>
<p>缓存的目的是将数据临时存储在某个位置，从而提高数据请求的性能和可靠性。DNS 高速缓存涉及将数据存储在更靠近请求客户端的位置，以便能够更早地解析 DNS 查询，并且能够避免在 DNS 查找链中进一步向下的额外查询，从而缩短加载时间并减少带宽/CPU 消耗。DNS 数据可缓存到各种不同的位置上，每个位置均将存储 DNS 记录并保存由生存时间（TTL）决定的一段时间。</p>
<h3 id="浏览器-dns-缓存">浏览器 DNS 缓存</h3>
<p>现代 Web 浏览器设计为默认将 DNS 记录缓存一段时间。目的很明显；越靠近 Web 浏览器进行 DNS 缓存，为检查缓存并向 IP 地址发出正确请求而必须采取的处理步骤就越少。发出对 DNS 记录的请求时，浏览器缓存是针对所请求的记录而检查的第一个位置。</p>
<p>在 Chrome 浏览器中，您可以转到 chrome://net-internals/#dns 查看 DNS 缓存的状态。</p>
<h3 id="操作系统os级-dns-缓存">操作系统（OS）级 DNS 缓存</h3>
<p>操作系统级 DNS 解析器是 DNS 查询离开您计算机前的第二站，也是本地最后一站。操作系统内旨在处理此查询的过程通常称为“存根解析器”或 DNS 客户端。当存根解析器获取来自某个应用程序的请求时，其首先检查自己的缓存，以便查看是否有此记录。如果没有，则将本地网络外部的 DNS 查询（设置了递归标记）发送到 Internet 服务提供商（ISP）内部的 DNS 递归解析器。</p>
<p>与先前所有步骤一样，当 ISP 内的递归解析器收到 DNS 查询时，其还将查看所请求的主机到 IP 地址转换是否已经存储在其本地持久性层中。</p>
<p>根据其缓存中具有的记录类型，递归解析器还具有其他功能：</p>
<p>如果解析器没有 A 记录，但确实有针对权威性域名服务器的 NS 记录，则其将直接查询这些域名服务器，从而绕过 DNS 查询中的几个步骤。此快捷方式可防止从根和 .com 域名服务器（在我们对 example.com 的搜索中）进行查找，并且有助于更快地解析 DNS 查询。<br>
如果解析器没有 NS 记录，它会向 TLD 服务器（本例中为 .com）发送查询，从而跳过根服务器。<br>
万一解析器没有指向 TLD 服务器的记录，其将查询根服务器。这种情况通常在清除了 DNS 高速缓存后发生。</p>
<blockquote>
<p><a href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/">原文地址</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook: 实现 useHash 获取 url 上的 hash 值]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hook-shi-xian-usehash-huo-qu-url-shang-de-hash-zhi</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hook-shi-xian-usehash-huo-qu-url-shang-de-hash-zhi">
        </link>
        <updated>2022-04-27T14:47:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-usehash">实现 useHash</h2>
<p>本节我们实现自定义React hook useHash，它能实时获取浏览器的hash值，并允许更改它。</p>
<ul>
<li>使用 useState hook 获取 Location 对象的 hash 属性。</li>
<li>使用 useCallback hook 创建一个更新状态的处理程序。</li>
<li>在挂载时使用 useEffect hook为“hashchange”事件添加监听器，并在卸载时清理它。</li>
<li>使用 useCallback hook 创建一个函数，该函数使用给定值更新 Location 对象的哈希属性。</li>
</ul>
<h3 id="实现">实现</h3>
<pre><code class="language-jsx">const useHash = () =&gt; {
const [hash, setHash] = React.useState(() =&gt; window.location.hash);

const hashChangeHandler = React.useCallback(() =&gt; {
  setHash(window.location.hash);
}, []);

React.useEffect(() =&gt; {
  window.addEventListener('hashchange', hashChangeHandler);
  return () =&gt; {
    window.removeEventListener('hashchange', hashChangeHandler);
  };
}, []);

const updateHash = React.useCallback(
  newHash =&gt; {
    if (newHash !== hash) window.location.hash = newHash;
  },
  [hash]
);

return [hash, updateHash];
};
</code></pre>
<h3 id="样例">样例</h3>
<pre><code class="language-jsx">  const MyApp = () =&gt; {
  const [hash, setHash] = useHash();

  React.useEffect(() =&gt; {
    setHash('#list');
  }, []);

  return (
    &lt;&gt;
      &lt;p&gt;window.location.href: {window.location.href}&lt;/p&gt;
      &lt;p&gt;Edit hash: &lt;/p&gt;
      &lt;input value={hash} onChange={e =&gt; setHash(e.target.value)} /&gt;
    &lt;/&gt;
  );
};

ReactDOM.render(&lt;MyApp /&gt;, document.getElementById('root'));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook: 实现只在更新时执行的 useUpdateEffect]]></title>
        <id>https://umeimmense.github.io/post/react-zi-ding-yi-hooks-useupdateeffect</id>
        <link href="https://umeimmense.github.io/post/react-zi-ding-yi-hooks-useupdateeffect">
        </link>
        <updated>2022-04-27T14:03:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-useupdateeffect">实现 useUpdateEffect</h2>
<p>本节我们实现自定义React hook useUpdateEffect ，它会忽略第一次的副作用，只在后续更新时执行。</p>
<pre><code class="language-jsx">import * as React from 'react';

const App = () =&gt; {
  const [toggle, setToggle] = React.useState(true);

  const handleToggle = () =&gt; {
    setToggle(!toggle);
  };

  const didMount = React.useRef(false);

  React.useEffect(() =&gt; {
    if (didMount.current) {
      console.log('I run only if toggle changes.');
    } else {
      didMount.current = true;
    }
  }, [toggle]);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;

      {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p>如果你定义一个可复用的自定义Hook，它只在更新时（而不是在挂载时）触发效果函数，你可以使用下面的hook：</p>
<pre><code class="language-jsx">import * as React from 'react';

const useEffectOnlyOnUpdate = (callback, dependencies) =&gt; {
  const didMount = React.useRef(false);

  React.useEffect(() =&gt; {
    if (didMount.current) {
      callback(dependencies);
    } else {
      didMount.current = true;
    }
  }, [callback, dependencies]);
};

const App = () =&gt; {
  const [toggle, setToggle] = React.useState(true);

  const handleToggle = () =&gt; {
    setToggle(!toggle);
  };

  useEffectOnlyOnUpdate((dependencies) =&gt; {
    console.log('I run only if toggle changes.');
  }, [toggle]);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;

      {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Search]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-search</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-search">
        </link>
        <updated>2022-04-17T08:13:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，将实现带有搜索功能的 React Table。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户在表中搜索数据。</p>
<h2 id="实现">实现</h2>
<p>React Table库没有自带搜索功能，但是，由于你可以从外部访问数据，因此你可以在将其传递给表之前对其进行操作。让我们看看这是如何工作的。</p>
<p>首先，创建一个 React useState Hook - 保存搜索的状态 - 和一个新的事件处理程序 - 作为稍后用户交互的回调函数：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  ...
};
</code></pre>
<p>接下来，在 Table 组件中，添加一个 HTML 输入字段来设置搜索状态：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>搜索状态生效。最后 展示的就是Table 组件之前搜索项目列表：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  const data = {
    nodes: nodes.filter((item) =&gt;
      item.name.includes(search)
    ),
  };

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  const data = {
    nodes: nodes.filter((item) =&gt;
      item.name.includes(search)
    ),
  };

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>如果你希望Table搜索不区分大小写，则需要调整过滤器功能：</p>
<pre><code class="language-jsx">const data = {
  nodes: nodes.filter((item) =&gt;
    item.name.toLowerCase().includes(search.toLowerCase())
  ),
};
</code></pre>
<p>React Table 没有为搜索功能提供原生插件。但是，你可以将搜索到的列表从外部传递到Table并从外部进行搜索，因此你拥有所有选项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Sort]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort">
        </link>
        <updated>2022-04-17T06:01:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table Library 及其 useSort 插件来实现排序功能。在前面的例子中，你已经安装了 React Table Library 来创建一个 Table 组件。现在，我们将允许用户通过单击列标题对Table中的列进行排序。</p>
<h2 id="实现">实现</h2>
<p>首先，导入 useSort Hook：</p>
<pre><code class="language-jsx">import { useSort } from '@table-library/react-table-library/sort';
</code></pre>
<p>其次，使用Table的数据对其进行初始化，并将其作为 prop 传递给 Table 组件：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data);

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>之后，将你的标题列转换为可排序的：</p>
<pre><code class="language-jsx">import {
  useSort,
  HeaderCellSort ,
} from '@table-library/react-table-library/sort';

const App = () =&gt; {
  ...

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCellSort sortKey=&quot;TASK&quot;&gt;
                Task
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;DEADLINE&quot;&gt;
                Deadline
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;TYPE&quot;&gt;
                Type
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;COMPLETE&quot;&gt;
                Complete
              &lt;/HeaderCellSort&gt;
            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>然后为每个排序键创建各自的排序函数：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data, null, {
    sortFns: {
      TASK: (array) =&gt;
        array.sort((a, b) =&gt; a.name.localeCompare(b.name)),
      DEADLINE: (array) =&gt;
        array.sort((a, b) =&gt; a.deadline - b.deadline),
      TYPE: (array) =&gt;
        array.sort((a, b) =&gt; a.type.localeCompare(b.type)),
      COMPLETE: (array) =&gt;
        array.sort((a, b) =&gt; a.isComplete - b.isComplete),
    },
  });

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>只需几行，你就有一个可排序的Table。我们可以按字符串排序（按字母顺序）、按日期排序、按布尔值排序和按枚举排序。由于自己传递了 sortBy 函数，因此如何对列进行排序取决于sortBy 函数。</p>
<p>可能缺少的获取当前排序的onChange事件。让我们看看它是如何与 useSort 结合使用的：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data,
    {
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  function onSortChange(action, state) {
    console.log(action, state);
  }

  ...
};
</code></pre>
<p>onChange 回调函数使你可以访问触发排序更改的操作以及Table的实际排序状态。通过访问此信息，你可以基于它触发更多的Table或非Table事件（例如，服务器端排序等副作用）。</p>
<p>最后，值得注意的是，你传递给Table的排序对象包含排序状态——这使你能够随时访问它——以及以编程方式对列进行排序的所有函数。当在这个 React Table中使用自定义排序组件时，我们稍后会详细看到这一点。<br>
无论如何，表中的列排序通常会带来更多要求。让我们来看看其中的两个：</p>
<p>例如，有时用户想要具有初始排序状态。这也可以通过 useSort 来实现，方法是传入一个默认的排序状态：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const sort = useSort(data,
    {
      state: {
        sortKey: 'TASK',
        reverse: false,
      },
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  ...
};
</code></pre>
<p>另一个案例是将排序图标与来自第三方库（例如 Material UI）的自定义排序图标交换：</p>
<pre><code class="language-jsx">import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';

const App = () =&gt; {
  ...

  const sort = useSort(
    data,
    {
      onChange: onSortChange,
    },
    {
      sortIcon: {
        margin: '0px',
        iconDefault: &lt;UnfoldMoreOutlinedIcon /&gt;,
        iconUp: &lt;KeyboardArrowUpOutlinedIcon /&gt;,
        iconDown: (
          &lt;KeyboardArrowDownOutlinedIcon /&gt;
        ),
      },
      sortFns: ...
    }
  );

  ...
};
</code></pre>
<p>排序功能还有更多选项。只需前往 <a href="https://react-table-library.com/?path=/docs/features-sort--base">React Table 文档</a>以了解有关它们的更多信息。</p>
<p>最后，使用 React Table Library 可以完全用自定义组件交换排序组件。对于我们的表格排序插件，我们可能希望将排序标题组件与我们自己的来自第三方库的 HTML 按钮进行交换。下面，你将看到一个如何在 React 表库中使用 Material UI 组件的示例。</p>
<p>首先，从你的第三方库中导入自定义组件（和自定义图标）：</p>
<pre><code class="language-jsx">import MaterialButton from '@mui/material/Button';
import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';
</code></pre>
<p>其次Table Header 使用第三方按钮：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const getIcon = (sortKey) =&gt; {
    if (sort.state.sortKey === sortKey &amp;&amp; sort.state.reverse) {
      return &lt;KeyboardArrowDownOutlinedIcon /&gt;;
    }

    if (sort.state.sortKey === sortKey &amp;&amp; !sort.state.reverse) {
      return &lt;KeyboardArrowUpOutlinedIcon /&gt;;
    }

    return &lt;UnfoldMoreOutlinedIcon /&gt;;
  };

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCell&gt;
                &lt;MaterialButton
                  fullWidth
                  style={{ justifyContent: 'flex-start' }}
                  endIcon={getIcon('TASK')}
                  onClick={() =&gt;
                    sort.fns.onToggleSort({
                      sortKey: 'TASK',
                    })
                  }
                &gt;
                  Task
                &lt;/MaterialButton&gt;
              &lt;/HeaderCell&gt;

              ...

            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};

</code></pre>
<p>请注意 useSort 中的排序对象如何为你提供创建自定义组件所需的一切。这样，你可以为每个表格列自定义排序组件。通过使用排序状态和所有排序功能，你可以从任何地方读取和写入排序状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Resize]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize">
        </link>
        <updated>2022-04-17T05:41:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本教程中，我想向你展示如何使用 React Table Library 及其调整大小功能。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户调整表中列的大小。</p>
<h2 id="实现">实现</h2>
<p>首先在Table的列上设置 resize 属性</p>
<pre><code class="language-jsx">&lt;Header&gt;
  &lt;HeaderRow&gt;
    &lt;HeaderCell resize&gt;Task&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Deadline&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Type&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Complete&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Tasks&lt;/HeaderCell&gt;
  &lt;/HeaderRow&gt;
&lt;/Header&gt;
</code></pre>
<p>这是为Table启用可调整大小的列的最直接的方法。但是，如果你想有更多的配置选项，你可以传递一个对象。<br>
例如，如果使用默认值，你可以为每个表格列定义最小宽度。</p>
<pre><code class="language-jsx">&lt;HeaderCell resize={{ minWidth: 50 }}&gt;Task&lt;/HeaderCell&gt;
</code></pre>
<p>你还可以调整大小区域的突出显示颜色并扩大调整区域的大小：</p>
<pre><code class="language-jsx">&lt;HeaderCell
  resize={{
    resizerWidth: 15,
    resizerHighlight: '#98d8ff',
  }}
&gt;
  Task
&lt;/HeaderCell&gt;
</code></pre>
]]></content>
    </entry>
</feed>