<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2022-03-02T19:01:40.801Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[探索 React 18 的三个新 API]]></title>
        <id>https://umeimmense.github.io/post/tan-suo-react-18-de-san-ge-xin-api</id>
        <link href="https://umeimmense.github.io/post/tan-suo-react-18-de-san-ge-xin-api">
        </link>
        <updated>2022-03-02T16:16:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>目前 React 生态系统中最大的话题是 React 18 及其备受期待的并发渲染功能的完整发布。 2021 年 6 月，React 团队宣布了 React 18 的计划以及即将发生的事情。 2021年 12 月，React Conf 2021 的主题是所有新发布的并发渲染功能。</p>
<p>与 React 18 一起发布的几个新 API 允许用户充分利用 React 的并发渲染功能。 这些hook是：</p>
<ul>
<li><a href="#the-usesyncexternalstore-hook">useSyncExternalStore</a></li>
<li><a href="#the-useid-hook">useId</a></li>
<li><a href="#the-useinsertioneffect-hook">useInsertionEffect</a></li>
</ul>
<p>本文将介绍这三个新 API、它们的用例、它们解决的问题、添加它们的原因以及它们如何集成到并发渲染领域。</p>
<h1 id="the-usesyncexternalstore-hook">the-usesyncexternalstore-hook</h1>
<p>在 React v16.14.0 中引入的用于适应并发渲染的 API 之一是 useMutableSource，它旨在允许 React 组件在并发渲染期间安全有效地与外部可变源集成。</p>
<p>Hook 将附加到数据源，等待更改，并相应地安排更新。 所有这一切都会以一种防止撕裂的方式发生，即当出现视觉不一致时，因为同一状态有多个值。</p>
<p>这对于新的并发渲染特性来说是一个特别突出的问题，因为状态流可以很快地交织在一起。 然而，采用 useMutableSource 被证明是困难的，原因如下：</p>
<ol>
<li>Hook 是异步的<br>
Hook 不知道如果选择器函数的结果值发生变化，它是否可以重用它。 唯一的解决方案是重新订阅提供的数据源并再次检索快照，这可能会导致性能问题，因为它发生在每次渲染上。</li>
</ol>
<p>对于用户和库（如 Redux），这意味着他们必须记住项目中的每个选择器，并且无法内联定义选择器函数，因为它们的引用不稳定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 18 并发（Concurrent）渲染的入门指南]]></title>
        <id>https://umeimmense.github.io/post/concurrent-rendering</id>
        <link href="https://umeimmense.github.io/post/concurrent-rendering">
        </link>
        <updated>2022-03-02T07:21:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>目前 React 领域最热门的话题是 React 18 版本。 特别是，该版本将引入一组所谓的并发渲染功能。 这些特性允许开发者选择 React 的并发渲染机制。 这种机制为 React 开发人员提供了一个全新的机会来控制和优化最终用户的体验。 这绝对是自 hooks 以来，我们在 React 世界中将收到的最令人兴奋的事情之一。</p>
<p>因此，你很可能以前听说过并发渲染。 可能是关于它的文章、围绕它的 API，或者 React 18 将为它带来什么。 但是，你可能会对并发渲染的基础知识感到疑惑。 究竟什么是并发渲染，为什么我们真的需要它？</p>
<p>为了帮助你理解，本文将讨论这些问题。 通过研究它的目的、它试图解决什么问题以及它是如何解决它的，你将获得有关并发渲染主题的基础知识。</p>
<h2 id="为什么我们需要并发渲染">为什么我们需要并发渲染？</h2>
<p>React 当前形式的问题之一是所有状态更新都是同步的。 这意味着 React 只能一一处理它们。 在许多用例和现实生活场景中，这非常好，不会对用户体验施加任何限制。</p>
<p>但是在 React 想要获取与其当前正在处理的状态更新不同的状态更新的情况下，现在这显然是不可能的。 React 在启动后无法中断、暂停或放弃渲染更新——这是一个阻塞的进程。</p>
<p>从本质上讲，这对优化用户体验的过程设置了上限。 虽然很高，但还是有上限的。 每个状态更新都被视为同等重要，即使这不适用于用户体验。 某些更新可能比其他更新具有更高的优先级或紧迫性。 与可能的情况相比，不能这样做实际上会对用户体验产生巨大的负面影响，这是次优的。</p>
<h2 id="什么是并发渲染">什么是并发渲染？</h2>
<p>并发渲染是一组功能，允许你的 React 项目选择所谓的可中断渲染。 与之前 React 被阻塞的渲染过程相反，这使得渲染过程可以从 React 端中断，这正是并发渲染的用武之地。这为 React 开发人员进一步提升 React 应用程序的用户体验开辟了许多新的可能性。</p>
<p>它允许 React 一次处理多个状态更新。 然而，这并不意味着 React 会突然同时执行所有排队状态更新。 相反，选择并发渲染允许 React 考虑其最佳行动方案。 幸运的是，这也是我们作为开发人员可以控制的事情。</p>
<p>假设 React 当前正在处理状态更新并且有一个不同的更新进来，那么 React 可以根据变量的因素做出不同的决定。 如果新的传入状态更新被标记为同等或不那么紧急，那么与之前的渲染过程相比没有任何变化。 React 将像往常一样继续当前状态更新。 完成后，它将获取新的状态更新。</p>
<p>但是如果新传入的状态更新被标记为更紧急，那么 React 可以决定暂停当前状态更新并首先处理传入的更新。 在完成新的更紧急的状态更新后，React 会回到原来的状态更新。 如果它确定有必要恢复它，它会这样做。 如果事实证明状态更新现在无关紧要，它可以决定完全放弃它。</p>
<h2 id="下一步是什么">下一步是什么？</h2>
<p>本文简要介绍了 React 18 将为 React 开发领域带来的最激动人心的功能之一，即并发渲染，并让你快速了解整个主题。 使用本文中的知识，你应该知道什么是并发渲染，了解它试图解决的问题，并大致了解它的工作原理。</p>
<p>幸运的是，并发渲染并不止于此。 虽然并发渲染还有很多方面需要理解或深入研究，但本文作为介绍以进入整个主题，并允许你从这里开始进一步探索 React 18。</p>
<p>下面准备了一些资料<br>
<a href="https://umeimmense.github.io/post/tan-suo-react-18-de-san-ge-xin-api/">这里</a>介绍了 React 18 中引入的三个新 API。所有这些 API 都是允许某些开发人员在某些场景中选择并发渲染的hook。<br>
<a href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html">官方的 React 18 公告</a>是了解更多关于 React 18、不同特性、如何采用它以及关于即将发布的 React 版本的所有信息的好地方。<br>
<a href="https://github.com/reactwg/react-18/discussions">React 工作组</a>是了解更多技术方面、获得更多指导、了解不同 API 和特性背后的思维过程以及总体上更深入地了解 React 18 中所有内容的好地方。<br>
这就是全部！ 现在你已经牢牢掌握了并发渲染的主题，在 React 18 中为你打开了一个全新的世界供你探索。走出去，探索并享受这个新的冒险！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Router 6：搜索参数]]></title>
        <id>https://umeimmense.github.io/post/react-router-6sou-suo-can-shu</id>
        <link href="https://umeimmense.github.io/post/react-router-6sou-suo-can-shu">
        </link>
        <updated>2021-12-17T03:29:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文我们讨论如何在 React Router 6 中使用搜索参数。搜索参数是一项强大的功能，它使你能够捕获 URL 中的状态。通过在 URL 中包含状态，你可以与其他人实现共享。例如，如果应用程序显示产品目录，开发人员将使用户能够搜索它。在 React 中，这将转换为项目列表（此处为：产品）和用于过滤它们的 HTML 输入字段。</p>
<p>现在，React 开发人员很有可能会使用 React 的 useState Hook 来管理这种搜索状态。这对这个用户来说很好，但不适合与其他用户共享。</p>
<p>因此，一个不错的方式是在 URL 中管理搜索状态，因为这样搜索状态就可以与其他用户共享。如果一个用户按标题（例如“Rust”）搜索项目列表，则搜索参数将作为键值对附加到 URL，例如 /bookshelf?title=Rust，因为可以与另一个用户共享。所以获得链接的其他用户将在其页面上看到相同的过滤项目列表。<br>
<img src="https://umeimmense.github.io/post-images/1640100507004.webp" alt="" loading="lazy"></p>
<h2 id="react-router-从状态到-url">React Router 从状态到 URL</h2>
<p>首先，我们将实现上一个所设想的那样，其中有一个项目列表，并通过 HTML 输入字段进行搜索。我们不会使用 React 的 useState Hook 来捕获搜索状态，而是使用 React Router 来获取可共享的 URL。 App 组件如下所示，类似于前面提到的 React Router 教程中的 App 组件：</p>
<pre><code class="language-jsx">const App = () =&gt; {
 return (
   &lt;&gt;
     &lt;h1&gt;React Router&lt;/h1&gt;

     &lt;nav&gt;
       &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
       &lt;Link to=&quot;/bookshelf&quot;&gt;Bookshelf&lt;/Link&gt;
     &lt;/nav&gt;

     &lt;Routes&gt;
       &lt;Route index element={&lt;Home /&gt;} /&gt;
       &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
       &lt;Route path=&quot;bookshelf&quot; element={&lt;Bookshelf /&gt;} /&gt;
       &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
     &lt;/Routes&gt;
   &lt;/&gt;
 );
};
</code></pre>
<p>虽然 Home 和 NoMatch 组件只是具有任何实现的占位符组件，但我们将关注 Bookshelf 组件，它将Books显示为列表组件。这些Books示例数据可以从远程 API（或模拟 API）获取：</p>
<pre><code class="language-jsx">const Bookshelf = () =&gt; {
  const books = [
    {
      title: 'The Road to Rust',
      isCompleted: false,
    },
    {
      title: 'The Road to React',
      isCompleted: true,
    },
  ];

  return (
    &lt;&gt;
      &lt;h2&gt;Bookshelf&lt;/h2&gt;

      &lt;ul&gt;
        {books.map((book) =&gt; (
          &lt;li key={book.title}&gt;{book.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>为了使用户能够通过不区分大小写的标题匹配来过滤此列表，我们使用 React 的 useState Hook 和 HTML 输入字段。最后，事件处理程序将从输入字段中读取值并将其写入状态：</p>
<pre><code class="language-jsx">const byTitle = (title) =&gt; (book) =&gt;
  book.title.toLowerCase().includes((title || '').toLowerCase());

const Bookshelf = () =&gt; {
  const books = [...];

  const [title, setTitle] = React.useState('');

  const handleTitle = (event) =&gt; {
    setTitle(event.target.value);
  };

  return (
    &lt;&gt;
      &lt;h2&gt;Bookshelf&lt;/h2&gt;

      &lt;input type=&quot;text&quot; value={title} onChange={handleTitle} /&gt;

      &lt;ul&gt;
        {books.filter(byTitle(title)).map((book) =&gt; (
          &lt;li key={book.title}&gt;{book.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>这就是就是“在 React 中使用状态”的版本。接下来，我们要使用 React Router 来在 URL 中捕获此状态。React Router 为我们提供了 useSearchParams hook，它几乎可以用来替代 React 的 useState hook：</p>
<pre><code class="language-jsx">import * as React from 'react';
import {
  Routes,
  Route,
  Link,
  useSearchParams,
} from 'react-router-dom';

...

const Bookshelf = () =&gt; {
  const books = [...];

  const [search, setSearch] = useSearchParams();

  const handleTitle = (event) =&gt; {
    setSearch({ title: event.target.value });
  };

  return (
    &lt;&gt;
      &lt;h2&gt;Bookshelf&lt;/h2&gt;

      &lt;input
        type=&quot;text&quot;
        value={search.get('title')}
        onChange={handleTitle}
      /&gt;

      &lt;ul&gt;
        {books.filter(byTitle(search.get('title'))).map((book) =&gt; (
          &lt;li key={book.title}&gt;{book.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>由于以下两点，它不能直接替代 React 的 useState Hook。首先，它对一个对象而不是字符串进行操作，因为一个 URL 可以有多个搜索参数（例如 /bookshelf?title=Rust&amp;rating=4），因此每个搜索参数都成为该对象中的一个属性（例如<code>{ title: 'Rust', rating: 4 }</code>)。</p>
<p>如果我们将 React 的 useState Hook 与对象而不是字符串一起使用，它本质上与我们之前的实现类似：</p>
<pre><code class="language-jsx">const [search, setSearch] = React.useState({ title: '' });
</code></pre>
<p>然而，即使 useSearchParams 返回的有状态值是对象类型（typeof search === 'object'），它仍然不能像单纯的 JavaScript 对象数据结构那样访问，因为它是 URLSearchParams 的一个实例。因此我们需要调用它的 getter 方法（例如 search.get('title')）。</p>
<p>其次，React Router 的 useSearchParams Hook 不接受初始状态，因为初始状态来自 URL。因此，当用户与搜索参数（例如 /bookshelf?title=Rust）共享 URL 时，另一个用户将从 React Router 的 Hook 获得 { title: 'Rust' } 作为初始状态。当应用程序将用户导航到带有搜索参数且设置了可选搜索参数的路线时，也会发生同样的情况。</p>
<p>这就是使用状态的 URL 而不是使用 React 的状态管理 Hook 之一。它极大地改善了用户体验，因为 URL 变得更加特定于用户在页面上看到的内容。因此，这个特定的 URL 可以与其他用户共享，他们将看到具有相同 UI 的页面。</p>
<h2 id="urlsearchparams-转换为对象">URLSEARCHPARAMS 转换为对象</h2>
<p>如果你在处理 React Router 的 useSearchParams Hook 时不想使用 URLSearchParams，你可以编写一个自定义hook，它返回一个 JavaScript 对象而不是 URLSearchParams 的实例：</p>
<pre><code class="language-jsx">const useCustomSearchParams = () =&gt; {
  const [search, setSearch] = useSearchParams();
  const searchAsObject = Object.fromEntries(
    new URLSearchParams(search)
  );

  return [searchAsObject, setSearch];
};

const Bookshelf = () =&gt; {
  const books = [...];

  const [search, setSearch] = useCustomSearchParams();

  const handleTitle = (event) =&gt; {
    setSearch({ title: event.target.value });
  };

  return (
    &lt;&gt;
      &lt;h2&gt;Bookshelf&lt;/h2&gt;

      &lt;input
        type=&quot;text&quot;
        value={search.title}
        onChange={handleTitle}
      /&gt;

      &lt;ul&gt;
        {books.filter(byTitle(search.title)).map((book) =&gt; (
          &lt;li key={book.title}&gt;{book.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>然而，这个自定义hook应该有一点不足，因为它不适用于重复键（例如带有 ?editions=1&amp;editions=3 的数组搜索参数）和使用复杂 URL 时的其他边界情况。</p>
<p>一般来说，仅使用 React Router 的 useSearchParams Hook（或这个自定义的 useCustomSearchParams hook）并不能为你提供 URL 状态管理的完整体验，因为它仅可用于字符串而不能用于其他数据类型。我们将在接下来的部分中探讨这一点以及如何解决这个问题。</p>
<h2 id="搜索参数与保留数据类型">搜索参数与保留数据类型</h2>
<p>并非所有状态都只包含字符串。在前面使用 React Router 的搜索参数的例子中，我们使用了一个字符串（这里是：title），它被编码到 URL 中。当从 URL 解码这个字符串时，我们将默认得到一个字符串——这在我们的例子中有效，因为我们需要一个字符串。但是其他原始数据类型如数字或布尔值呢？更不用说复杂的数据类型，例如数组。</p>
<p>为了探索解决这个，我们将通过实现一个复选框来继续之前的示例。我们将使用这个复选框组件并将其连接到 React Router 的搜索参数：</p>
<pre><code class="language-jsx">const bySearch = (search) =&gt; (book) =&gt;
  book.title
    .toLowerCase()
    .includes((search.title || '').toLowerCase()) &amp;&amp;
  book.isCompleted === search.isCompleted;

const Bookshelf = () =&gt; {
  const books = [...];

  const [search, setSearch] = useCustomSearchParams();

  const handleTitle = (event) =&gt; {
    setSearch({ title: event.target.value });
  };

  const handleIsCompleted = (event) =&gt; {
    setSearch({ isCompleted: event.target.checked });
  };

  return (
    &lt;&gt;
      &lt;h2&gt;Bookshelf&lt;/h2&gt;

      &lt;input
        type=&quot;text&quot;
        value={search.title}
        onChange={handleTitle}
      /&gt;

      &lt;Checkbox
        label=&quot;Is Completed?&quot;
        value={search.isCompleted}
        onChange={handleIsCompleted}
      /&gt;

      &lt;ul&gt;
        {books.filter(bySearch(search)).map((book) =&gt; (
          &lt;li key={book.title}&gt;{book.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>在浏览器中实验以下。你将看到对 isCompleted 布尔值的搜索不起作用，因为来自我们的搜索对象的 isCompleted 被表示为一个字符串，如“true”或“false”。我们可以通过增强我们的自定义hook来规避这一点：</p>
<pre><code class="language-jsx">const useCustomSearchParams = (param = {}) =&gt; {
  const [search, setSearch] = useSearchParams();
  const searchAsObject = Object.fromEntries(
    new URLSearchParams(search)
  );

  const transformedSearch = Object.keys(param).reduce(
    (acc, key) =&gt; ({
      ...acc,
      [key]: param[key](acc[key]),
    }),
    searchAsObject
  );

  return [transformedSearch, setSearch];
};

const PARAMS = {
  BooleanParam: (string = '') =&gt; string === 'true',
};

const Bookshelf = () =&gt; {
  const books = [...];

  const [search, setSearch] = useCustomSearchParams({
    isCompleted: PARAMS.BooleanParam,
  });

  ...

  return (...);
};
</code></pre>
<p>本质上，新版本的自定义hook采用具有可选转换功能的对象。它遍历每个转换函数，如果找到转换函数和搜索参数之间的匹配项，则将该函数应用于搜索参数。在这种情况下，我们将字符串布尔值（“true”或“false”）转换为实际的布尔值。如果没有找到匹配项，它只返回原始搜索参数。因此我们不需要标题的转换函数，因为它是一个字符串并且可以继续为字符串。</p>
<p>通过拥有自定义hook的实现细节，我们还可以创建其他转换器函数（例如 NumberParam），从而填补缺失数据类型转换（例如数字）的空白：</p>
<pre><code class="language-javascript">const PARAMS = {
  BooleanParam: (string = '') =&gt; string === 'true',
  NumberParam: (string = '') =&gt; (string ? Number(string) : null),
  // other transformation functions to map all data types
};
</code></pre>
<p>开源组件中use-query-params这个库完美的解决这个问题。</p>
<h2 id="react-router-使用搜索参数">React Router 使用搜索参数</h2>
<p><a href="https://github.com/pbeshai/use-query-params">use-query-params</a> 库非常适合将复杂的 URL 用作超越字符串的状态的用例。在本节中，我们将探索 use-query-params 库，从而摆脱我们自定义的 useSearchParams hook。</p>
<p>自己按照库的安装说明进行操作。你需要在命令行上安装该库并在 React 项目的根级别实例化它：</p>
<pre><code class="language-jsx">import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter, Route } from 'react-router-dom';
import { QueryParamProvider } from 'use-query-params';

import App from './App';

ReactDOM.render(
  &lt;BrowserRouter&gt;
    &lt;QueryParamProvider ReactRouterRoute={Route}&gt;
      &lt;App /&gt;
    &lt;/QueryParamProvider&gt;
  &lt;/BrowserRouter&gt;,
  document.getElementById('root')
);
</code></pre>
<p>然而， use-query-params 还没有正确适应 React Router 6。因此，你可能会看到以下错误弹出：“<Route> 仅用作 <Routes> 元素的子元素，永远不会直接呈现。请将你的 <Route> 包装在 <Routes> 中。”。因此，在根级别调整你的代码：</p>
<pre><code class="language-jsx">import React from 'react';
import ReactDOM from 'react-dom';
import {
  BrowserRouter,
  useNavigate,
  useLocation,
} from 'react-router-dom';
import { QueryParamProvider } from 'use-query-params';

import App from './App';

const RouteAdapter = ({ children }) =&gt; {
  const navigate = useNavigate();
  const location = useLocation();

  const adaptedHistory = React.useMemo(
    () =&gt; ({
      replace(location) {
        navigate(location, { replace: true, state: location.state });
      },
      push(location) {
        navigate(location, { replace: false, state: location.state });
      },
    }),
    [navigate]
  );
  return children({ history: adaptedHistory, location });
};

ReactDOM.render(
  &lt;BrowserRouter&gt;
    &lt;QueryParamProvider ReactRouterRoute={RouteAdapter}&gt;
      &lt;App /&gt;
    &lt;/QueryParamProvider&gt;
  &lt;/BrowserRouter&gt;,
  document.getElementById('root')
);
</code></pre>
<p>现在你可以使用 use-query-params 在 React 中进行强大的 URL 状态管理。你所要做的就是使用新的 useQueryParams 钩子。另请注意，与我们的自定义钩子相比，你还需要“转换”字符串搜索参数：</p>
<pre><code class="language-jsx">import * as React from 'react';
import { Routes, Route, Link } from 'react-router-dom';
import {
  useQueryParams,
  StringParam,
  BooleanParam,
} from 'use-query-params';

...

const Bookshelf = () =&gt; {
  const books = [...];

  const [search, setSearch] = useQueryParams({
    title: StringParam,
    isCompleted: BooleanParam,
  });

  ...

  return (...);
};
</code></pre>
<p>你还可以提供合理的默认值。例如，此时在没有搜索参数的情况下导航到 /bookshelf 时，title 和 isComplete 将是未定义的。但是，如果你希望它们至少是标题的空字符串和 isComplete 的 false，你可以提供这些默认值，例如：</p>
<pre><code class="language-jsx">import * as React from 'react';
import { Routes, Route, Link } from 'react-router-dom';
import {
  useQueryParams,
  StringParam,
  BooleanParam,
  withDefault
} from 'use-query-params';

...

const Bookshelf = () =&gt; {
  const books = [...];

  const [search, setSearch] = useQueryParams({
    title: withDefault(StringParam, ''),
    isCompleted: withDefault(BooleanParam, false),
  });

  ...

  return (...);
};
</code></pre>
<p>还有一件值得注意的事情要提到：目前，use-query-params 使用默认的“push in”模式，这意味着每次附加搜索参数时，它不会覆盖其他搜索参数。因此，你在更改其中之一的同时保留所有搜索参数。但是，如果这不是你想要的行为，你还可以更改模式（例如，更改为“push”），这样将不再保留以前的搜索参数（尽管这在我们的场景中没有意义）：</p>
<pre><code class="language-jsx">const Bookshelf = () =&gt; {
  ...

  const handleTitle = (event) =&gt; {
    setSearch({ title: event.target.value }, 'push');
  };

  const handleIsCompleted = (event) =&gt; {
    setSearch({ isCompleted: event.target.checked }, 'push');
  };

  ...

  return (...);
};
</code></pre>
<p>除了我们在这里使用的两种数据类型转换之外，还有对数字、数组、对象等的转换。例如，如果你希望在 React 中有一个可选择的表，你可能希望将表中的每个选定行表示为数组中的标识符（在 use-query-params 中，它是 ArrayParam 转换）映射到实际 URL .然后你可以与另一个用户共享此 URL，该用户将从所选行开始。</p>
<p>使用 URL 作为状态是改善用户体验的方式。在处理单个或多个字符串状态时，React Router 的搜索参数为你提供了一个很好的体验。但是，一旦你想保留映射到 URL 的数据类型，你可能希望使用诸如 use-query-params 之类的库在 React 中进行复杂的 URL 状态管理。</p>
<h2 id="参考">参考</h2>
<p><a href="https://pbeshai.github.io/use-query-params/">use-query-params</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Router 6：嵌套路由]]></title>
        <id>https://umeimmense.github.io/post/react-router-6qian-tao-lu-you</id>
        <link href="https://umeimmense.github.io/post/react-router-6qian-tao-lu-you">
        </link>
        <updated>2021-12-14T03:28:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文教你如何在 React Router 6 中使用嵌套路由。嵌套路由是一个强大的功能。虽然大多数人认为 React Router 只会在页面之间路由使用，但它也允许用户根据当前路由交换视图的特定片段。例如，在用户页面上，会显示多个选项卡（例如个人资料、帐户）以浏览用户信息。通过单击这些选项卡，浏览器中的 URL 会发生变化，但不会替换整个页面，只会替换选项卡的内容。<br>
<img src="https://umeimmense.github.io/post-images/1639933512952.webp" alt="" loading="lazy"><br>
下面我们将使用 React Router 重新创建这个场景。为了说明这是如何工作的，以及如何自己在 React 中逐步实现嵌套路由，我们将从以下示例开始：</p>
<pre><code class="language-jsx">import { Routes, Route, Link } from 'react-router-dom';

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;nav&gt;
        &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
        &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt;
      &lt;/nav&gt;

      &lt;Routes&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;user&quot; element={&lt;User /&gt;} /&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>在这个函数组件中，我们使用了 React Router 中的 Link 和 Route 组件，用于 home/ 和 user/ 路由。此外，我们有一个加载了 Home 组件的所谓的索引路由和一个加载了 NoMatch 组件的所谓的 No Match 路由。两者都作为备选路线。从这里开始，我们将了解嵌套路由的概念。</p>
<h2 id="react-router-中的嵌套路由">React Router 中的嵌套路由</h2>
<p>我们将继续处理 User 组件，这是我们希望通过选项卡进行嵌套路由的地方。因此，我们将实例化一组新的 Link 组件（将是我们的无样式选项卡），用于将用户导航到他们的个人资料和他们的帐户。</p>
<pre><code class="language-jsx">const User = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;User&lt;/h1&gt;

      &lt;nav&gt;
        &lt;Link to=&quot;/user/profile&quot;&gt;Profile&lt;/Link&gt;
        &lt;Link to=&quot;/user/account&quot;&gt;Account&lt;/Link&gt;
      &lt;/nav&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>我们在这里使用绝对路径将用户从他们的个人资料导航到他们的帐户，反之亦然，但是，我们也可以使用相对路径作为最佳实践。因为 User 组件位于 /user 路由中，所以 Link 组件可以预测它们的父路由（这里是：/user），并且只需将相对路径（这里：profile 和 account）附加到它（例如 /user/profile）：</p>
<pre><code class="language-jsx">const User = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;User&lt;/h1&gt;

      &lt;nav&gt;
        &lt;Link to=&quot;profile&quot;&gt;Profile&lt;/Link&gt;
        &lt;Link to=&quot;account&quot;&gt;Account&lt;/Link&gt;
      &lt;/nav&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>此时，当我们尝试在 React 应用程序中单击这些链接之一时，我们将被困在我们的 No Match Route 中。这告诉我们，我们还没有将这些路由（此处：/user/profile 和 /user/account）映射到任何实际的路由组件。因此，我们将这两个新路由作为所谓的嵌套路由添加到我们的 /user 路由中：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;nav&gt;
        &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
        &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt;
      &lt;/nav&gt;

      &lt;Routes&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;user&quot; element={&lt;User /&gt;}&gt;
          &lt;Route path=&quot;profile&quot; element={&lt;Profile /&gt;} /&gt;
          &lt;Route path=&quot;account&quot; element={&lt;Account /&gt;} /&gt;
        &lt;/Route&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>Route 组件现在以一对一的关系映射到 Link 组件。但是，可以有多个 Link 组件链接到同一个路由，因此它实际上是一对多的关系。</p>
<p>在浏览器中对此进行测试时，我们将看到仅显示 User 组件，而不会显示其嵌套的 Profile 组件，也不会显示其嵌套的 Account 组件。我们缺少 React Router 的关键 Outlet 组件：</p>
<pre><code class="language-jsx">import { Routes, Route, Link, Outlet } from 'react-router-dom';

...

const User = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;User&lt;/h1&gt;

      &lt;nav&gt;
        &lt;Link to=&quot;profile&quot;&gt;Profile&lt;/Link&gt;
        &lt;Link to=&quot;account&quot;&gt;Account&lt;/Link&gt;
      &lt;/nav&gt;

      &lt;Outlet /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>Outlet 组件从父 Routes 的 Route 组件集合中使用其各自的组件（此处为 Profile 或 Account 组件）呈现匹配的子路由。<br>
<img src="https://umeimmense.github.io/post-images/1639933949387.webp" alt="" loading="lazy"><br>
如果没有 /profile 和 /account 路由匹配（例如 /user/settings），你将只看到 User 组件出现。为避免这种情况，你可以添加索引和无匹配路由的组合。之后，默认路由将是 /profile 路由：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;nav&gt;
        &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
        &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt;
      &lt;/nav&gt;

      &lt;Routes&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;user&quot; element={&lt;User /&gt;}&gt;
          &lt;Route index element={&lt;Profile /&gt;} /&gt;
          &lt;Route path=&quot;profile&quot; element={&lt;Profile /&gt;} /&gt;
          &lt;Route path=&quot;account&quot; element={&lt;Account /&gt;} /&gt;
          &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
        &lt;/Route&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>虽然 User 组件总是将选项卡呈现为导航，但其内容（Outlet）被匹配的嵌套路由（基于 /user/profile 或 /user/account 路由的 Profile 或 Account 组件）替换。如果在访问 /user 路由时这些路由都不匹配，应用程序将显示 Profile 组件（如果路由与 /user 完全匹配）或 NoMatch 组件（如果路由不匹配，例如 /user/setting）出现。</p>
<h2 id="react-router-中的-动态嵌套路由">React router 中的 动态嵌套路由</h2>
<p>在嵌套路由的下一个示例中，我们将从 App 组件中开始。这次我们不想像之前那样渲染静态嵌套路由（例如 /user/profile），而是基于标识符的动态嵌套路由（例如 /users/1 用于显示具有标识符 1 并因此匹配此路由的用户）。因此，我们将示例从单用户路由 (/user) 调整为多用户路由 (/user)。</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const users = [
    { id: '1', fullName: 'Robin Wieruch' },
    { id: '2', fullName: 'Sarah Finnley' },
  ];

  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;nav&gt;
        &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
        &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
      &lt;/nav&gt;

      &lt;Routes&gt;
        &lt;Route element={&lt;Layout /&gt;}&gt;
          &lt;Route index element={&lt;Home /&gt;} /&gt;
          &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
          &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;} /&gt;
          &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>Users 组件成为 React 中的列表组件，因为它遍历每个用户并为其返回 JSX。在这种情况下，它不仅仅是一个列表，因为我们将 React Router 的 Link 组件添加到组合中。 Link 组件中的相对路径提示相应的嵌套（此处：/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi></mrow><mi mathvariant="normal">嵌</mi><mi mathvariant="normal">套</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">但</mi><mi mathvariant="normal">动</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">此</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{user.id} 嵌套在 /users 中）但动态（此处：/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span><span class="mord cjk_fallback">嵌</span><span class="mord cjk_fallback">套</span><span class="mord cjk_fallback">在</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">动</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">：</span><span class="mord">/</span></span></span></span>{user.id}）路由：</p>
<pre><code class="language-jsx">const Users = ({ users }) =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;

      &lt;ul&gt;
        {users.map((user) =&gt; (
          &lt;li key={user.id}&gt;
            &lt;Link to={user.id}&gt;
              {user.fullName}
            &lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>通过拥有这个新的动态嵌套路由，我们需要在 App 组件中为它创建一个匹配的嵌套路由组件。首先，由于它是 /users 路由的所谓嵌套路由（或子路由），我们可以将它嵌套在相应的父路由组件中。此外，由于它是所谓的动态路由，它使用定义为 :userId 的动态路由，而用户的标识符则动态匹配（例如，id 为 '1' 的用户将与 /users/1 匹配）：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const users = [
    { id: '1', fullName: 'Robin Wieruch' },
    { id: '2', fullName: 'Sarah Finnley' },
  ];

  return (
    &lt;h1&gt;React Router&lt;/h1&gt;

    &lt;nav&gt;...&lt;/nav&gt;

    &lt;Routes&gt;
      &lt;Route element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt;
          &lt;Route path=&quot;:userId&quot; element={&lt;User /&gt;} /&gt;
        &lt;/Route&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
};
</code></pre>
<p>这样，User 组件就变成了 Users 组件的嵌套路由。因此，再次在 Outlet 组件的帮助下渲染其嵌套路由是用户组件的责任——再次渲染匹配的子路由：</p>
<pre><code class="language-jsx">import { Routes, Route, Link, Outlet } from 'react-router-dom';

...

const Users = ({ users }) =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;

      &lt;ul&gt;...&lt;/ul&gt;

      &lt;Outlet /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>接下来，我们将声明缺少的 User 组件，只要用户的标识符在 URL 中匹配，该组件就会通过 Users 组件中的 Outlet 嵌套。在这个新组件中，我们可以使用 React Router 的 useParams Hook 从 URL 中获取相应的 userId（等于 :userId）：</p>
<pre><code class="language-jsx">import {
  ...
  useParams,
} from 'react-router-dom';

...

const User = () =&gt; {
  const { userId } = useParams();

  return (
    &lt;&gt;
      &lt;h2&gt;User: {userId}&lt;/h2&gt;

      &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>我们已经看到了如何通过将一个 Route 组件（或多个 Route 组件）嵌套在另一个 Route 组件中来创建嵌套路由。前者是嵌套的子路由，后者是渲染封闭组件的父路由，该组件必须使用 Outlet 组件来渲染实际匹配的子路由。</p>
<p>此外，我们还看到了如何通过在路由的路径属性中使用冒号（例如：userId）来创建动态路由。本质上， :userId 充当任何标识符的星号。在我们的例子中，我们使用 Link 组件将用户导航到 /users/:userId 路由，其中​​ :userId 代表实际用户的标识符。最后，我们总是可以通过使用 React Router 的 useParams Hook 从 URL 中获取动态路径（称为参数或 params）。</p>
<p>如果你碰巧将 React Router 用于你的 React 应用程序，嵌套路由可以通过让你的用户访问你的应用程序非常特定的部分，同时将这些部分作为 URL 共享，从而极大地提升你的用户体验。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ JavaScript 中的 Heap]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-dui</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-dui">
        </link>
        <updated>2021-12-13T03:18:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>之前我们已经研究了树数据结构的实现以及它的一些变体，例如 trie。在这篇文章中，我们将深入研究堆。它也称为优先级队列。</p>
<h2 id="什么是堆">什么是堆？</h2>
<p>堆是树数据结构的一种变体，具有两个附加属性：<br>
1.它是一棵完全二叉树：一棵完全二叉树的每一层都包含最大数量的节点，可能最后一层除外，它必须从左到右填充。完整的二叉树总是通过它的定义来平衡的。作为参考下图显示了什么时候可以将树称为完全二叉树：<br>
<img src="https://umeimmense.github.io/post-images/1639723723975.jpeg" alt="" loading="lazy"><br>
2.每个节点都满足“堆属性”：堆属性本质上意味着对于任何给定的节点 C，如果 P 是 C 的父节点，则：</p>
<ul>
<li>对于最大堆：P 的键应该大于或等于 C 的键。</li>
<li>对于最小堆：P 的键应该小于或等于 C 的键。<br>
<img src="https://umeimmense.github.io/post-images/1639723881691.jpeg" alt="" loading="lazy"></li>
</ul>
<h2 id="如何表示堆">如何表示堆？</h2>
<p>我们通常从节点的类表示开始实现，然后将其与实际数据结构本身的类表示联系起来。我们也可以对堆做同样的事情。但是，有一种更简单的方法可以解决此问题，这是因为所有堆都必须遵守以下两个属性之一：</p>
<blockquote>
<p>所有堆必须是完全二叉树<br>
由于所有堆都必须是完全二叉树，并且我们知道完全二叉树中除最后一层外的所有级别都必须完全填充。此外，对于最后一层，所有子项必须从左到右方向填充，没有任何间隙。这个定义确保了一个由 n 个节点组成的完全二叉树只能有 1 种可能的形状。反过来，它允许我们使用数组来表示完整的二叉树。这意味着，堆也可以使用数组来表示。例如，我们可以将一个简单的堆表示为一个数组，如下图所示：<br>
<img src="https://umeimmense.github.io/post-images/1639724054342.jpeg" alt="" loading="lazy"><br>
这里要注意的关键是父节点和子节点之间的关系。如果仔细观察上图，我们可以推断出以下内容：</p>
</blockquote>
<ol>
<li>如果节点位于数组中的索引 i 处，则假设结果索引位于数组的长度内：</li>
</ol>
<ul>
<li>它的左孩子将在第 (2i+1) 个位置</li>
<li>左孩子将在 (2i+2) 位置</li>
</ul>
<ol start="2">
<li>如果一个节点被放置在数组中的索引 i 处，它的父节点将位于第 ((i-1)/2) 个索引处。<br>
下图可以更轻松地使用上述信息：<br>
<img src="https://umeimmense.github.io/post-images/1639724181146.jpeg" alt="" loading="lazy"></li>
</ol>
<h2 id="具体实现">具体实现</h2>
<blockquote>
<p>注意：在整个实现过程中，我们只会讨论最小堆。稍后我们将看到如何将相同的想法轻松扩展到最大堆。</p>
</blockquote>
<p>在我们已经涵盖了表示的细节，让我们想出一个使用数据结构的接口。在堆数据结构的帮助下，我们希望能够实现三个关键点：</p>
<ul>
<li>向堆中添加一个新键</li>
<li>从堆中删除最大或最小键（取决于它是最小堆还是最大堆）</li>
<li>从堆中获取最小键的最大值（取决于是最小堆还是最大堆）</li>
</ul>
<p>第三个操作很简单。我们知道对于最小堆，数组中的第一项将是最小键，同样对于最大堆，数组中的第一项将是最大键。所以我们剩下两个操作的实现：</p>
<pre><code class="language-javascript">// adds the provided newKey into the min-heap named &quot;heap&quot;
function heappush(heap, newKey){}

// removes the smallest key from the min-heap named &quot;heap&quot;
function heappop(heap){}
</code></pre>
<h3 id="实现heappush">实现heappush()</h3>
<p>我们如何向堆中添加一个新键？假设我们首先将新键推送到数组中。推送新键仍然让我们遵守堆的第一个要求，即它必须是一个完整的二叉树。但是，我们需要确保它也遵守“堆属性”。<br>
我们可以通过将push的项与其父项进行比较来做到这一点。如果父项大于的push的项，那么我们知道堆属性被违反，因此我们可以交换。我们可以继续进行这种交换，直到找到一个合法的父节点或者我们已经到达堆的顶部。<br>
<img src="https://umeimmense.github.io/post-images/1639724511455.jpeg" alt="" loading="lazy"><br>
代码如下</p>
<pre><code class="language-javascript">function heappush(heap, newKey){
  // push the new key 
  heap.push(newKey);

  // get the current index of pushed key
  let curr = heap.length-1;

 // keep comparing till root is reached or we terminate in middle
  while(curr &gt; 0){
    let parent = Math.floor((curr-1)/2)
    if( heap[curr] &lt; heap[parent] ){
      // quick swap
      [ heap[curr], heap[parent] ] = [ heap[parent], heap[curr] ]
      // update the index of newKey
      curr = parent
    } else{
      // if no swap, break, since we heap is stable now
      break
    }
  } 
}
</code></pre>
<h3 id="实现-heappop">实现 heappop()</h3>
<p>使用 <code>heappop()</code> 我们需要删除堆的最顶层元素。意思是，对于最小堆，最小键将被删除，而对于最大堆，最大键将被删除。从数组的角度来看，它只是意味着我们应该删除数组的第一项。但是哪个节点应该成为根？如果我们随机选择被移除节点的左孩子或右孩子作为新的根节点，则不能保证遵循堆属性。我们可以按照以下步骤（对于最小堆）：</p>
<ol>
<li>将根节点与最后一个节点交换（数组中的第一个元素与最后一个元素）</li>
<li>通过从数组中弹出最后一项来删除根节点</li>
<li>将新根节点的键与其子节点进行比较：</li>
</ol>
<ul>
<li>如果键小于它的两个子键，则堆是稳定的</li>
<li>否则，将Key与较小的子Key交换</li>
</ul>
<ol start="4">
<li>重复步骤 3，直到到达最后一个子节点或建立堆属性。</li>
</ol>
<p>本质上，我们遵循与 heappush() 类似的过程，除了我们试图以从上到下的方式建立堆属性，即从根开始并一直持续到最后一个孩子。在 heappush() 中，我们遵循相反的顺序，即从最后一个孩子开始，一直到根。<br>
代码实现：</p>
<pre><code class="language-javascript">function heappop(heap){
  // swap root with last node
  const n = heap.length;
  [heap[0], heap[n-1]] = [ heap[n-1], heap[0]]

  // remove the root i.e. the last item (because of swap)
  const removedKey = heap.pop();

  let curr = 0;

  // keep going till atleast left child is possible for current node
  while(2*curr + 1 &lt; heap.length){
    const leftIndex = 2*curr+1; 
    const rightIndex = 2*curr+2;
    const minChildIndex = (rightIndex &lt; heap.length &amp;&amp; heap[rightIndex] &lt; heap[leftIndex] ) ? rightIndex :leftIndex;
    if(heap[minChildIndex] &lt; heap[curr]){
     // quick swap, if smaller of two children is smaller than the parent (min-heap)
      [heap[minChildIndex], heap[curr]] = [heap[curr], heap[minChildIndex]]
      curr = minChildIndex
    } else {
      break
    }
  }

  // finally return the removed key
  return removedKey;
}
</code></pre>
<h2 id="使用现有数组创建堆">使用现有数组创建堆</h2>
<p>从现有数组创建堆看起来非常简单。只需创建一个空堆，然后遍历数组的所有项并执行 heappush():</p>
<pre><code class="language-javascript">function heapify(arr){
  const heap = []
  for(let item of arr){
     heappush(heap, item)
  }
  return heap;
}
</code></pre>
<p>但是我们可以在这里做得更好吗？是的。首先，我们可以完全避免为新堆使用额外的空间。为什么不重新排列数组本身的元素，使其满足堆属性？为此，我们可以遵循与堆弹出类似的逻辑。我们可以查看第一个节点并与它的子节点进行比较，看看它是否是最小的节点，如果不是与较小的子节点交换。下面我们来实现一下：</p>
<pre><code class="language-javascript">// follows pretty much the same logic as heappush, except minor modifications
function percolateDown(heap, index){
  let curr = index;
  // keep going down till heap property is established
  while(2*curr + 1 &lt; heap.length){
    const leftIndex = 2*curr+1; 
    const rightIndex = 2*curr+2;
    const minChildIndex = (rightIndex &lt; heap.length &amp;&amp; heap[rightIndex] &lt; heap[leftIndex] ) ? rightIndex :leftIndex;
    if(heap[minChildIndex] &lt; heap[curr]){
     // quick swap, if smaller of two children is smaller than the parent (min-heap)
      [heap[minChildIndex], heap[curr]] = [heap[curr], heap[minChildIndex]]
      curr = minChildIndex
    } else {
      break
    }
}
</code></pre>
<p>我们可以对数组中的所有元素使用 percolateDown() 函数，按照堆属性将所有元素按正确顺序排列：</p>
<pre><code class="language-javascript">function heapify(heap){
  for(let i in heap){
     percolateDown(heap, i)
   }
  return heap
}
</code></pre>
<p>这样就为我们节省了一个额外的数组。但是我们能做些什么来改善所花费的时间吗？是的。如果你仔细观察，我们实际上是在做一些重复的工作。假设堆中有 n 个节点，其中 x 是叶节点，那么这意味着我们只需要对 n-x 个节点执行 percolateDown()，因为到那时最后 x 个节点将在正确的位置。</p>
<blockquote>
<p>那么在堆的数组表示中，我们应该执行 percolateDown() 操作到哪个索引？<br>
直到最后一个节点的父节点所在的索引。因为一旦最后一个节点的父节点被过滤掉，它也会处理最后一个节点。所以：</p>
</blockquote>
<ul>
<li>如果数组长度为 n</li>
<li>最后一个节点的索引是：n-1</li>
<li>它的父节点的索引是：<code>Math.floor((n-1) - 1 / 2) = Math.floor(n/2 - 1)</code></li>
</ul>
<pre><code class="language-javascript">function heapify(heap){
  const last = Math.floor(heap.length/2 - 1);
  for(let i = 0; i &lt;= last; i++){
     percolateDown(heap, i)
   }
  return heap
}
</code></pre>
<h2 id="时间和空间复杂度">时间和空间复杂度</h2>
<p>查看 heappush() 和 heapop() 操作，很明显我们在尝试添加或删除键时正在遍历树的高度。由于堆是一棵平衡树，因此高度是 log(n)，其中 n 是节点总数。因此，对于堆的推送和弹出操作，时间复杂度为 O(log(n))。 heapify() 操作的时间复杂度可能看起来像 Onlog(n)，因为每次调用都需要 O(log(n))。这个观察结果对于推导 heapify() 的时间复杂度的上限是正确的，但是，渐近（平均）时间复杂度为 O(n)。更多细节在这里。就空间复杂度而言，它是恒定的，因为额外的空间仅被诸如 curr、leftIndex 等大小恒定的变量占用。</p>
<h2 id="最大堆">最大堆</h2>
<p>如果我们有 minHeap 的实现，我们也可以轻松地将它用作最大堆。我们只需要确保在向堆添加值时我们插入键的负数。它将确保堆充当所有键的负数的最小堆，这相当于所有实际键的最大堆。例如：</p>
<ul>
<li>假设我们有一个数组 <code>const x = [23, 454, 54, 29]</code>;</li>
<li>可以使用以下方法创建最小堆：</li>
</ul>
<pre><code class="language-javascript">const heap = [];
for(let el of x) heappush(heap, el);
  // min value
const min = heappop(heap)
</code></pre>
<p>最大堆可以使用</p>
<pre><code class="language-javascript">const heap = [];
for(let el of x) heappush(heap, -el);

// max value
const max = -heappop(heap)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的稀疏数组与密集数组的区别？]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-xi-shu-shu-zu-yu-mi-ji-shu-zu-de-qu-bie</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-xi-shu-shu-zu-yu-mi-ji-shu-zu-de-qu-bie">
        </link>
        <updated>2021-12-12T08:02:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>JavaScript 中的数组非常易于使用。但是，你应该注意一个细微差别：某些数组中可能存在漏洞。<br>
在这篇文章中，我将描述 JavaScript 中稀疏数组和密集数组之间的区别。此外，你将找到创建稀疏数组的常用方法。</p>
<h2 id="密集数组">密集数组</h2>
<p>JavaScript 中的数组是一个对象，表示元素的有序集合。数组中的元素有一个确切的顺序。你可以使用索引访问数组的第 n 项。</p>
<pre><code class="language-javascript">const names = ['Batman', 'Joker', 'Bane'];
console.log(names[0]); // logs 'Batman'
console.log(names[1]); // logs 'Joker'
console.log(names[2]); // logs 'Bane'
console.log(names.length); // logs 3
</code></pre>
<ul>
<li><code>names[0]</code> 访问索引 0（第一个元素）处的数组项。</li>
<li>数组还有一个属性长度，它表示数组中的项数。在前面的示例中，<code>names.length</code> 为 3，因为数组中的元素个数为 3。</li>
<li>上面创建的名称数组是一个密集数组：这意味着它包含每个索引处的元素，从 0 开始，直到 names.length - 1。<br>
我们定义这是一个函数 isDense(array) ，用于确定数组是否在每个索引处都有元素：</li>
</ul>
<pre><code class="language-javascript">function isDense(array) {
 for (let index = 0; index &lt; array.length; index++) {
   if (!(index in array)) {
     return false;
   }
 }
 return true;
}
const names = ['Batman', 'Joker', 'Bane'];
console.log(isDense(names)); // logs true
</code></pre>
<p>其中 <code>index in array</code> 确定数组是否在索引位置有一个元素。</p>
<p>这是一个有趣的问题：JavaScript 中的所有数组都是密集的吗？或者当 <code>isDense(array)</code> 返回 false 时可能有数组？</p>
<h2 id="稀疏数组">稀疏数组</h2>
<p>有些情况下 JavaScript 数组中可能存在漏洞。这样的数组被命名为稀疏数组。<br>
例如，如果你使用数组字面量但省略指示项就会创建了一个稀疏数组：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
console.log(names[0]); // logs 'Batman'
console.log(names[1]); // logs undefined
console.log(names[2]); // logs 'Bane'
console.log(isDense(names)); // logs false
</code></pre>
<p><code>['Batman', , 'Bane']</code> 数组文字创建一个稀疏数组，在 1 索引处有一个缺失。如果你访问这个位置的值——names[1]——它的计算结果是 <code>undefined</code>。</p>
<p>要明确检查特定索引处是否有空缺，你可以这样写<code>index in names</code>中：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
// No hole
console.log(0 in names); // logs true
// Hole
console.log(1 in names); // logs false
</code></pre>
<p>当然，如果你在稀疏数组上运行 isDense() 它将返回 false：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
console.log(isDense(names)); // logs false
</code></pre>
<p>现在你对稀疏数组有所了解。但是创建稀疏数组的常用方法是什么？</p>
<h2 id="创建稀疏数组的方法">创建稀疏数组的方法</h2>
<h3 id="数组字面量">数组字面量</h3>
<p>在使用数组字面量时省略一个值会创建一个稀疏数组（注意记录器数组中的空词）：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
console.log(names); // logs ['Batman', empty, 'Bane']
</code></pre>
<h3 id="array-构造函数">Array() 构造函数</h3>
<p>调用 <code>Array(length)</code> 或 <code>new Array(length)</code>（带有一个数字参数）会创建一个完全稀疏的数组：</p>
<pre><code class="language-javascript">const array = Array(3);
console.log(isDense(array)); // logs false
console.log(array);          // logs [empty, empty, empty]
</code></pre>
<h3 id="删除操作符">删除操作符</h3>
<p>在数组上使用 <code>delete array[index]</code>运算符时：</p>
<pre><code class="language-javascript">const names = ['Batman', 'Joker', 'Bane'];
delete names[1];
console.log(isDense(names)); // logs false
console.log(names);          // logs ['Batman', empty, 'Bane']
</code></pre>
<p>最初，names数组是密集的。<br>
但是执行 <code>delete names[1]</code>会删除索引 1 处的元素并使 <code>names</code> 数组变得稀疏。</p>
<h3 id="增加length属性">增加length属性</h3>
<p>如果你增加数组的长度属性，那么你也会在数组中创建空缺：</p>
<pre><code class="language-javascript">const names = ['Batman', 'Joker', 'Bane'];
names.length = 5;
console.log(isDense(names)); // logs false
console.log(names); // logs ['Batman', 'Joker', 'Bane', empty, empty]
</code></pre>
<p>最初<code>names</code>数组有3个元素，是一个密集数组。<br>
但是，将<code>names.length</code> 增加到 5 个元素会在 3 和 4 个索引处创建 2 个孔。</p>
<p>附带说明一下，减少 <code>length</code> 属性不会创建稀疏数组，而是从数组末尾删除元素。</p>
<h3 id="数组方法和稀疏数组">数组方法和稀疏数组</h3>
<p>稀疏数组的一个问题是许多数组内置方法只是跳过稀疏数组中的空缺。<br>
例如， <code>array.forEach(eachFunc)</code> 不会在孔上调用 <code>eachFunc</code> ：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
names.forEach(name =&gt; {
  console.log(name);
});
// logs 'Batman'
// logs 'Bane'
</code></pre>
<p>以同样的方式 <code>array.map(mapperFunc)</code>、<code>array.filter(predicateFunc)</code> 和更多函数跳过这些空缺位置。如果你不小心创建了一个稀疏数组，可能很难理解为什么数组方法不能按预期工作。</p>
<h2 id="总结">总结</h2>
<p>在 JavaScript 中，数组可以是密集的或稀疏的。</p>
<p>如果每个索引处都有从 0 开始直到 <code>array.length - 1</code> 的元素，则数组是密集的。否则，如果任何索引处至少缺少一项，则数组是稀疏的。</p>
<p>虽然你不会过多地处理稀疏数组，但你应该了解可以创建一个数组的情况：</p>
<ul>
<li>跳过数组 <code>[1, , 3]</code> 中的值时</li>
<li>使用 <code>Array(length)</code> 时</li>
<li>使用<code>delete array[index]</code></li>
<li>当增加 <code>array.length</code> 属性时</li>
</ul>
<p>稀疏数组的问题在于某些 JavaScript 函数（如 <code>array.forEach()</code>、<code>array.map()</code> 等）在迭代数组项时会跳过空缺值。</p>
<h2 id="拓展">拓展</h2>
<p>稀疏数组在访问元素的速度上比密集数组慢</p>
<pre><code class="language-javascript">const arr = new Array(200000)
arr[19999] = 88
console.time('using[]')
arr[19999]
console.timeEnd('using[]')
// using[]: 0.031982421875ms

const ddd = [...new Array(200000)]
ddd[19999] = 88
console.time('using[]')
ddd[19999]
console.timeEnd('using[]')
// using[]: 0.010009765625ms 
</code></pre>
<p>具体原因是，对于稀疏数组 V8 引擎访问对象是使用 散列表模式的，该种模式在访问时需要计算一遍哈希值，所以会比较慢，但散列表对于空间利用来说，效率更高。而密集数组，它是申请一段连续的内存空间，访问时可以直接通过「索引」来访问，所以速度比较快。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 Trie：什么是前缀树？]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-trieshi-me-shi-qian-zhui-shu</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-trieshi-me-shi-qian-zhui-shu">
        </link>
        <updated>2021-12-10T08:02:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>我们已经在三篇文章中介绍了树数据结构的基础知识。如果你还没有读过这些，我强烈建议先阅读前三篇文章：</p>
<ul>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">使用递归和迭代算法遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li/">使用父指针遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom/">将树遍历算法应用于 DOM</a></li>
</ul>
<h2 id="介绍">介绍</h2>
<p>Trie 是树数据结构的一种变体。它也被称为前缀树或搜索树的变体。就像 n 叉树数据结构一样，trie 可以有 n 个来自单亲的孩子。通常，trie 中的所有节点都会存储一些字符。假设我们只处理英语单词，下面是一个简单的 trie 可能看起来像：<br>
<img src="https://umeimmense.github.io/post-images/1639386955366.jpeg" alt="" loading="lazy"><br>
需要注意的事项：</p>
<ol>
<li>
<p>我们正在尝试使用树来尽可能高效地表示英语单词。</p>
</li>
<li>
<p>在上图中，从根节点到任何绿色节点的路径表示一个英文单词。例如：</p>
<ul>
<li>NULL-&gt;C-&gt;A-&gt;T: CAT</li>
<li>NULL-&gt;D-&gt;O: DO</li>
<li>NULL-&gt;D-&gt;O-&gt;G: DOG</li>
<li>NULL-&gt;D-&gt;A-&gt;R-&gt;K: DARK</li>
<li>NULL-&gt;A: A</li>
<li>NULL-&gt;A-&gt;N: AN</li>
</ul>
</li>
<li>
<p>每个节点最多可以有 26 个子节点（如果我们只处理英文字母）。我们有一个 NULL 节点作为根节点，因为一个单词可以以 26 个字母中的任何一个开头，因此我们需要一个虚拟节点，它可以将任何潜在的第一个字母作为子节点。</p>
</li>
<li>
<p>绿色节点，本质上代表“词尾”，同时从根遍历到该节点。</p>
</li>
</ol>
<h2 id="实现节点">实现节点</h2>
<p>现在，让我们尝试提出 Trie 节点的表示。回到树节点，这就是我们呈现它的方式：</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.left = null
  this.right = null
}
</code></pre>
<p>因此，我们可以对 Trie 遵循类似的想法，同时确保它满足我们在介绍部分讨论的要求。要了解 Trie 节点的要求，让我们放大任何节点：<br>
<img src="https://umeimmense.github.io/post-images/1639387276741.jpeg" alt="" loading="lazy"><br>
所以现在更有意义了。这是最终的代码：</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.isEndOfWord = false // false by default, a green node means this flag is true
  this.children = {} // children are stored as Map, where key is the letter and value is a TrieNode for that letter 
}
</code></pre>
<h2 id="实现-trie-数据结构">实现 Trie 数据结构</h2>
<p>我们可以使用一个简单的 ES6 类来表示：</p>
<pre><code class="language-javascript">class Trie{
  constructor(){
    this.root = new Node(null)
  }

  insert(word){
   // TODO
  }

  search(word){
   // TODO
  }

}
</code></pre>
<p>所以我们已经准备好了大概。作为初始化的一部分，每个trie 都会创建它自己的根节点（NULL）。那么我们可以实现这两个方法如下：</p>
<ul>
<li>insert(word)：我们可以将单词拆分为字母，并为每个字母创建一个 Node()。然后我们可以开始将这些 Trie 节点中的每一个链接到根节点，以插入单词。最后，我们将最后插入的节点的 isEndOfWord 属性标记为 true。</li>
<li>search(word)：我们可以将单词拆分为字母。然后我们可以从根开始一个一个地寻找这些字母中的每一个。如果我们能够按顺序找到所有字母，那么我们可以返回 true 否则 false。</li>
</ul>
<p>让我们直观地理解这两个操作以获得更好的上下文：</p>
<ul>
<li>首先insert(CAR)然后insert(CAN):<br>
<img src="https://umeimmense.github.io/post-images/1639387651437.jpeg" alt="" loading="lazy"></li>
<li>首先search(CAR)然后search(CAN):<br>
<img src="https://umeimmense.github.io/post-images/1639387657794.jpeg" alt="" loading="lazy"></li>
</ul>
<p>实现如下：</p>
<pre><code class="language-javascript">class Trie{
  constructor(){
    this.root = new Node(null)
  }

  insert(word){
    let current = this.root
    // iterate through all the characters of word
    for(let character of word){
         // if node doesn't have the current character as child, insert it
         if(current.children[character] === undefined){
             current.children[character] = new Node(character)
         }
        // move down, to insert next character
        current = current.children[character]  
    }
    // mark the last inserted character as end of the word
    current.isEndOfWord = true
  }

  search(word){
     let current = this.root
    // iterate through all the characters of word
    for(let character of word){
         if(current.children[character] === undefined){
             // could not find this character in sequence, return false
             return false
         }
        // move down, to match next character
        current = current.children[character]  
    }
     // found all characters, return true if last character is end of a word
    return current.isEndOfWord
  }
}
</code></pre>
<h2 id="使用-trie">使用 Trie</h2>
<pre><code class="language-javascript">const trie = new Trie();

// insert few words
trie.insert(&quot;CAT&quot;);
trie.insert(&quot;DOG&quot;);

// search something
trie.search(&quot;MAT&quot;) // false
trie.search(&quot;DOG&quot;) // true
</code></pre>
<h3 id="空间复杂度">空间复杂度</h3>
<p>在最坏的情况下，所有插入单词的每个字符都可以占用 Trie 中的单个节点。所以这意味着最坏的空间复杂度可以是 (W*n)，其中 W 是每个单词的平均字符数，n 是 Trie 中的单词总数。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>插入：插入一个有n个字符的单词，只需要遍历n个字符，所以时间复杂度为O(n)</li>
<li>搜索：与插入类似，我们只需要遍历单词的所有字符即可进行搜索。所以时间复杂度是 O(n)，其中 n 是单词中的字符数。</li>
</ul>
<p>现在，想一想，你还能如何在庞大的单词列表中搜索某个单词？<br>
-可能使用数组？时间复杂度为 O(m)，其中 m 是单词总数，这很糟糕。</p>
<ul>
<li>如何使用Map（或 JavaScript 中的对象）？这会将时间复杂度降低到 O(1)，但是找到具有特定前缀的单词列表有多快？它将是 O(m)。</li>
</ul>
<p>Trie 不仅将时间复杂度降低到 O(n)（n = 单词中的字符数），而且您还可以有效地搜索具有前缀的单词列表，这对于任何以上两种方法。</p>
<h2 id="应用">应用</h2>
<ul>
<li>自动完成和预先输入：如果您在文本框中键入内容，并且看到具有相同前缀的潜在搜索列表，即自动完成小部件，那么这可能是由后台的 Trie 处理的。同样，<a href="https://en.wikipedia.org/wiki/Typeahead">Typeahead</a> 也可以使用 Trie 来实现。</li>
<li>拼写检查器：我们可以使用 trie 创建拼写检查器，即给定一个单词列表，我们可以检查给定单词的拼写是否正确。</li>
<li>IP 路由（最长前缀匹配）：Internet 由多个路由器节点组成，它们决定应该发送的目标数据包。 Internet 上的每个路由器都需要将数据包发送到由给定 IP 目的地决定的适当目标节点。但是每个路由器如何使用给定的 IP 地址决定下一个目标路由器呢？这个问题可以使用IP路由来解决。<a href="https://www.lewuathe.com/longest-prefix-match-with-trie-tree.html">这是一篇深入探讨这个主题的好文章</a>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 将树遍历算法应用于 DOM]]></title>
        <id>https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom</id>
        <link href="https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom">
        </link>
        <updated>2021-12-09T06:10:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>到目前为止，我们已经了解了一些二叉树遍历的方法：</p>
<ul>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">使用递归和迭代算法遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li/">使用父指针遍历二叉树</a><br>
在本文中，我们将把这些知识用于 n 叉树，即 DOM。我们将看到如何使用各种 CSS 选择器定位 DOM 元素，而无需使用内置 API，如 getElementById、getElementsByClassname 或 querySelector/querySelectorAll。因此，本文将阐明这些 API 可能如何在幕后工作。</li>
</ul>
<h2 id="dom-遍历">DOM 遍历</h2>
<p>借用 <a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">使用递归和迭代算法遍历二叉树</a>的思路，我们来得出DOM的前序遍历算法：</p>
<pre><code class="language-javascript">function walkPreOrder(node){
  if(!node) return

  // do something here
  console.log(node)

  for(let child of node.children){
     walkPreOrder(child)
  }
}
</code></pre>
<p>我们可以修改这个算法使之来返回一个迭代器：</p>
<pre><code class="language-javascript">function* walkPreOrder(node){
  if(!node) return

  // do something here
  yield node
  for(let child of node.children){
    yield* walkPreOrder(child)
  }
}

// USAGE
for(let node of walkPreOrder(root)){
  console.log(node)
}
</code></pre>
<p>我们可以使用任何广度优先或深度优先算法（在之前的文章中讨论过）来遍历 DOM。<br>
我们还假设正在处理具有以下 HTML 的文档：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;DOM selection algorithm&lt;/title&gt;
  &lt;/head&gt;
&lt;body&gt;

  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;body&quot;&gt;
      &lt;div class=&quot;row&quot;&gt;
        &lt;img id=&quot;profile&quot; src=&quot;xyz.jpg&quot; alt=&quot;&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;row&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;row&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="通过-id-定位节点">通过 ID 定位节点</h2>
<pre><code class="language-javascript">function locateById(nodeId){
  // iterate through all nodes in depth first (preOrder) fashion
  // return the node as soon as it's found
  for(let node of walkPreOrder(document.body)){
     if(node.id === nodeId){
        return node
     }
  }
   return null
}
</code></pre>
<p>我们可以使用 locateById() 函数如下：</p>
<pre><code class="language-javascript">const img = locateById('profile')
// returns the image node
</code></pre>
<h2 id="通过classname-定位节点">通过ClassName 定位节点</h2>
<p>浏览器提供 document.getElementsByClassName() API 来实现此结果。我们如何实现类似的东西：</p>
<pre><code class="language-javascript">function locateAllByClassName(className){
   const result = []
   for(let node of walkPreOrder(document.body)){
      if(node.classList.contains(className)){
        result.push(node)
      }
   }
   return result
}

// USAGE
const elements = locateAllByClassName('row')
</code></pre>
<h2 id="浏览器如何优化选择查询">浏览器如何优化选择查询</h2>
<p>选择 DOM 节点是 Web 应用程序相当常见的操作。为同一个选择器多次遍历树似乎不是最佳选择。浏览器通过使用记忆优化选择。<br>
查看 <a href="https://searchfox.org/mozilla-central/source/parser/html/javasrc/TreeBuilder.java#1467">mozilla 解析器的源代码</a>，即函数 startTag 的摘录：</p>
<pre><code class="language-javascript"> // ID uniqueness
 @IdType String id = attributes.getId();
 if (id != null) {
      LocatorImpl oldLoc = idLocations.get(id);
      if (oldLoc != null) {
            err(&quot;Duplicate ID \u201C&quot; + id + &quot;\u201D.&quot;);
            errorHandler.warning(new SAXParseException(
                  &quot;The first occurrence of ID \u201C&quot; + id
                  + &quot;\u201D was here.&quot;, oldLoc));
       } else {
            idLocations.put(id, new LocatorImpl(tokenizer));
       }
 }
</code></pre>
<p>我们可以看到这些节点 ID 保存在一个简单的哈希映射中。我们可以使用类似的方法来确保对同一 ID 的重复查询不需要完全遍历，相反，我们可以从 hashMap 中查找并返回它。<br>
以下是我们的解决方案：</p>
<pre><code class="language-javascript">function getSelectors(){
  const idLocations = {}
  const classLocations = {}

  // updated selector functions  
  function locateById(nodeId){
    if(idLocations.hasOwnProperty(nodeId)) 
       return idLocations[nodeId]

    for(let node of walkPreOrder(document.body)){
       if(node.id === nodeId){
          idLocations[nodeId]= node //memoize
          return node
       }
     }
    idLocations[nodeId]= null // memoize
    return null
  }

  function locateAllByClassName(className){
    if(classLocations.hasOwnProperty(className)) 
         return classLocations[className]

    const result = []
    for(let node of walkPreOrder(document.body)){
       if(node.classList.contains(className)){
          result.push(node)
        }
     }
     classLocations[nodeId]= result
     return result
  }

  return {
       locateById,
       locateAllByClassName
    }

} 

  // USAGE
  const {locateById, locateAllByClassName} = getSelectors();
  const result = locateAllByClassName('row') // returns array of elements
  const img = locateById('profile') // returns an element, if found
</code></pre>
<h2 id="处理更复杂的选择器">处理更复杂的选择器</h2>
<p>让我们尝试实现类似 element.querySelector 的方法。以下是 MDN 的描述：</p>
<blockquote>
<p>The querySelector() method of the Element interface returns the first element that is a descendant of the element on which it is invoked that matches the specified group of selectors.</p>
</blockquote>
<h3 id="样例">样例</h3>
<pre><code class="language-javascript">const firstRow = document.querySelector('.container .row:first-child')
</code></pre>
<p>在这种情况下，我们可以将任何 CSS 选择器传递给函数，它应该能够遍历 DOM 为我们找到该元素。让我们看看它是如何实现的：</p>
<pre><code class="language-javascript">// given a selector and root node, find that selector within the root node
function select(selector, root){
  for(let node of walkPreOrder(root)){
      if(node.matches(selector)){
        return node
     }
   }
  return null;
}


function myQuerySelector(path, node){
  // if path is empty, nothing to find
  if(path.length === 0) return null;

  // if node is not provided, let's assume user wants to search within document.body
  let root = node || document.body;  
  const selector = path[0];

  // if there's only one selector in the path, just traverse using select function above
  if(path.length === 1) return select(selector, root);

   // else, either the current node matches the first selector in path or not
   // if first selector matches with current node, look through it's children for subsequent selectors only
   // else, look through it's children for the whole path
  const newPath = root.matches(selector) ? path.slice(1): path;
  for(let child of root.children){
    const ans = myQuerySelector(newPath, child);
    if(ans) return ans
  }

  // nothing found
  return null;
}


// USAGE:
const firstRow = myQuerySelector([&quot;.container&quot;, &quot;.row&quot;])
</code></pre>
<p>myQuerySelectorAll 的实现（类似于 element.querySelectorAll）也遵循相同的方法，稍作修改：</p>
<pre><code class="language-javascript">function selectAll(selector, root){
  let result = []
  for(let node of walkPreOrder(root)){
      if(node.matches(selector)){
        result.push(node)
     }
   }
  return result;
}

function myQuerySelectorAll(path, node){
  let result = [];
  if(path.length === 0) return result;

  let root = node || document.body;  
  const selector = path[0];

  if(path.length === 1) return selectAll(selector, root);

  const newPath = root.matches(selector) ? path.slice(1): path;
  for(let child of root.children){
    result = [...result, ...myQuerySelectorAll(newPath, child)]

  }

  return result;
}
</code></pre>
<h2 id="进阶">进阶</h2>
<p>我们可以使用本文开头描述的递归前序遍历方法来克隆任何树。让我们看看我们如何使用它来克隆任何 DOM 树，类似于 element.cloneNode(true) 所做的：</p>
<ul>
<li>通过创建具有相同 tagName 的新节点然后复制属性来创建源节点的克隆。</li>
<li>对源节点的所有子节点递归调用 cloneTree 方法，并将返回的节点作为子节点附加到克隆节点。</li>
</ul>
<pre><code class="language-javascript">function cloneTree(node){
  if(!node) return

  const clonedNode = document.createElement(node.tagName.toLowerCase())
  const attributes = node.getAttributeNames()

  attributes.forEach(attribute =&gt; {
     clonedNode.setAttribute(attribute, node.getAttribute(attribute))
  })

  for(const child of node.children){
      clonedNode.append(cloneTree(child))
  }

  return clonedNode
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 Tree 使用父指针高效遍历]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li">
        </link>
        <updated>2021-12-08T03:18:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本系列的<a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">第一部分</a>中，我们研究了遍历二叉树的递归和迭代方法。<br>
在实际应用中，树节点有一个父节点是很常见的：一个指向父节点的指针，因此也称为父指针。让我们以浏览器中的 DOM 为例。假设我们使用以下命令选择任何节点：</p>
<pre><code class="language-javascript">const element = document.querySelector(&quot;#id&quot;)
</code></pre>
<p>在本文中，我们将研究如何使用这些父指针来提高遍历效率。我稍后会解释我所说的“更高效”是什么意思。在下一篇文章中，我们还将了解如何使用此处学到的经验教训从头开始创建 myQuery 库。</p>
<h2 id="更新节点定义">更新节点定义</h2>
<p>首先，我们需要更新Node 函数</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.left = null
  this.right = null
  this.parent = null // added parent field
}
</code></pre>
<p>现在让我们看看如何使用这个新的 Node 定义来创建一个类似的树，就像我们在上一篇文章中所做的那样。</p>
<pre><code class="language-javascript">const root = new Node(2)
const left = new Node(1)
root.left = left
left.parent = root

const right = new Node(3)
root.right = right
right.parent = root
</code></pre>
<p>我们只需要确保父指针指向父节点。这是我们使用上述代码获得的最终树的视觉参考：<br>
<img src="https://umeimmense.github.io/post-images/1639116374962.jpeg" alt="" loading="lazy"></p>
<p>##寻找后继节点</p>
<h3 id="前序后继">前序后继</h3>
<p>假设每个节点都有一个parent指针，如何找出二叉树中任何节点的 前序 后继？<br>
让我们试着分析一下这个问题：</p>
<ol>
<li>首先，我们在这里处理前序，这意味着我们正在寻找以下顺序：</li>
</ol>
<pre><code class="language-javascript">root -&gt; left -&gt; right
</code></pre>
<ol start="2">
<li>这意味着如果我们已经在当前节点，我们想寻找左子节点作为后继节点。</li>
<li>如果根本没有左子节点怎么办？那么在这种情况下，我们会寻找合适的节点，如果在有左子节点，那就是后继节点。</li>
<li>如果没有左子节点或右子节点，那么我们需要回溯（继续向上走向父节点）。我们一直回溯，直到通过它的右子节点到达父级（因为这意味着  前序 对于父级下的整个子树是完整的，根据 #1 的定义）。</li>
</ol>
<p>最终算法实现就是这样：</p>
<pre><code class="language-javascript">function preOrderSuccessor(node){
   if(!node) return

   if(node.left) return node.left
   if(node.right) return node.right

   let parent = node.parent

   while(parent &amp;&amp; parent.right === node) {
     node = node.parent
     parent = parent.parent
   }

   if(!parent) return null // we backtracked till root, so no successor

   return parent.right
}
</code></pre>
<p>可以根据下图更好的理解<br>
<img src="https://umeimmense.github.io/post-images/1639365381317.jpeg" alt="" loading="lazy"></p>
<h3 id="中序后继">中序后继</h3>
<ol>
<li>首先，我们在这里处理中序遍历，这意味着我们正在寻找以下顺序：</li>
</ol>
<pre><code class="language-javascript">root -&gt; left -&gt; right
</code></pre>
<ol start="2">
<li>如果我们在当前节点，并且它右边有右子节点，那么我们可以通过在右子树上找到最左边的节点来获得后继节点。</li>
<li>如果没有右子节点，那么我们需要回溯（向上移动）。我们一直向上移动，直到通过它的右子节点到达父节点，因为这意味着已经遍历了整个子树（根据 #1 中的定义）。</li>
<li>一旦我们找到最近的父节点，它是通过它的左子节点找到的，它就会作为后继节点返回。为什么？因为这意味着它是一个已经探索了左树的节点，所以根据 #1 中的定义，节点本身现在是后继节点。<br>
实现如下：</li>
</ol>
<pre><code class="language-javascript">function inOrderSuccessor(node){
   if(!node) return

   if(node.right){
     let current = node.right
     while(current &amp;&amp; current.left) current = current.left
     return current
   }

   let parent = node.parent

   while(parent &amp;&amp; parent.right === node) {
     root = node.parent
     parent = parent.parent
   }

   if(!parent) return null

   return parent
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://umeimmense.github.io/post-images/1639366519214.jpeg" alt="" loading="lazy"></figure>
<h3 id="后序后继">后序后继</h3>
<ol>
<li>首先，我们在这里处理后序遍历，这意味着我们正在寻找以下顺序：</li>
</ol>
<pre><code class="language-javascript">left -&gt; right -&gt; root
</code></pre>
<ol start="2">
<li>所以，如果我们在任何节点上，就意味着它的左右子树已经被访问过了。这意味着我们需要查看父级的继任者。</li>
<li>如果我们从它的右子节点到达父母，这意味着父母本身就是继任者，根据#1 中的定义</li>
<li>如果我们从它的左子节点到达父母，这意味着接下来要探索父母的右子节点（根据#1 中的定义）。所以现在我们需要简单地返回父节点右子节点中最左边的节点作为后继节点。<br>
实现如下：</li>
</ol>
<pre><code class="language-javascript">function postOrderSuccessor(node){
   if(!node) return

   let parent = node.parent
   if(!parent) return null

   if(parent.right === node). return parent

   let current = parent.right
   while(current &amp;&amp; (current.left || current.right)){
     current = (current.left || current.right)
   }

   return current
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://umeimmense.github.io/post-images/1639366689014.jpeg" alt="" loading="lazy"></figure>
<h2 id="使用后继算法更好地遍历">使用后继算法更好地遍历</h2>
<p>为什么我们需要使用父指针来提出遍历算法呢？这是一个值得思考的问题，因为我们已经提出了遍历树的递归和迭代方法，而且不需要父指针。</p>
<p>我们这样做的原因是因为我们之前的方法增加了空间复杂性。如果你还记得上一篇文章中我们需要使用一个或两个堆栈（取决于遍历方法）来使任何遍历算法工作。即使在递归方法中，虽然我们不直接使用堆栈，但递归本身基于调用堆栈，因此那里也使用了隐藏的内存中堆栈。问题是这个堆栈的大小会随着我们树的深度而增加，因此这不是最好的解决方案，因为我们有办法在花费更少空间的情况下完成相同的任务。通过使用父指针，我们可以完全摆脱这些堆栈，为我们节省大量空间，即从 O(logN) 的空间复杂度（其中 N 表示平衡树的大小）到 O(1)。让我们看看如何实现。</p>
<h3 id="前序遍历">前序遍历</h3>
<p>对于 前序遍历，我们从树的根部开始。之后，我们可以使用上面的算法继续获取前序后继以遍历整棵树：</p>
<pre><code class="language-javascript">function preOrder(root){
  // first node
  console.log(root.value);

  let current = root
  while(true){
    const next = preOrderSuccessor(current)
    if(!next) break

    // do something
    console.log(next.value)

    current = next
  }
}

</code></pre>
<h3 id="中序遍历">中序遍历</h3>
<p>对于 中序遍历，起始节点将是树的最左侧节点。此后，我们可以使用上述算法继续获取后继以遍历整棵树：</p>
<pre><code class="language-javascript">function inOrder(root){
  // start at the left most node
  while(root &amp;&amp; root.left){
    root = root.left
  }

  // first node
  console.log(root.value);

  let current = node
  while(true){
    const next = inOrderSuccessor(current)
    if(!next) break

    // do something
    console.log(current.value)

    current = next
  }
}

</code></pre>
<h3 id="后序遍历">后序遍历</h3>
<p>非常类似于上面的中序遍历的方法：</p>
<pre><code class="language-javascript">function postOrder(root){
  // start at the left most node
  while(root &amp;&amp; root.left){
    root = root.left
  }

  // first node
  console.log(root.value);

  let current = node
  while(true){
    const next = postOrderSuccessor(current)
    if(!next) break

    // do something
    console.log(current.value)

    current = next
  }
}
</code></pre>
<h2 id="进阶">进阶</h2>
<p>如果每个节点都有一个父指针，你能想出算法来寻找前任（inOrder、preOrder 和 postOrder）吗？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 Tree]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-tree</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-tree">
        </link>
        <updated>2021-12-07T08:17:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>Tree是一种有趣的数据结构。它在各个领域都有广泛的应用。例如：</p>
<ul>
<li>DOM 是一种Tree状数据结构</li>
<li>我们操作系统中的目录和文件可以表示为Tree</li>
<li>家庭层次结构可以表示为Tree。<br>
Tree的许多变体（如堆、BST 等）可用于解决与调度、图像处理、数据库等相关的问题。许多复杂的问题乍一看似乎与Tree无关，但可以被表示为一个Tree的问题。我们也会（在本系列的后面部分）解决这些问题，从而了解Tree如何使看似复杂的问题更容易理解和解决。</li>
</ul>
<h2 id="简介">简介</h2>
<p>二叉树实现节点非常简单</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.left = null
  this.right = null
}
// usage
const root = new Node(2)
root.left = new Node(1)
root.right = new Node(3)
</code></pre>
<p>所以这几行代码将为我们创建一个二叉树，如下所示：</p>
<pre><code>           2  
        /      \
       /         \
     1            3
   /   \        /    \
null  null   null   null
</code></pre>
<h2 id="遍历">遍历</h2>
<p>让我们从尝试遍历这些连接的树节点（或一棵树）开始。正如我们可以遍历数组一样，如果我们也可以“遍历”树节点。然而，树不是像数组那样的线性数据结构，所以遍历这些的方法不止一种。我们可以将遍历方法大致分为以下几类：</p>
<ul>
<li>广度优先遍历</li>
<li>深度优先遍历</li>
</ul>
<h3 id="广度优先遍历bfs">广度优先遍历（BFS）</h3>
<p>在这种方法中，我们逐层遍历树。我们将从根开始，然后覆盖它的所有子级，然后覆盖所有 2 级子级，依此类推。例如对于上面的树，遍历会导致这样的结果：</p>
<pre><code>           2  
        /      \
       /         \
     1            3
   /   \        /    \
null  null   null   null
2，1，3
</code></pre>
<p>下面是一个稍微复杂的树的插图，使这更容易理解：<br>
<img src="https://umeimmense.github.io/post-images/1638865775709.png" alt="" loading="lazy"></p>
<p>为了实现这种形式的遍历，我们可以使用队列（先进先出）数据结构。以下是整个算法的过程：</p>
<ol>
<li>初始化一个包含 root 的队列</li>
<li>从队列中删除第一项</li>
<li>将弹出项的左右节点推入队列</li>
<li>重复步骤 2 和 3，直到队列为空<br>
下面是这个算法在实现后的样子：</li>
</ol>
<pre><code class="language-javascript">function walkBFS(root){
  if(root === null) return

  const queue = [root]
  while(queue.length){
      const item = queue.shift()
      // do something
      console.log(item)

      if(item.left) queue.push(item.left)
      if(item.right) queue.push(item.right)
   }
}
</code></pre>
<p>我们可以稍微修改上面的算法实现为：</p>
<pre><code class="language-javascript">function walkBFS(root){
  if(root === null) return

  const queue = [root], ans = []

  while(queue.length){
      const len = queue.length, level = []
      for(let i = 0; i &lt; len; i++){
          const item = queue.shift()
          level.push(item)
          if(item.left) queue.push(item.left)
          if(item.right) queue.push(item.right)
       }
       ans.push(level)
   }
  return ans
}
</code></pre>
<h3 id="深度优先遍历dfs">深度优先遍历（DFS）</h3>
<p>在 DFS 中，我们取一个节点并继续探索它的子节点，直到深度耗尽为止。它可以通过以下方式之一完成：</p>
<pre><code> root node -&gt; left node -&gt; right node // pre-order traversal
 left node -&gt; root node -&gt; right node // in-order traversal
 left node -&gt; right node -&gt; root node // post-order traversal
</code></pre>
<p>所有这些遍历技术都可以递归和迭代实现。让我们进入实现细节：</p>
<h4 id="前序遍历pre-order-traversal">前序遍历(Pre-Order traversal)</h4>
<h5 id="分析">分析</h5>
<pre><code> root node -&gt; left node -&gt; right node
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://umeimmense.github.io/post-images/1638866252844.png" alt="" loading="lazy"></figure>
<h5 id="技巧">技巧:</h5>
<p>我们可以使用这个简单的技巧来手动找出任何树的前序遍历：从根节点开始遍历整棵树，保持自己在左边。</p>
<h5 id="实现">实现</h5>
<ul>
<li>递归</li>
</ul>
<pre><code class="language-javascript">function walkPreOrder(root){
  if(root === null) return

  // do something here
  console.log(root.val)

  // recurse through child nodes
  if(root.left) walkPreOrder(root.left)
  if(root.right) walkPreOrder(root.right)
}

</code></pre>
<ul>
<li>迭代<br>
前序遍历的迭代方法与 BFS 非常相似，不同之处在于我们使用堆栈而不是队列，并且我们首先将右节点推入堆栈：</li>
</ul>
<pre><code class="language-javascript">function walkPreOrder(root){
  if(root === null) return

  const stack = [root]
  while(stack.length){
      const item = stack.pop()

      // do something
      console.log(item)

      // Left child is pushed after right one, since we want to print left child first hence it must be above right child in the stack
      if(item.right) stack.push(item.right)
      if(item.left) stack.push(item.left)
   }
}
</code></pre>
<h4 id="中序遍历in-order-traversal">中序遍历(In-Order traversal)</h4>
<h5 id="分析-2">分析</h5>
<p>下面是一棵树的中序遍历的过程：</p>
<pre><code>left node -&gt; root node -&gt; right node
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://umeimmense.github.io/post-images/1638870255515.png" alt="" loading="lazy"></figure>
<h5 id="技巧-2">技巧</h5>
<p>我们可以使用这个简单的技巧来手动找出任何树的中序遍历：在树的底部水平放置一个平面镜，并获取所有节点的投影<br>
<img src="https://umeimmense.github.io/post-images/1638870350959.png" alt="" loading="lazy"></p>
<h5 id="实现-2">实现</h5>
<ul>
<li>递归<pre><code class="language-javascript">function walkInOrder(root){
if(root === null) return

if(root.left) walkInOrder(root.left)

</code></pre>
</li>
</ul>
<p>// do something here<br>
console.log(root.val)</p>
<p>if(root.right) walkInOrder(root.right)<br>
}</p>
<pre><code>- 迭代
这个算法乍一看可能有点神秘。但它相当直观。让我们这样看：在中序遍历中，最左边的孩子节点首先被打印，然后是根，然后是孩子节点。所以首先想到的是想出这样的东西：
```javascript
const curr = root

while(curr){
while(curr.left){
  curr = curr.left // get to leftmost child
}

console.log(curr) // print it

curr = curr.right // now move to right child
}
</code></pre>
<p>在上述方法中，我们无法回溯，即返回导致最左侧节点的父节点。所以我们需要一个堆栈来记录这些。因此，我们修订后的方法可能如下所示：</p>
<pre><code class="language-javascript">const stack = []
const curr = root

while(stack.length || curr){
while(curr){
  stack.push(curr) // keep recording the trail, to backtrack
  curr = curr.left // get to leftmost child
}
const leftMost = stack.pop()
console.log(leftMost) // print it

curr = leftMost.right // now move to right child
}
</code></pre>
<p>现在我们可以使用上面的方法来制定最终的迭代算法：</p>
<pre><code class="language-javascript">function walkInOrder(root){
  if(root === null) return

  const stack = []
  let current = root

  while(stack.length || current){
      while(current){
         stack.push(current)
         current = current.left
      }
      const last = stack.pop()

      // do something
      console.log(last)

      current = last.right
   }
}
</code></pre>
<h4 id="后序遍历post-order-traversal">后序遍历（Post-Order traversal）</h4>
<h5 id="分析-3">分析</h5>
<p>下面是一棵树的中序遍历的过程：</p>
<pre><code> left node -&gt; right node -&gt; root node
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://umeimmense.github.io/post-images/1638870734512.png" alt="" loading="lazy"></figure>
<h5 id="技巧-3">技巧</h5>
<p>对于任何树的快速手动后序遍历：一个接一个地提取所有最左边的孩子节点。<br>
<img src="https://umeimmense.github.io/post-images/1638870834926.png" alt="" loading="lazy"></p>
<h5 id="实现-3">实现</h5>
<p>让我们深入研究这种遍历的实际实现。</p>
<ul>
<li>递归<pre><code class="language-javascript">  function walkPostOrder(root){
  if(root === null) return

  if(root.left) walkPostOrder(root.left)
  if(root.right) walkPostOrder(root.right)

  // do something here
  console.log(root.val)

  }
</code></pre>
</li>
<li>迭代<br>
我们已经有了用于前序遍历的迭代算法。我们可以用那个吗？因为后序遍历似乎只是前序遍历的反向。让我们来看看：</li>
</ul>
<pre><code>// PreOrder:
root -&gt; left -&gt; right

// Reverse of PreOrder:
right -&gt; left -&gt; root

// But PostOrder is:
left -&gt; right -&gt; root
</code></pre>
<p>从上面分析可见有细微的差别。我们可以通过稍微修改我们的 前序遍历算法然后反转它应该给出 后序遍历结果来适应这一点。总体算法将是：</p>
<pre><code>// record result using 
root -&gt; right -&gt; left

// reverse result
left -&gt; right -&gt; root
</code></pre>
<ul>
<li>使用与上述迭代前序遍历算法类似的方法，使用临时堆栈。
<ul>
<li>唯一的区别是 root -&gt; right -&gt; left 而不是 root -&gt; left -&gt; right</li>
</ul>
</li>
<li>结果将遍历序列记录在一个array</li>
<li>结果的反转就是后序遍历</li>
</ul>
<pre><code class="language-javascript">function walkPostOrder(root){
  if(root === null) return []

  const tempStack = [root], result = []

  while(tempStack.length){
      const last = tempStack.pop()

      result.push(last)

      if(last.left) tempStack.push(last.left)
      if(last.right) tempStack.push(last.right)
    }

    return result.reverse()
}

</code></pre>
]]></content>
    </entry>
</feed>