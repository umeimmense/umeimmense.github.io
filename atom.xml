<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2021-12-17T06:34:20.666Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的稀疏数组与密集数组的区别？]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-xi-shu-shu-zu-yu-mi-ji-shu-zu-de-qu-bie</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-xi-shu-shu-zu-yu-mi-ji-shu-zu-de-qu-bie">
        </link>
        <updated>2021-12-12T08:02:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>JavaScript 中的数组非常易于使用。但是，你应该注意一个细微差别：某些数组中可能存在漏洞。<br>
在这篇文章中，我将描述 JavaScript 中稀疏数组和密集数组之间的区别。此外，你将找到创建稀疏数组的常用方法。</p>
<h2 id="密集数组">密集数组</h2>
<p>JavaScript 中的数组是一个对象，表示元素的有序集合。数组中的元素有一个确切的顺序。你可以使用索引访问数组的第 n 项。</p>
<pre><code class="language-javascript">const names = ['Batman', 'Joker', 'Bane'];
console.log(names[0]); // logs 'Batman'
console.log(names[1]); // logs 'Joker'
console.log(names[2]); // logs 'Bane'
console.log(names.length); // logs 3
</code></pre>
<ul>
<li><code>names[0]</code> 访问索引 0（第一个元素）处的数组项。</li>
<li>数组还有一个属性长度，它表示数组中的项数。在前面的示例中，<code>names.length</code> 为 3，因为数组中的元素个数为 3。</li>
<li>上面创建的名称数组是一个密集数组：这意味着它包含每个索引处的元素，从 0 开始，直到 names.length - 1。<br>
我们定义这是一个函数 isDense(array) ，用于确定数组是否在每个索引处都有元素：</li>
</ul>
<pre><code class="language-javascript">function isDense(array) {
 for (let index = 0; index &lt; array.length; index++) {
   if (!(index in array)) {
     return false;
   }
 }
 return true;
}
const names = ['Batman', 'Joker', 'Bane'];
console.log(isDense(names)); // logs true
</code></pre>
<p>其中 <code>index in array</code> 确定数组是否在索引位置有一个元素。</p>
<p>这是一个有趣的问题：JavaScript 中的所有数组都是密集的吗？或者当 <code>isDense(array)</code> 返回 false 时可能有数组？</p>
<h2 id="稀疏数组">稀疏数组</h2>
<p>有些情况下 JavaScript 数组中可能存在漏洞。这样的数组被命名为稀疏数组。<br>
例如，如果你使用数组字面量但省略指示项就会创建了一个稀疏数组：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
console.log(names[0]); // logs 'Batman'
console.log(names[1]); // logs undefined
console.log(names[2]); // logs 'Bane'
console.log(isDense(names)); // logs false
</code></pre>
<p><code>['Batman', , 'Bane']</code> 数组文字创建一个稀疏数组，在 1 索引处有一个缺失。如果你访问这个位置的值——names[1]——它的计算结果是 <code>undefined</code>。</p>
<p>要明确检查特定索引处是否有空缺，你可以这样写<code>index in names</code>中：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
// No hole
console.log(0 in names); // logs true
// Hole
console.log(1 in names); // logs false
</code></pre>
<p>当然，如果你在稀疏数组上运行 isDense() 它将返回 false：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
console.log(isDense(names)); // logs false
</code></pre>
<p>现在你对稀疏数组有所了解。但是创建稀疏数组的常用方法是什么？</p>
<h2 id="创建稀疏数组的方法">创建稀疏数组的方法</h2>
<h3 id="数组字面量">数组字面量</h3>
<p>在使用数组字面量时省略一个值会创建一个稀疏数组（注意记录器数组中的空词）：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
console.log(names); // logs ['Batman', empty, 'Bane']
</code></pre>
<h3 id="array-构造函数">Array() 构造函数</h3>
<p>调用 <code>Array(length)</code> 或 <code>new Array(length)</code>（带有一个数字参数）会创建一个完全稀疏的数组：</p>
<pre><code class="language-javascript">const array = Array(3);
console.log(isDense(array)); // logs false
console.log(array);          // logs [empty, empty, empty]
</code></pre>
<h3 id="删除操作符">删除操作符</h3>
<p>在数组上使用 <code>delete array[index]</code>运算符时：</p>
<pre><code class="language-javascript">const names = ['Batman', 'Joker', 'Bane'];
delete names[1];
console.log(isDense(names)); // logs false
console.log(names);          // logs ['Batman', empty, 'Bane']
</code></pre>
<p>最初，names数组是密集的。<br>
但是执行 <code>delete names[1]</code>会删除索引 1 处的元素并使 <code>names</code> 数组变得稀疏。</p>
<h3 id="增加length属性">增加length属性</h3>
<p>如果你增加数组的长度属性，那么你也会在数组中创建空缺：</p>
<pre><code class="language-javascript">const names = ['Batman', 'Joker', 'Bane'];
names.length = 5;
console.log(isDense(names)); // logs false
console.log(names); // logs ['Batman', 'Joker', 'Bane', empty, empty]
</code></pre>
<p>最初<code>names</code>数组有3个元素，是一个密集数组。<br>
但是，将<code>names.length</code> 增加到 5 个元素会在 3 和 4 个索引处创建 2 个孔。</p>
<p>附带说明一下，减少 <code>length</code> 属性不会创建稀疏数组，而是从数组末尾删除元素。</p>
<h3 id="数组方法和稀疏数组">数组方法和稀疏数组</h3>
<p>稀疏数组的一个问题是许多数组内置方法只是跳过稀疏数组中的空缺。<br>
例如， <code>array.forEach(eachFunc)</code> 不会在孔上调用 <code>eachFunc</code> ：</p>
<pre><code class="language-javascript">const names = ['Batman', , 'Bane'];
names.forEach(name =&gt; {
  console.log(name);
});
// logs 'Batman'
// logs 'Bane'
</code></pre>
<p>以同样的方式 <code>array.map(mapperFunc)</code>、<code>array.filter(predicateFunc)</code> 和更多函数跳过这些空缺位置。如果你不小心创建了一个稀疏数组，可能很难理解为什么数组方法不能按预期工作。</p>
<h2 id="总结">总结</h2>
<p>在 JavaScript 中，数组可以是密集的或稀疏的。</p>
<p>如果每个索引处都有从 0 开始直到 <code>array.length - 1</code> 的元素，则数组是密集的。否则，如果任何索引处至少缺少一项，则数组是稀疏的。</p>
<p>虽然你不会过多地处理稀疏数组，但你应该了解可以创建一个数组的情况：</p>
<ul>
<li>跳过数组 <code>[1, , 3]</code> 中的值时</li>
<li>使用 <code>Array(length)</code> 时</li>
<li>使用<code>delete array[index]</code></li>
<li>当增加 <code>array.length</code> 属性时</li>
</ul>
<p>稀疏数组的问题在于某些 JavaScript 函数（如 <code>array.forEach()</code>、<code>array.map()</code> 等）在迭代数组项时会跳过空缺值。</p>
<h2 id="拓展">拓展</h2>
<p>稀疏数组在访问元素的速度上比密集数组慢</p>
<pre><code class="language-javascript">const arr = new Array(200000)
arr[19999] = 88
console.time('using[]')
arr[19999]
console.timeEnd('using[]')
// using[]: 0.031982421875ms

const ddd = [...new Array(200000)]
ddd[19999] = 88
console.time('using[]')
ddd[19999]
console.timeEnd('using[]')
// using[]: 0.010009765625ms 
</code></pre>
<p>具体原因是，对于稀疏数组 V8 引擎访问对象是使用 散列表模式的，该种模式在访问时需要计算一遍哈希值，所以会比较慢，但散列表对于空间利用来说，效率更高。而密集数组，它是申请一段连续的内存空间，访问时可以直接通过「索引」来访问，所以速度比较快。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 Trie：什么是前缀树？]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-trieshi-me-shi-qian-zhui-shu</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-trieshi-me-shi-qian-zhui-shu">
        </link>
        <updated>2021-12-10T08:02:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>我们已经在三篇文章中介绍了树数据结构的基础知识。如果你还没有读过这些，我强烈建议先阅读前三篇文章：</p>
<ul>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">使用递归和迭代算法遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li/">使用父指针遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom/">将树遍历算法应用于 DOM</a></li>
</ul>
<h2 id="介绍">介绍</h2>
<p>Trie 是树数据结构的一种变体。它也被称为前缀树或搜索树的变体。就像 n 叉树数据结构一样，trie 可以有 n 个来自单亲的孩子。通常，trie 中的所有节点都会存储一些字符。假设我们只处理英语单词，下面是一个简单的 trie 可能看起来像：<br>
<img src="https://umeimmense.github.io/post-images/1639386955366.jpeg" alt="" loading="lazy"><br>
需要注意的事项：</p>
<ol>
<li>
<p>我们正在尝试使用树来尽可能高效地表示英语单词。</p>
</li>
<li>
<p>在上图中，从根节点到任何绿色节点的路径表示一个英文单词。例如：</p>
<ul>
<li>NULL-&gt;C-&gt;A-&gt;T: CAT</li>
<li>NULL-&gt;D-&gt;O: DO</li>
<li>NULL-&gt;D-&gt;O-&gt;G: DOG</li>
<li>NULL-&gt;D-&gt;A-&gt;R-&gt;K: DARK</li>
<li>NULL-&gt;A: A</li>
<li>NULL-&gt;A-&gt;N: AN</li>
</ul>
</li>
<li>
<p>每个节点最多可以有 26 个子节点（如果我们只处理英文字母）。我们有一个 NULL 节点作为根节点，因为一个单词可以以 26 个字母中的任何一个开头，因此我们需要一个虚拟节点，它可以将任何潜在的第一个字母作为子节点。</p>
</li>
<li>
<p>绿色节点，本质上代表“词尾”，同时从根遍历到该节点。</p>
</li>
</ol>
<h2 id="实现节点">实现节点</h2>
<p>现在，让我们尝试提出 Trie 节点的表示。回到树节点，这就是我们呈现它的方式：</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.left = null
  this.right = null
}
</code></pre>
<p>因此，我们可以对 Trie 遵循类似的想法，同时确保它满足我们在介绍部分讨论的要求。要了解 Trie 节点的要求，让我们放大任何节点：<br>
<img src="https://umeimmense.github.io/post-images/1639387276741.jpeg" alt="" loading="lazy"><br>
所以现在更有意义了。这是最终的代码：</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.isEndOfWord = false // false by default, a green node means this flag is true
  this.children = {} // children are stored as Map, where key is the letter and value is a TrieNode for that letter 
}
</code></pre>
<h2 id="实现-trie-数据结构">实现 Trie 数据结构</h2>
<p>我们可以使用一个简单的 ES6 类来表示：</p>
<pre><code class="language-javascript">class Trie{
  constructor(){
    this.root = new Node(null)
  }

  insert(word){
   // TODO
  }

  search(word){
   // TODO
  }

}
</code></pre>
<p>所以我们已经准备好了大概。作为初始化的一部分，每个trie 都会创建它自己的根节点（NULL）。那么我们可以实现这两个方法如下：</p>
<ul>
<li>insert(word)：我们可以将单词拆分为字母，并为每个字母创建一个 Node()。然后我们可以开始将这些 Trie 节点中的每一个链接到根节点，以插入单词。最后，我们将最后插入的节点的 isEndOfWord 属性标记为 true。</li>
<li>search(word)：我们可以将单词拆分为字母。然后我们可以从根开始一个一个地寻找这些字母中的每一个。如果我们能够按顺序找到所有字母，那么我们可以返回 true 否则 false。</li>
</ul>
<p>让我们直观地理解这两个操作以获得更好的上下文：</p>
<ul>
<li>首先insert(CAR)然后insert(CAN):<br>
<img src="https://umeimmense.github.io/post-images/1639387651437.jpeg" alt="" loading="lazy"></li>
<li>首先search(CAR)然后search(CAN):<br>
<img src="https://umeimmense.github.io/post-images/1639387657794.jpeg" alt="" loading="lazy"></li>
</ul>
<p>实现如下：</p>
<pre><code class="language-javascript">class Trie{
  constructor(){
    this.root = new Node(null)
  }

  insert(word){
    let current = this.root
    // iterate through all the characters of word
    for(let character of word){
         // if node doesn't have the current character as child, insert it
         if(current.children[character] === undefined){
             current.children[character] = new Node(character)
         }
        // move down, to insert next character
        current = current.children[character]  
    }
    // mark the last inserted character as end of the word
    current.isEndOfWord = true
  }

  search(word){
     let current = this.root
    // iterate through all the characters of word
    for(let character of word){
         if(current.children[character] === undefined){
             // could not find this character in sequence, return false
             return false
         }
        // move down, to match next character
        current = current.children[character]  
    }
     // found all characters, return true if last character is end of a word
    return current.isEndOfWord
  }
}
</code></pre>
<h2 id="使用-trie">使用 Trie</h2>
<pre><code class="language-javascript">const trie = new Trie();

// insert few words
trie.insert(&quot;CAT&quot;);
trie.insert(&quot;DOG&quot;);

// search something
trie.search(&quot;MAT&quot;) // false
trie.search(&quot;DOG&quot;) // true
</code></pre>
<h3 id="空间复杂度">空间复杂度</h3>
<p>在最坏的情况下，所有插入单词的每个字符都可以占用 Trie 中的单个节点。所以这意味着最坏的空间复杂度可以是 (W*n)，其中 W 是每个单词的平均字符数，n 是 Trie 中的单词总数。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>插入：插入一个有n个字符的单词，只需要遍历n个字符，所以时间复杂度为O(n)</li>
<li>搜索：与插入类似，我们只需要遍历单词的所有字符即可进行搜索。所以时间复杂度是 O(n)，其中 n 是单词中的字符数。</li>
</ul>
<p>现在，想一想，你还能如何在庞大的单词列表中搜索某个单词？<br>
-可能使用数组？时间复杂度为 O(m)，其中 m 是单词总数，这很糟糕。</p>
<ul>
<li>如何使用Map（或 JavaScript 中的对象）？这会将时间复杂度降低到 O(1)，但是找到具有特定前缀的单词列表有多快？它将是 O(m)。</li>
</ul>
<p>Trie 不仅将时间复杂度降低到 O(n)（n = 单词中的字符数），而且您还可以有效地搜索具有前缀的单词列表，这对于任何以上两种方法。</p>
<h2 id="应用">应用</h2>
<ul>
<li>自动完成和预先输入：如果您在文本框中键入内容，并且看到具有相同前缀的潜在搜索列表，即自动完成小部件，那么这可能是由后台的 Trie 处理的。同样，<a href="https://en.wikipedia.org/wiki/Typeahead">Typeahead</a> 也可以使用 Trie 来实现。</li>
<li>拼写检查器：我们可以使用 trie 创建拼写检查器，即给定一个单词列表，我们可以检查给定单词的拼写是否正确。</li>
<li>IP 路由（最长前缀匹配）：Internet 由多个路由器节点组成，它们决定应该发送的目标数据包。 Internet 上的每个路由器都需要将数据包发送到由给定 IP 目的地决定的适当目标节点。但是每个路由器如何使用给定的 IP 地址决定下一个目标路由器呢？这个问题可以使用IP路由来解决。<a href="https://www.lewuathe.com/longest-prefix-match-with-trie-tree.html">这是一篇深入探讨这个主题的好文章</a>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 将树遍历算法应用于 DOM]]></title>
        <id>https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom</id>
        <link href="https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom">
        </link>
        <updated>2021-12-09T06:10:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>到目前为止，我们已经了解了一些二叉树遍历的方法：</p>
<ul>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">使用递归和迭代算法遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li/">使用父指针遍历二叉树</a><br>
在本文中，我们将把这些知识用于 n 叉树，即 DOM。我们将看到如何使用各种 CSS 选择器定位 DOM 元素，而无需使用内置 API，如 getElementById、getElementsByClassname 或 querySelector/querySelectorAll。因此，本文将阐明这些 API 可能如何在幕后工作。</li>
</ul>
<h2 id="dom-遍历">DOM 遍历</h2>
<p>借用 <a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">使用递归和迭代算法遍历二叉树</a>的思路，我们来得出DOM的前序遍历算法：</p>
<pre><code class="language-javascript">function walkPreOrder(node){
  if(!node) return

  // do something here
  console.log(node)

  for(let child of node.children){
     walkPreOrder(child)
  }
}
</code></pre>
<p>我们可以修改这个算法使之来返回一个迭代器：</p>
<pre><code class="language-javascript">function* walkPreOrder(node){
  if(!node) return

  // do something here
  yield node
  for(let child of node.children){
    yield* walkPreOrder(child)
  }
}

// USAGE
for(let node of walkPreOrder(root)){
  console.log(node)
}
</code></pre>
<p>我们可以使用任何广度优先或深度优先算法（在之前的文章中讨论过）来遍历 DOM。<br>
我们还假设正在处理具有以下 HTML 的文档：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;DOM selection algorithm&lt;/title&gt;
  &lt;/head&gt;
&lt;body&gt;

  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;body&quot;&gt;
      &lt;div class=&quot;row&quot;&gt;
        &lt;img id=&quot;profile&quot; src=&quot;xyz.jpg&quot; alt=&quot;&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;row&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;row&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="通过-id-定位节点">通过 ID 定位节点</h2>
<pre><code class="language-javascript">function locateById(nodeId){
  // iterate through all nodes in depth first (preOrder) fashion
  // return the node as soon as it's found
  for(let node of walkPreOrder(document.body)){
     if(node.id === nodeId){
        return node
     }
  }
   return null
}
</code></pre>
<p>我们可以使用 locateById() 函数如下：</p>
<pre><code class="language-javascript">const img = locateById('profile')
// returns the image node
</code></pre>
<h2 id="通过classname-定位节点">通过ClassName 定位节点</h2>
<p>浏览器提供 document.getElementsByClassName() API 来实现此结果。我们如何实现类似的东西：</p>
<pre><code class="language-javascript">function locateAllByClassName(className){
   const result = []
   for(let node of walkPreOrder(document.body)){
      if(node.classList.contains(className)){
        result.push(node)
      }
   }
   return result
}

// USAGE
const elements = locateAllByClassName('row')
</code></pre>
<h2 id="浏览器如何优化选择查询">浏览器如何优化选择查询</h2>
<p>选择 DOM 节点是 Web 应用程序相当常见的操作。为同一个选择器多次遍历树似乎不是最佳选择。浏览器通过使用记忆优化选择。<br>
查看 <a href="https://searchfox.org/mozilla-central/source/parser/html/javasrc/TreeBuilder.java#1467">mozilla 解析器的源代码</a>，即函数 startTag 的摘录：</p>
<pre><code class="language-javascript"> // ID uniqueness
 @IdType String id = attributes.getId();
 if (id != null) {
      LocatorImpl oldLoc = idLocations.get(id);
      if (oldLoc != null) {
            err(&quot;Duplicate ID \u201C&quot; + id + &quot;\u201D.&quot;);
            errorHandler.warning(new SAXParseException(
                  &quot;The first occurrence of ID \u201C&quot; + id
                  + &quot;\u201D was here.&quot;, oldLoc));
       } else {
            idLocations.put(id, new LocatorImpl(tokenizer));
       }
 }
</code></pre>
<p>我们可以看到这些节点 ID 保存在一个简单的哈希映射中。我们可以使用类似的方法来确保对同一 ID 的重复查询不需要完全遍历，相反，我们可以从 hashMap 中查找并返回它。<br>
以下是我们的解决方案：</p>
<pre><code class="language-javascript">function getSelectors(){
  const idLocations = {}
  const classLocations = {}

  // updated selector functions  
  function locateById(nodeId){
    if(idLocations.hasOwnProperty(nodeId)) 
       return idLocations[nodeId]

    for(let node of walkPreOrder(document.body)){
       if(node.id === nodeId){
          idLocations[nodeId]= node //memoize
          return node
       }
     }
    idLocations[nodeId]= null // memoize
    return null
  }

  function locateAllByClassName(className){
    if(classLocations.hasOwnProperty(className)) 
         return classLocations[className]

    const result = []
    for(let node of walkPreOrder(document.body)){
       if(node.classList.contains(className)){
          result.push(node)
        }
     }
     classLocations[nodeId]= result
     return result
  }

  return {
       locateById,
       locateAllByClassName
    }

} 

  // USAGE
  const {locateById, locateAllByClassName} = getSelectors();
  const result = locateAllByClassName('row') // returns array of elements
  const img = locateById('profile') // returns an element, if found
</code></pre>
<h2 id="处理更复杂的选择器">处理更复杂的选择器</h2>
<p>让我们尝试实现类似 element.querySelector 的方法。以下是 MDN 的描述：</p>
<blockquote>
<p>The querySelector() method of the Element interface returns the first element that is a descendant of the element on which it is invoked that matches the specified group of selectors.</p>
</blockquote>
<h3 id="样例">样例</h3>
<pre><code class="language-javascript">const firstRow = document.querySelector('.container .row:first-child')
</code></pre>
<p>在这种情况下，我们可以将任何 CSS 选择器传递给函数，它应该能够遍历 DOM 为我们找到该元素。让我们看看它是如何实现的：</p>
<pre><code class="language-javascript">// given a selector and root node, find that selector within the root node
function select(selector, root){
  for(let node of walkPreOrder(root)){
      if(node.matches(selector)){
        return node
     }
   }
  return null;
}


function myQuerySelector(path, node){
  // if path is empty, nothing to find
  if(path.length === 0) return null;

  // if node is not provided, let's assume user wants to search within document.body
  let root = node || document.body;  
  const selector = path[0];

  // if there's only one selector in the path, just traverse using select function above
  if(path.length === 1) return select(selector, root);

   // else, either the current node matches the first selector in path or not
   // if first selector matches with current node, look through it's children for subsequent selectors only
   // else, look through it's children for the whole path
  const newPath = root.matches(selector) ? path.slice(1): path;
  for(let child of root.children){
    const ans = myQuerySelector(newPath, child);
    if(ans) return ans
  }

  // nothing found
  return null;
}


// USAGE:
const firstRow = myQuerySelector([&quot;.container&quot;, &quot;.row&quot;])
</code></pre>
<p>myQuerySelectorAll 的实现（类似于 element.querySelectorAll）也遵循相同的方法，稍作修改：</p>
<pre><code class="language-javascript">function selectAll(selector, root){
  let result = []
  for(let node of walkPreOrder(root)){
      if(node.matches(selector)){
        result.push(node)
     }
   }
  return result;
}

function myQuerySelectorAll(path, node){
  let result = [];
  if(path.length === 0) return result;

  let root = node || document.body;  
  const selector = path[0];

  if(path.length === 1) return selectAll(selector, root);

  const newPath = root.matches(selector) ? path.slice(1): path;
  for(let child of root.children){
    result = [...result, ...myQuerySelectorAll(newPath, child)]

  }

  return result;
}
</code></pre>
<h2 id="进阶">进阶</h2>
<p>我们可以使用本文开头描述的递归前序遍历方法来克隆任何树。让我们看看我们如何使用它来克隆任何 DOM 树，类似于 element.cloneNode(true) 所做的：</p>
<ul>
<li>通过创建具有相同 tagName 的新节点然后复制属性来创建源节点的克隆。</li>
<li>对源节点的所有子节点递归调用 cloneTree 方法，并将返回的节点作为子节点附加到克隆节点。</li>
</ul>
<pre><code class="language-javascript">function cloneTree(node){
  if(!node) return

  const clonedNode = document.createElement(node.tagName.toLowerCase())
  const attributes = node.getAttributeNames()

  attributes.forEach(attribute =&gt; {
     clonedNode.setAttribute(attribute, node.getAttribute(attribute))
  })

  for(const child of node.children){
      clonedNode.append(cloneTree(child))
  }

  return clonedNode
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 Tree 使用父指针高效遍历]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li">
        </link>
        <updated>2021-12-08T03:18:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本系列的<a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">第一部分</a>中，我们研究了遍历二叉树的递归和迭代方法。<br>
在实际应用中，树节点有一个父节点是很常见的：一个指向父节点的指针，因此也称为父指针。让我们以浏览器中的 DOM 为例。假设我们使用以下命令选择任何节点：</p>
<pre><code class="language-javascript">const element = document.querySelector(&quot;#id&quot;)
</code></pre>
<p>在本文中，我们将研究如何使用这些父指针来提高遍历效率。我稍后会解释我所说的“更高效”是什么意思。在下一篇文章中，我们还将了解如何使用此处学到的经验教训从头开始创建 myQuery 库。</p>
<h2 id="更新节点定义">更新节点定义</h2>
<p>首先，我们需要更新Node 函数</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.left = null
  this.right = null
  this.parent = null // added parent field
}
</code></pre>
<p>现在让我们看看如何使用这个新的 Node 定义来创建一个类似的树，就像我们在上一篇文章中所做的那样。</p>
<pre><code class="language-javascript">const root = new Node(2)
const left = new Node(1)
root.left = left
left.parent = root

const right = new Node(3)
root.right = right
right.parent = root
</code></pre>
<p>我们只需要确保父指针指向父节点。这是我们使用上述代码获得的最终树的视觉参考：<br>
<img src="https://umeimmense.github.io/post-images/1639116374962.jpeg" alt="" loading="lazy"></p>
<p>##寻找后继节点</p>
<h3 id="前序后继">前序后继</h3>
<p>假设每个节点都有一个parent指针，如何找出二叉树中任何节点的 前序 后继？<br>
让我们试着分析一下这个问题：</p>
<ol>
<li>首先，我们在这里处理前序，这意味着我们正在寻找以下顺序：</li>
</ol>
<pre><code class="language-javascript">root -&gt; left -&gt; right
</code></pre>
<ol start="2">
<li>这意味着如果我们已经在当前节点，我们想寻找左子节点作为后继节点。</li>
<li>如果根本没有左子节点怎么办？那么在这种情况下，我们会寻找合适的节点，如果在有左子节点，那就是后继节点。</li>
<li>如果没有左子节点或右子节点，那么我们需要回溯（继续向上走向父节点）。我们一直回溯，直到通过它的右子节点到达父级（因为这意味着  前序 对于父级下的整个子树是完整的，根据 #1 的定义）。</li>
</ol>
<p>最终算法实现就是这样：</p>
<pre><code class="language-javascript">function preOrderSuccessor(node){
   if(!node) return

   if(node.left) return node.left
   if(node.right) return node.right

   let parent = node.parent

   while(parent &amp;&amp; parent.right === node) {
     node = node.parent
     parent = parent.parent
   }

   if(!parent) return null // we backtracked till root, so no successor

   return parent.right
}
</code></pre>
<p>可以根据下图更好的理解<br>
<img src="https://umeimmense.github.io/post-images/1639365381317.jpeg" alt="" loading="lazy"></p>
<h3 id="中序后继">中序后继</h3>
<ol>
<li>首先，我们在这里处理中序遍历，这意味着我们正在寻找以下顺序：</li>
</ol>
<pre><code class="language-javascript">root -&gt; left -&gt; right
</code></pre>
<ol start="2">
<li>如果我们在当前节点，并且它右边有右子节点，那么我们可以通过在右子树上找到最左边的节点来获得后继节点。</li>
<li>如果没有右子节点，那么我们需要回溯（向上移动）。我们一直向上移动，直到通过它的右子节点到达父节点，因为这意味着已经遍历了整个子树（根据 #1 中的定义）。</li>
<li>一旦我们找到最近的父节点，它是通过它的左子节点找到的，它就会作为后继节点返回。为什么？因为这意味着它是一个已经探索了左树的节点，所以根据 #1 中的定义，节点本身现在是后继节点。<br>
实现如下：</li>
</ol>
<pre><code class="language-javascript">function inOrderSuccessor(node){
   if(!node) return

   if(node.right){
     let current = node.right
     while(current &amp;&amp; current.left) current = current.left
     return current
   }

   let parent = node.parent

   while(parent &amp;&amp; parent.right === node) {
     root = node.parent
     parent = parent.parent
   }

   if(!parent) return null

   return parent
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://umeimmense.github.io/post-images/1639366519214.jpeg" alt="" loading="lazy"></figure>
<h3 id="后序后继">后序后继</h3>
<ol>
<li>首先，我们在这里处理后序遍历，这意味着我们正在寻找以下顺序：</li>
</ol>
<pre><code class="language-javascript">left -&gt; right -&gt; root
</code></pre>
<ol start="2">
<li>所以，如果我们在任何节点上，就意味着它的左右子树已经被访问过了。这意味着我们需要查看父级的继任者。</li>
<li>如果我们从它的右子节点到达父母，这意味着父母本身就是继任者，根据#1 中的定义</li>
<li>如果我们从它的左子节点到达父母，这意味着接下来要探索父母的右子节点（根据#1 中的定义）。所以现在我们需要简单地返回父节点右子节点中最左边的节点作为后继节点。<br>
实现如下：</li>
</ol>
<pre><code class="language-javascript">function postOrderSuccessor(node){
   if(!node) return

   let parent = node.parent
   if(!parent) return null

   if(parent.right === node). return parent

   let current = parent.right
   while(current &amp;&amp; (current.left || current.right)){
     current = (current.left || current.right)
   }

   return current
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://umeimmense.github.io/post-images/1639366689014.jpeg" alt="" loading="lazy"></figure>
<h2 id="使用后继算法更好地遍历">使用后继算法更好地遍历</h2>
<p>为什么我们需要使用父指针来提出遍历算法呢？这是一个值得思考的问题，因为我们已经提出了遍历树的递归和迭代方法，而且不需要父指针。</p>
<p>我们这样做的原因是因为我们之前的方法增加了空间复杂性。如果你还记得上一篇文章中我们需要使用一个或两个堆栈（取决于遍历方法）来使任何遍历算法工作。即使在递归方法中，虽然我们不直接使用堆栈，但递归本身基于调用堆栈，因此那里也使用了隐藏的内存中堆栈。问题是这个堆栈的大小会随着我们树的深度而增加，因此这不是最好的解决方案，因为我们有办法在花费更少空间的情况下完成相同的任务。通过使用父指针，我们可以完全摆脱这些堆栈，为我们节省大量空间，即从 O(logN) 的空间复杂度（其中 N 表示平衡树的大小）到 O(1)。让我们看看如何实现。</p>
<h3 id="前序遍历">前序遍历</h3>
<p>对于 前序遍历，我们从树的根部开始。之后，我们可以使用上面的算法继续获取前序后继以遍历整棵树：</p>
<pre><code class="language-javascript">function preOrder(root){
  // first node
  console.log(root.value);

  let current = root
  while(true){
    const next = preOrderSuccessor(current)
    if(!next) break

    // do something
    console.log(next.value)

    current = next
  }
}

</code></pre>
<h3 id="中序遍历">中序遍历</h3>
<p>对于 中序遍历，起始节点将是树的最左侧节点。此后，我们可以使用上述算法继续获取后继以遍历整棵树：</p>
<pre><code class="language-javascript">function inOrder(root){
  // start at the left most node
  while(root &amp;&amp; root.left){
    root = root.left
  }

  // first node
  console.log(root.value);

  let current = node
  while(true){
    const next = inOrderSuccessor(current)
    if(!next) break

    // do something
    console.log(current.value)

    current = next
  }
}

</code></pre>
<h3 id="后序遍历">后序遍历</h3>
<p>非常类似于上面的中序遍历的方法：</p>
<pre><code class="language-javascript">function postOrder(root){
  // start at the left most node
  while(root &amp;&amp; root.left){
    root = root.left
  }

  // first node
  console.log(root.value);

  let current = node
  while(true){
    const next = postOrderSuccessor(current)
    if(!next) break

    // do something
    console.log(current.value)

    current = next
  }
}
</code></pre>
<h2 id="进阶">进阶</h2>
<p>如果每个节点都有一个父指针，你能想出算法来寻找前任（inOrder、preOrder 和 postOrder）吗？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 Tree]]></title>
        <id>https://umeimmense.github.io/post/javascript-zhong-de-tree</id>
        <link href="https://umeimmense.github.io/post/javascript-zhong-de-tree">
        </link>
        <updated>2021-12-07T08:17:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>Tree是一种有趣的数据结构。它在各个领域都有广泛的应用。例如：</p>
<ul>
<li>DOM 是一种Tree状数据结构</li>
<li>我们操作系统中的目录和文件可以表示为Tree</li>
<li>家庭层次结构可以表示为Tree。<br>
Tree的许多变体（如堆、BST 等）可用于解决与调度、图像处理、数据库等相关的问题。许多复杂的问题乍一看似乎与Tree无关，但可以被表示为一个Tree的问题。我们也会（在本系列的后面部分）解决这些问题，从而了解Tree如何使看似复杂的问题更容易理解和解决。</li>
</ul>
<h2 id="简介">简介</h2>
<p>二叉树实现节点非常简单</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.left = null
  this.right = null
}
// usage
const root = new Node(2)
root.left = new Node(1)
root.right = new Node(3)
</code></pre>
<p>所以这几行代码将为我们创建一个二叉树，如下所示：</p>
<pre><code>           2  
        /      \
       /         \
     1            3
   /   \        /    \
null  null   null   null
</code></pre>
<h2 id="遍历">遍历</h2>
<p>让我们从尝试遍历这些连接的树节点（或一棵树）开始。正如我们可以遍历数组一样，如果我们也可以“遍历”树节点。然而，树不是像数组那样的线性数据结构，所以遍历这些的方法不止一种。我们可以将遍历方法大致分为以下几类：</p>
<ul>
<li>广度优先遍历</li>
<li>深度优先遍历</li>
</ul>
<h3 id="广度优先遍历bfs">广度优先遍历（BFS）</h3>
<p>在这种方法中，我们逐层遍历树。我们将从根开始，然后覆盖它的所有子级，然后覆盖所有 2 级子级，依此类推。例如对于上面的树，遍历会导致这样的结果：</p>
<pre><code>           2  
        /      \
       /         \
     1            3
   /   \        /    \
null  null   null   null
2，1，3
</code></pre>
<p>下面是一个稍微复杂的树的插图，使这更容易理解：<br>
<img src="https://umeimmense.github.io/post-images/1638865775709.png" alt="" loading="lazy"></p>
<p>为了实现这种形式的遍历，我们可以使用队列（先进先出）数据结构。以下是整个算法的过程：</p>
<ol>
<li>初始化一个包含 root 的队列</li>
<li>从队列中删除第一项</li>
<li>将弹出项的左右节点推入队列</li>
<li>重复步骤 2 和 3，直到队列为空<br>
下面是这个算法在实现后的样子：</li>
</ol>
<pre><code class="language-javascript">function walkBFS(root){
  if(root === null) return

  const queue = [root]
  while(queue.length){
      const item = queue.shift()
      // do something
      console.log(item)

      if(item.left) queue.push(item.left)
      if(item.right) queue.push(item.right)
   }
}
</code></pre>
<p>我们可以稍微修改上面的算法实现为：</p>
<pre><code class="language-javascript">function walkBFS(root){
  if(root === null) return

  const queue = [root], ans = []

  while(queue.length){
      const len = queue.length, level = []
      for(let i = 0; i &lt; len; i++){
          const item = queue.shift()
          level.push(item)
          if(item.left) queue.push(item.left)
          if(item.right) queue.push(item.right)
       }
       ans.push(level)
   }
  return ans
}
</code></pre>
<h3 id="深度优先遍历dfs">深度优先遍历（DFS）</h3>
<p>在 DFS 中，我们取一个节点并继续探索它的子节点，直到深度耗尽为止。它可以通过以下方式之一完成：</p>
<pre><code> root node -&gt; left node -&gt; right node // pre-order traversal
 left node -&gt; root node -&gt; right node // in-order traversal
 left node -&gt; right node -&gt; root node // post-order traversal
</code></pre>
<p>所有这些遍历技术都可以递归和迭代实现。让我们进入实现细节：</p>
<h4 id="前序遍历pre-order-traversal">前序遍历(Pre-Order traversal)</h4>
<h5 id="分析">分析</h5>
<pre><code> root node -&gt; left node -&gt; right node
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://umeimmense.github.io/post-images/1638866252844.png" alt="" loading="lazy"></figure>
<h5 id="技巧">技巧:</h5>
<p>我们可以使用这个简单的技巧来手动找出任何树的前序遍历：从根节点开始遍历整棵树，保持自己在左边。</p>
<h5 id="实现">实现</h5>
<ul>
<li>递归</li>
</ul>
<pre><code class="language-javascript">function walkPreOrder(root){
  if(root === null) return

  // do something here
  console.log(root.val)

  // recurse through child nodes
  if(root.left) walkPreOrder(root.left)
  if(root.right) walkPreOrder(root.right)
}

</code></pre>
<ul>
<li>迭代<br>
前序遍历的迭代方法与 BFS 非常相似，不同之处在于我们使用堆栈而不是队列，并且我们首先将右节点推入堆栈：</li>
</ul>
<pre><code class="language-javascript">function walkPreOrder(root){
  if(root === null) return

  const stack = [root]
  while(stack.length){
      const item = stack.pop()

      // do something
      console.log(item)

      // Left child is pushed after right one, since we want to print left child first hence it must be above right child in the stack
      if(item.right) stack.push(item.right)
      if(item.left) stack.push(item.left)
   }
}
</code></pre>
<h4 id="中序遍历in-order-traversal">中序遍历(In-Order traversal)</h4>
<h5 id="分析-2">分析</h5>
<p>下面是一棵树的中序遍历的过程：</p>
<pre><code>left node -&gt; root node -&gt; right node
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://umeimmense.github.io/post-images/1638870255515.png" alt="" loading="lazy"></figure>
<h5 id="技巧-2">技巧</h5>
<p>我们可以使用这个简单的技巧来手动找出任何树的中序遍历：在树的底部水平放置一个平面镜，并获取所有节点的投影<br>
<img src="https://umeimmense.github.io/post-images/1638870350959.png" alt="" loading="lazy"></p>
<h5 id="实现-2">实现</h5>
<ul>
<li>递归<pre><code class="language-javascript">function walkInOrder(root){
if(root === null) return

if(root.left) walkInOrder(root.left)

</code></pre>
</li>
</ul>
<p>// do something here<br>
console.log(root.val)</p>
<p>if(root.right) walkInOrder(root.right)<br>
}</p>
<pre><code>- 迭代
这个算法乍一看可能有点神秘。但它相当直观。让我们这样看：在中序遍历中，最左边的孩子节点首先被打印，然后是根，然后是孩子节点。所以首先想到的是想出这样的东西：
```javascript
const curr = root

while(curr){
while(curr.left){
  curr = curr.left // get to leftmost child
}

console.log(curr) // print it

curr = curr.right // now move to right child
}
</code></pre>
<p>在上述方法中，我们无法回溯，即返回导致最左侧节点的父节点。所以我们需要一个堆栈来记录这些。因此，我们修订后的方法可能如下所示：</p>
<pre><code class="language-javascript">const stack = []
const curr = root

while(stack.length || curr){
while(curr){
  stack.push(curr) // keep recording the trail, to backtrack
  curr = curr.left // get to leftmost child
}
const leftMost = stack.pop()
console.log(leftMost) // print it

curr = leftMost.right // now move to right child
}
</code></pre>
<p>现在我们可以使用上面的方法来制定最终的迭代算法：</p>
<pre><code class="language-javascript">function walkInOrder(root){
  if(root === null) return

  const stack = []
  let current = root

  while(stack.length || current){
      while(current){
         stack.push(current)
         current = current.left
      }
      const last = stack.pop()

      // do something
      console.log(last)

      current = last.right
   }
}
</code></pre>
<h4 id="后序遍历post-order-traversal">后序遍历（Post-Order traversal）</h4>
<h5 id="分析-3">分析</h5>
<p>下面是一棵树的中序遍历的过程：</p>
<pre><code> left node -&gt; right node -&gt; root node
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://umeimmense.github.io/post-images/1638870734512.png" alt="" loading="lazy"></figure>
<h5 id="技巧-3">技巧</h5>
<p>对于任何树的快速手动后序遍历：一个接一个地提取所有最左边的孩子节点。<br>
<img src="https://umeimmense.github.io/post-images/1638870834926.png" alt="" loading="lazy"></p>
<h5 id="实现-3">实现</h5>
<p>让我们深入研究这种遍历的实际实现。</p>
<ul>
<li>递归<pre><code class="language-javascript">  function walkPostOrder(root){
  if(root === null) return

  if(root.left) walkPostOrder(root.left)
  if(root.right) walkPostOrder(root.right)

  // do something here
  console.log(root.val)

  }
</code></pre>
</li>
<li>迭代<br>
我们已经有了用于前序遍历的迭代算法。我们可以用那个吗？因为后序遍历似乎只是前序遍历的反向。让我们来看看：</li>
</ul>
<pre><code>// PreOrder:
root -&gt; left -&gt; right

// Reverse of PreOrder:
right -&gt; left -&gt; root

// But PostOrder is:
left -&gt; right -&gt; root
</code></pre>
<p>从上面分析可见有细微的差别。我们可以通过稍微修改我们的 前序遍历算法然后反转它应该给出 后序遍历结果来适应这一点。总体算法将是：</p>
<pre><code>// record result using 
root -&gt; right -&gt; left

// reverse result
left -&gt; right -&gt; root
</code></pre>
<ul>
<li>使用与上述迭代前序遍历算法类似的方法，使用临时堆栈。
<ul>
<li>唯一的区别是 root -&gt; right -&gt; left 而不是 root -&gt; left -&gt; right</li>
</ul>
</li>
<li>结果将遍历序列记录在一个array</li>
<li>结果的反转就是后序遍历</li>
</ul>
<pre><code class="language-javascript">function walkPostOrder(root){
  if(root === null) return []

  const tempStack = [root], result = []

  while(tempStack.length){
      const last = tempStack.pop()

      result.push(last)

      if(last.left) tempStack.push(last.left)
      if(last.right) tempStack.push(last.right)
    }

    return result.reverse()
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初探 React Router 6 ]]></title>
        <id>https://umeimmense.github.io/post/chu-tan-react-router-6</id>
        <link href="https://umeimmense.github.io/post/chu-tan-react-router-6">
        </link>
        <updated>2021-12-03T07:34:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>不久前，React Router 库更新到了第 6 版，随之而来的是一些有趣的变化，本文将讲述React Router 6的一些新特性及使用的案例。<br>
接下来是一些准备工作：</p>
<ol>
<li>首先需要创建一个新的 React 项目（例如 create-react-app）。然后，按照官方文档安装 React Router。</li>
</ol>
<pre><code class="language-shell">yarn add react-router-dom@latest    
</code></pre>
<p><img src="https://umeimmense.github.io/post-images/1638518814219.png" alt="" loading="lazy"><br>
我们这里安装的是6.0.2版本。<br>
2. 第一个实现细节将告诉我们的 React 应用程序我们想要使用 React Router。因此，在 React 项目的顶级文件（例如 index.js）中导入 Router 组件，其中 React 使用 ReactDOM API 挂载到 HTML：</p>
<pre><code class="language-jsx">import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';

import App from './App';

ReactDOM.render(
  &lt;BrowserRouter&gt;
    &lt;App /&gt;
  &lt;/BrowserRouter&gt;,
  document.getElementById('root')
);
</code></pre>
<p>从这里开始，我们将在 App.js 文件中继续我们的实现。</p>
<h2 id="匹配路由">匹配路由</h2>
<p>首先，我们将使用 React Router 的 Link 组件在我们的 App 组件中实现导航。我不建议使用内联样式，因此请根据你的 React 项目选择合适的样式策略和样式方法：</p>
<pre><code class="language-jsx">import { Link } from 'react-router-dom';

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;
      &lt;Navigation /&gt;
    &lt;/&gt;
  );
};

const Navigation = () =&gt; {
  return (
    &lt;nav
      style={{
        borderBottom: 'solid 1px',
        paddingBottom: '1rem',
      }}
    &gt;
      &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
      &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
    &lt;/nav&gt;
  );
};
</code></pre>
<p><img src="https://umeimmense.github.io/post-images/1638519209630.png" alt="" loading="lazy"><br>
当你在浏览器中启动 React 应用程序时，你应该能够单击两个 Link 组件，这些组件应该将你导航到各自的路由。单击这些链接时，可通过检查浏览器的当前 URL 来确认。接下来，我们需要使用 React Router 的 Route 组件将路由映射到实际渲染：</p>
<pre><code class="language-jsx">import { Routes, Route, Link } from 'react-router-dom';

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;Navigation /&gt;

      &lt;Routes&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};

const Navigation = () =&gt; {
  return (
    &lt;nav
      style={{
        borderBottom: 'solid 1px',
        paddingBottom: '1rem',
      }}
    &gt;
      &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
      &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
    &lt;/nav&gt;
  );
};
</code></pre>
<p>你可以通过检查它们各自的 to 和 path 属性来查看 Link 和 Route 组件之间的直接匹配。当路由匹配时，每个 Route 组件都会渲染一个 React 元素。由于我们在这里渲染一个 React 元素，我们也可以传递 React props。缺少的是相应功能组件的声明：</p>
<pre><code class="language-jsx">const Home = () =&gt; {
  return (
    &lt;main style={{ padding: '1rem 0' }}&gt;
      &lt;h2&gt;Home&lt;/h2&gt;
    &lt;/main&gt;
  );
};

const Users = () =&gt; {
  return (
    &lt;main style={{ padding: '1rem 0' }}&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
    &lt;/main&gt;
  );
};
</code></pre>
<p>返回浏览器时，你应该能够在看到 Home 和 Users 组件的同时从一个页面导航到另一个页面（此处：从 /home 到 /users 路由）。基本上这就是 React Router 的本质：设置 Link 组件并将它们与 Route 组件匹配。链接与路由是多对一的关系，因此你的应用程序中可以有多个链接链接到同一个路由。</p>
<h2 id="布局路由-索引路由-无匹配路由">布局路由、索引路由、无匹配路由</h2>
<p>接下来，你将看到新的 Home 和 Users 组件如何共享相同的布局。作为 React 开发人员，直觉上我们会从 Home 和 Users 组件中提取一个带有样式的新组件，以避免重复。在这个新组件中，我们将使用 React 的 children 属性将组件组合在一起。第一步，将样式提取到它自己的组件中：</p>
<pre><code class="language-jsx">const Home = () =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Home&lt;/h2&gt;
    &lt;/&gt;
  );
};

const Users = () =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
    &lt;/&gt;
  );
};

const Layout = ({ children }) =&gt; {
  return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;;
};
</code></pre>
<p>其次，在 App 组件中渲染它。通过使用 React 的子级，Layout 组件应该渲染匹配的封闭子路由：</p>
<pre><code class="language-jsx">import { Routes, Route, Link } from 'react-router-dom';

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;Navigation /&gt;

      &lt;Routes&gt;
        &lt;Layout&gt;
          &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
          &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt;
        &lt;/Layout&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};

const Navigation = () =&gt; {
  return (
    &lt;nav
      style={{
        borderBottom: 'solid 1px',
        paddingBottom: '1rem',
      }}
    &gt;
      &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
      &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
    &lt;/nav&gt;
  );
};

const Home = () =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Home&lt;/h2&gt;
    &lt;/&gt;
  );
};

const Users = () =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
    &lt;/&gt;
  );
};

const Layout = ({ children }) =&gt; {
  return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;;
};
</code></pre>
<p>但是你会看到这在 React Router 中是不允许的，你会得到一个异常说：<Routes> 的所有组件子项必须是 <Route> 或 &lt;React.Fragment&gt;。解决此问题的一种常见方法是在每个组件中单独使用 Layout 组件（类似于我们之前使用的）或在每个 Route 组件中（如下例所示）：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  return (
    &lt;&gt;
      ...

      &lt;Routes&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Layout&gt;&lt;Home /&gt;&lt;/Layout&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Layout&gt;&lt;Users /&gt;&lt;/Layout&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>然而，这给 React 应用程序增加了不必要的冗余。因此，我们将使用所谓的 Layout Route，而不是复制 Layout 组件，它不是实际的路由，而只是一种方法，可以让一组 Route 中的每个 Route 组件的元素具有相同的周围样式：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  return (
    &lt;&gt;
      ...

      &lt;Routes&gt;
        &lt;Route element={&lt;Layout /&gt;}&gt;
          &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
          &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>如你所见，可以将 Route 组件嵌套在另一个 Route 组件中——而前者成为所谓的嵌套路由。现在不再在 Layout 组件中使用 React 的子组件，而是使用 React Router 的 Outlet 组件作为等效组件：</p>
<pre><code class="language-jsx">import { Routes, Route, Outlet, Link } from 'react-router-dom';

...

const Layout = () =&gt; {
  return (
    &lt;main style={{ padding: '1rem 0' }}&gt;
      &lt;Outlet /&gt;
    &lt;/main&gt;
  );
};
</code></pre>
<p>本质上，Layout 组件中的 Outlet 组件插入了父路由（这里：Layout 组件）的匹配子路由（这里：Home 或 Users 组件）。毕竟，使用 Layout Route 可以帮助你为集合中的每个 Route 组件提供相同的布局（例如，CSS 样式，HTML 结构）。</p>
<p>从这里开始，你可以更进一步，将 App 组件的所有实现细节（标题、导航）移动到这个新的 Layout 组件中。此外，我们可以与 NavLink 组件交换链接，以实现所谓的活动链接——向用户显示当前活动的路线。因此，当将新的 NavLink 组件与函数一起使用时，我们可以访问其style和 className props中的 isActive 标志：</p>
<pre><code class="language-jsx">import { Routes, Route, Link, NavLink, Outlet } from 'react-router-dom';

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;Navigation /&gt;

      &lt;Routes&gt;
        &lt;Route element={&lt;Layout /&gt;}&gt;
          &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
          &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/&gt;
  );
};

const Navigation = () =&gt; {
  return (
    &lt;nav
      style={{
        borderBottom: 'solid 1px',
        paddingBottom: '1rem',
      }}
    &gt;
      &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;
      &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
    &lt;/nav&gt;
  );
};

const Home = () =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Home&lt;/h2&gt;
    &lt;/&gt;
  );
};

const Users = () =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
    &lt;/&gt;
  );
};

const Layout = () =&gt; {
  const style = ({ isActive }) =&gt; ({
    fontWeight: isActive ? 'bold' : 'normal',
  });

  return (
    &lt;&gt;
      &lt;h1&gt;React Router&lt;/h1&gt;

      &lt;nav
        style={{
          borderBottom: 'solid 1px',
          paddingBottom: '1rem',
        }}
      &gt;
        &lt;NavLink to=&quot;/home&quot; style={style}&gt;Home&lt;/NavLink&gt;
        &lt;NavLink to=&quot;/users&quot; style={style}&gt;Users&lt;/NavLink&gt;
      &lt;/nav&gt;

      &lt;main style={{ padding: '1rem 0' }}&gt;
        &lt;Outlet /&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>接下来你可能已经注意到这个 React 应用程序缺少一个基本路由。虽然我们有 /home 和 /users 路由，但没有 / 路由。你也会在浏览器的开发人员工具中看到此警告：没有路由匹配位置“/”。因此，每当用户访问 / 路由时，我们都会创建一个所谓的索引路由作为回退。此回退路由的元素可以是新组件或任何已匹配的路由（例如，Home 应为路由 / 和 /home 呈现，如下例所示）：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
};
</code></pre>
<p>当父路由匹配但没有子路由匹配时，你可以将索引路由视为默认路由。接下来，如果用户导航到不匹配的路由（例如 /about），我们将添加一个所谓的 No Match Route（也称为 Not Found Route），它相当于网站的 404 页面：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
};

const NoMatch = () =&gt; {
  return (&lt;p&gt;There's nothing here: 404!&lt;/p&gt;);
};
</code></pre>
<p>到目前为止，在使用 Routes 组件作为 Route 组件集合的容器时，通过使用 Layout Routes、Index Routes 和 No Match Routes 展示了 React Router 的其他最佳实践。如你所见，也可以将 Route 组件嵌套到 Route 组件中。下面我们接着了解有关嵌套路由的更多信息。</p>
<h2 id="动态且嵌套的路由">动态且嵌套的路由</h2>
<p>接下来我们将用实现细节来装饰用户组件。首先，我们将在我们的 App 组件中初始化一个项目列表（这里是：用户）。该列表只是示例数据，但它也可以在 React 中从远程 API 获取。其次，我们将用户作为props传递给用户组件：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const users = [
    { id: '1', fullName: 'Robin Wieruch' },
    { id: '2', fullName: 'Sarah Finnley' },
  ];

  return (
    &lt;Routes&gt;
      &lt;Route element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;} /&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
};
</code></pre>
<p>Users 组件成为 React 中的列表组件，因为它遍历每个用户并为其返回 JSX。在这种情况下，它不仅仅是一个列表，因为我们将 React Router 的 Link 组件添加到组合中。 Link 组件中的相对路径提示相应的动态（此处：/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi></mrow><mi mathvariant="normal">）</mi><mi mathvariant="normal">尚</mi><mi mathvariant="normal">未</mi><mi mathvariant="normal">嵌</mi><mi mathvariant="normal">套</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">此</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{user.id}）尚未嵌套（此处：/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">尚</span><span class="mord cjk_fallback">未</span><span class="mord cjk_fallback">嵌</span><span class="mord cjk_fallback">套</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">：</span><span class="mord">/</span></span></span></span>{user.id} 嵌套在 /users 中）路由：</p>
<pre><code class="language-jsx">const Users = ({ users }) =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;

      &lt;ul&gt;
        {users.map((user) =&gt; (
          &lt;li key={user.id}&gt;
            &lt;Link to={`/users/${user.id}`}&gt;
              {user.fullName}
            &lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>通过拥有这个新的动态嵌套路由，我们需要在 App 组件中为它创建一个匹配的嵌套路由组件。首先，由于它是 /users 路由的所谓嵌套路由（或子路由），我们可以将它嵌套在相应的父路由组件中。此外，由于它是所谓的动态路由，它使用定义为 :userId 的动态路由，而用户的标识符则动态匹配（例如，id 为 '1' 的用户将与 /users/1 匹配）：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const users = [
    { id: '1', fullName: 'Robin Wieruch' },
    { id: '2', fullName: 'Sarah Finnley' },
  ];

  return (
    &lt;Routes&gt;
      &lt;Route element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt;
          &lt;Route path=&quot;:userId&quot; element={&lt;User /&gt;} /&gt;
        &lt;/Route&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
};
</code></pre>
<p>之前，当我们介绍将 /home 和 /users 路由作为其子路由的父布局路由时，我们已经了解了嵌套路由。当我们进行此更改时，我们必须使用父路由中的 Outlet 组件来渲染匹配的子路由。同样的情况在这里再次发生，因为用户组件也必须渲染它的嵌套路由：</p>
<pre><code class="language-jsx">const Users = ({ users }) =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;

      &lt;ul&gt;...&lt;/ul&gt;

      &lt;Outlet /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>接下来，我们将声明缺少的 User 组件，只要用户的标识符在 URL 中匹配，该组件就会通过 Users 组件中的 Outlet 嵌套。因此，我们可以使用 React Router 的 useParams Hook 从 URL 中获取相应的 userId（等于 :userId）：</p>
<pre><code class="language-jsx">import {
  ...
  useParams,
} from 'react-router-dom';

...

const User = () =&gt; {
  const { userId } = useParams();

  return (
    &lt;&gt;
      &lt;h2&gt;User: {userId}&lt;/h2&gt;

      &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>我们再次看到了如何通过将一个 Route 组件（或多个 Route 组件）嵌套在另一个 Route 组件中来创建嵌套路由。前者是嵌套的子路由，后者是渲染封闭组件的父路由，该组件必须使用 Outlet 组件来渲染实际匹配的子路由。</p>
<p>我们还看到了如何通过在路由的路径属性（例如：userId）中使用冒号来创建动态路由。本质上， :userId 充当任何标识符的星号。在我们的例子中，我们使用 Link 组件将用户导航到 /users/:userId 路由，其中​​ :userId 代表实际用户的标识符。最后，我们总是可以通过使用 React Router 的 useParams Hook 从 URL 中获取动态路径（称为参数或 params）。</p>
<h2 id="react-router中的相关链接">React Router中的相关链接</h2>
<p>最新版本的 React Router 带有所谓的相对链接。我们将通过查看用户组件及其用于链接组件的绝对 /users/${user.id} 路径来研究这个概念。在之前版本的 React Router 中，需要指定整个路径。但是，在此版本中，你可以仅使用嵌套路径作为相对路径：</p>
<pre><code class="language-jsx">const Users = ({ users }) =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;

      &lt;ul&gt;
        {users.map((user) =&gt; (
          &lt;li key={user.id}&gt;
            &lt;Link to={user.id}&gt;
              {user.fullName}
            &lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>由于 Users 组件用于 /users 路由，因此 Users 组件中的 Link 知道其当前位置，不需要创建绝对路径的整个顶级部分。相反，它知道 /users 并且只是附加 :userId 作为它的相对路径。</p>
<h2 id="声明式和程序式导航">声明式和程序式导航</h2>
<p>到目前为止，我们只在使用 Link 或 NavLink 组件时使用了声明式导航。但是，在某些情况下，你希望能够通过 JavaScript 以编程方式导航用户。我们将通过实现一个可以在 User 组件中删除用户的功能来展示这个场景。在删除后，用户应该从 User 组件导航到 Users 组件（从 /users/:userId 到 /users）。</p>
<p>我们将通过使用 React 的 useState Hook 创建一个有状态的 users 值来开始这个实现，然后实现一个事件处理程序，该处理程序使用标识符从用户中删除用户：</p>
<pre><code class="language-jsx">import * as React from 'react';
...

const App = () =&gt; {
  const [users, setUsers] = React.useState([
    { id: '1', fullName: 'Robin Wieruch' },
    { id: '2', fullName: 'Sarah Finnley' },
  ]);

  const handleRemoveUser = (userId) =&gt; {
    setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId));
  };

  return (
    &lt;Routes&gt;
      &lt;Route element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt;
          &lt;Route
            path=&quot;:userId&quot;
            element={&lt;User onRemoveUser={handleRemoveUser} /&gt;}
          /&gt;
        &lt;/Route&gt;
        &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
};
</code></pre>
<p>在我们将事件处理程序作为回调处理程序传递给 User 组件后，我们可以在那里使用它作为内联处理程序来通过标识符删除特定用户：</p>
<pre><code class="language-jsx">const User = ({ onRemoveUser }) =&gt; {
  const { userId } = useParams();

  return (
    &lt;&gt;
      &lt;h2&gt;User: {userId}&lt;/h2&gt;

      &lt;button type=&quot;button&quot; onClick={() =&gt; onRemoveUser(userId)}&gt;
        Remove
      &lt;/button&gt;

      &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>一旦用户被删除，我们可以使用 React Router 的 useNavigate Hook，它允许我们以编程方式将用户导航到另一个路由（这里：/users）：</p>
<pre><code class="language-jsx">import * as React from 'react';
import {
  ...
  useNavigate,
} from 'react-router-dom';

const App = () =&gt; {
  const navigate = useNavigate();

  const [users, setUsers] = React.useState([
    { id: '1', fullName: 'Robin Wieruch' },
    { id: '2', fullName: 'Sarah Finnley' },
  ]);

  const handleRemoveUser = (userId) =&gt; {
    setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId));

    navigate('/users');
  };

  return (...);
};
</code></pre>
<p>在这种情况下，删除操作是同步发生的，因为用户只是客户端的一个有状态值。但是，如果用户是数据库中的实体，则必须发出异步请求才能删除它。一旦这个操作成功（例如：promise是 resolved时），用户就会被导航到 /users 路由。你可以通过在 React 中设置一个虚假的 API 来自己尝试这个场景，而不使用实际的服务器。</p>
<h2 id="搜索参数">搜索参数</h2>
<p>浏览器中的 URL 不仅包含路径，还包含一个可选的查询字符串（在 React Router 中称为搜索参数），它以键/值对的形式出现在 ? URL 中的分隔符。例如，/users?name=robin 将是一个带有一对搜索参数的 URL，其中键是名称，值是 robin。以下示例将其显示为实现：</p>
<pre><code class="language-jsx">import * as React from 'react';
import {
  ...
  useSearchParams,
} from 'react-router-dom';

...

const Users = ({ users }) =&gt; {
  const [searchParams, setSearchParams] = useSearchParams();

  const searchTerm = searchParams.get('name') || '';

  const handleSearch = (event) =&gt; {
    const name = event.target.value;

    if (name) {
      setSearchParams({ name: event.target.value });
    } else {
      setSearchParams({});
    }
  };

  return (
    &lt;&gt;
      &lt;h2&gt;Users&lt;/h2&gt;

      &lt;input
        type=&quot;text&quot;
        value={searchTerm}
        onChange={handleSearch}
      /&gt;

      &lt;ul&gt;
        {users
          .filter((user) =&gt;
            user.fullName
              .toLowerCase()
              .includes(searchTerm.toLocaleLowerCase())
          )
          .map((user) =&gt; (
            &lt;li key={user.id}&gt;
              &lt;Link to={user.id}&gt;{user.fullName}&lt;/Link&gt;
            &lt;/li&gt;
          ))}
      &lt;/ul&gt;

      &lt;Outlet /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>首先，我们使用 React Router 的 useSearchParams Hook 从 URL 中读取当前搜索参数（请参阅 searchParams 上的 get() 方法），同时还将搜索参数写入 URL（请参阅 setSearchParams() 函数）。虽然我们使用前者按键获取搜索参数（此处：“name”）来控制输入字段，但我们使用后者在 URL 中按键设置搜索参数。在输入字段中键入。在其核心，React Router 的 useSearchParams Hook 与 React 的 useState Hook 相同，区别在于该状态是 URL 状态，而不是 React 中的本地状态。最后我们使用搜索参数来过滤用户的实际列表以完成此功能。</p>
<p>毕竟，在你的 URL 中包含搜索参数可以让你与他人共享更具体的 URL。如果你在一个搜索黑色鞋子的电子商务网站上，你可能希望共享整个 URL（例如 myecommerce.com/shoes?color=black）而不仅仅是路径（例如 myecommerce.com/shoes）。</p>
<h2 id="总结">总结</h2>
<p>React Router 是 React 最常用的第三方库之一。它的核心功能是将 Link 组件映射到 Route 组件，这使开发人员无需向 Web 服务器发出请求即可实现客户端路由。然而，除了这个核心功能之外，它还是一个成熟的路由库，它支持声明式嵌套路由、动态路由、导航、活动链接，还可以通过 URL 进行编程导航和搜索。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/remix-run/react-router/releases">react-router</a><br>
<a href="https://create-react-app.dev/docs/getting-started/">CRA</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 引擎如何提升其运行时的性能？]]></title>
        <id>https://umeimmense.github.io/post/javascript-yin-qing-ru-he-ti-sheng-qi-yun-xing-shi-de-xing-neng</id>
        <link href="https://umeimmense.github.io/post/javascript-yin-qing-ru-he-ti-sheng-qi-yun-xing-shi-de-xing-neng">
        </link>
        <updated>2021-12-02T14:43:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>JavaScript 是一项令人印象深刻的技术。不是因为它设计得特别好，也不是因为世界上几乎所有可以访问互联网的设备都执行 JavaScript 程序。相反，JavaScript 令人印象深刻，是因为它的几乎每一个特性都使它成为优化的噩梦，但是它速度很快。</p>
<p>javascript 为什么会执行速度很快呢？这就是我们需要去深入探究的问题。</p>
<p>在本文中，我们将仔细研究不同 JavaScript 引擎用于实现良好运行时性能的一些技术，在研究过程中省略了一些细节，并简化了事情。本文的目标不是让您了解事物的确切运作方式，而是让您了解并理解引擎如何提升其运行时的一些基本知识。</p>
<h2 id="执行模型">执行模型</h2>
<p>当您的浏览器下载 JavaScript 时，其首要任务是让它尽快运行。它通过将代码转换为字节码、虚拟机指令，然后将其移交给理解如何执行它们的解释器或虚拟机来实现。</p>
<p>您可能会问为什么浏览器会将 JavaScript 转换为虚拟机指令而不是实际的机器指令？这是个好问题。事实上，直到最近，V8（Chrome 的 JavaScript 引擎）还一直在做直接转换为机器指令的工作。</p>
<p>特定编程语言的虚拟机通常是更容易编译的目标，因为它与源语言的关系更密切。实际的机器有一个更通用的指令集，因此需要更多的工作来翻译编程语言以很好地处理这些指令。这种困难意味着编译需要更长的时间，同时也意味着 JavaScript 开始执行需要更长的时间。</p>
<p>例如，理解 JavaScript 的虚拟机也可能理解 JavaScript 对象。因此，执行像 object.x 这样的语句所需的虚拟指令可能是一两条指令。一台不了解 JavaScript 对象如何工作的实际机器需要更多的指令来确定 .x 在内存中的位置以及如何获取它。</p>
<p>虚拟机的问题在于它是虚拟的, 它是不存在的。指令不能直接执行，必须在运行时解释。解释代码总是比直接执行代码慢。</p>
<p>这里有一个问题需要权衡。需要在更快的编译时间与更快的运行时间中做一个选择。在许多情况下，更快的编译是一个很好的权衡。用户不太可能关心单个按钮的点击是否需要 20 或 40 毫秒的执行时间，尤其是当按钮只被按下一次时。快速编译 JavaScript，即使生成的代码执行速度较慢，也会让用户更快地查看页面并与页面交互。</p>
<p>有些情况在计算上是昂贵的。诸如游戏、语法高亮之类的场景。在这种情况下，编译和执行机器指令的时间加起来可能会减少总执行时间。那么 JavaScript 是如何处理这些情况的呢？</p>
<h2 id="经常被执行的代码">经常被执行的代码</h2>
<p>每当 JavaScript 引擎检测到某个函数执行了很多次时，它就会将该函数交给优化编译器。该编译器将虚拟机指令翻译成实际的机器指令。更重要的是，由于该函数已经运行了多次，优化编译器可以根据之前的运行做出一些假设。换句话说，它可以执行推测优化以生成更快的代码。</p>
<p>如果这些推测后来被证明是错误的，会发生什么？ JavaScript引擎可以简单地删除错误的函数，并还原为使用未优化版本。一旦该函数再运行几次，它就可以尝试再次将其传递给优化编译器，这一次它会提供更多可用于推测优化的信息。</p>
<p>既然我们知道频繁运行的函数在优化过程中使用来自先前执行的信息，接下来要探索的是这是什么类型的信息。</p>
<h2 id="翻译问题">翻译问题</h2>
<p>JavaScript 中的几乎所有东西都是对象。不幸的是，JavaScript 对象很难让机器处理。让我们看看下面的代码：</p>
<pre><code class="language-javascript">function addFive(obj) {
    return obj.method() + 5;
}
</code></pre>
<p>将函数转换为机器指令非常简单，就像从函数返回一样。但是机器不知道对象是什么，比如访问obj的method属性需要怎么翻译呢？</p>
<p>如果知道 obj 是什么样子会很有帮助，但在 JavaScript 中我们永远无法确定。任何对象都可以添加或删除方法属性。即使method确实存在，我们实际上也不能确定它是否是一个函数，更不用说调用它之后的返回值了。</p>
<p>让我们尝试将上述代码转换为没有对象的 JavaScript 子集，来了解转换为机器指令可能是什么样的。</p>
<p>首先，我们需要一种表示对象的方法。我们还需要一种从其中检索值的方法。在机器代码中支持数组是比较的，所以我们可能会使用这样的表示：</p>
<pre><code class="language-javascript">// An object like { method: function() {} }
// could be represented as:
// [ [ &quot;method&quot; ], // property names
//   [ function() {} ] ] // property values

function lookup(obj, name) {
  for (var i = 0; i &lt; obj[0].length; i++) {
    if (obj[0][i] === name) return i;
  }
  return -1;
}
</code></pre>
<p>参考上述的表示，我们可以尝试对 addFive 进行一个简单的实现</p>
<pre><code class="language-javascript">function addFive(obj) {
  var propertyIndex = lookup(obj, &quot;method&quot;);
  var property = propertyIndex &lt; 0 
      ? undefined 
      : obj[1][propertyIndex];

  if (typeof(property) !== &quot;function&quot;) {
      throw NotAFunction(obj, &quot;method&quot;);
  }
  var callResult = property(/* this */ obj);
  return callResult + 5;
}
</code></pre>
<p>当然，这在 obj.method() 返回的不是数字的情况下不能运行，所以我们需要稍微调整一下实现：</p>
<pre><code class="language-javascript">function addFive(obj) {
  var propertyIndex = lookup(obj, &quot;method&quot;);
  var property = propertyIndex &lt; 0 
      ? undefined 
      : obj[1][propertyIndex];

  if (typeof(property) !== &quot;function&quot;) {
      throw NotAFunction(obj, &quot;method&quot;);
  }
  var callResult = property(/* this */ obj);
  if (typeof(callResult) === &quot;string&quot;) {
      return stringConcat(callResult, &quot;5&quot;);
  } else if (typeof(callResult !== &quot;number&quot;) {
      throw NotANumber(callResult);
  }
  
  return callResult + 5;
}
</code></pre>
<p>这是能运行的，但我希望很明显，如果我们能提前知道 obj 的结构是什么，以及方法的类型是什么，那么这段代码可以跳过几个步骤。</p>
<h2 id="隐藏类">隐藏类</h2>
<p>主流的 JavaScript 引擎都以某种方式跟踪对象是什么样的呢？在 Chrome 中，这个概念被称为隐藏类。</p>
<p>让我们从以下代码片段开始：</p>
<pre><code class="language-javascript">var obj = {}; // empty object
obj.x = 1; // shape has now changed to include a `x` property
obj.toString = function() { return &quot;TODO&quot;; }; // shape changes
delete obj.x; // shape changes again
</code></pre>
<p>如果我们将其转换为机器指令，我们将如何在添加和删除新属性时跟踪对象的样子？如果我们使用上一个示例将对象表示为数组的想法，它可能看起来像这样：</p>
<pre><code class="language-javascript">var emptyObj__Class = [ 
  null, // No parent hidden class
  [],   // Property names
  []    // Property types
];

var obj = [ 
  emptyObj__Class, // Hidden class of `obj`
  []               // Property values
];

var obj_X__Class = [ 
  emptyObj__Class, // Contains same properties as empty object
  [&quot;x&quot;],           // As well as one property called `x`
  [&quot;number&quot;]       // Where `x` is a number
];

obj[0] = obj_X__Class; // Shape changes
obj[1].push(1);        // value of `x`

var obj_X_ToString__Class = [
  obj_X__Class, // Contains same properties as previous shape
  [&quot;toString&quot;], // And one property called `toString`
  [&quot;function&quot;]  // Where `toString` is a function
];

obj[0] = obj_X_ToString__Class;             // shape change
obj[1].push(function() { return &quot;TODO&quot;; }); // `toString` value

var obj_ToString__Class = [
  null, // Starting from scratch when deleting `x`
  [&quot;toString&quot;], 
  [&quot;function&quot;] 
];

obj[0] = obj_ToString__Class;
obj[1] = [obj[1][1]];
</code></pre>
<p>如果我们要生成这样的虚拟机指令，我们现在就有了一种方法来跟踪对象在任何给定时间的样子。然而，这本身并不能真正帮助我们。我们需要将这些信息存储在有价值的地方。</p>
<h2 id="内联缓存">内联缓存</h2>
<p>每当 JavaScript 代码对对象执行属性访问时，JavaScript 引擎都会将该对象的隐藏类以及查找结果（属性名称到索引的映射）存储在缓存中。这些缓存被称为内联缓存，它们有两个重要目的：</p>
<ul>
<li>在执行字节码时，如果所涉及的对象具有缓存中的隐藏类，它们会加速属性访问。</li>
<li>在优化期间，它们包含有关访问对象属性时所涉及的对象类型的信息，这有助于优化编译器生成特别适合这些类型的代码。</li>
</ul>
<p>内联缓存对它们存储信息的隐藏类的数量有限制。这可以保留内存，但也确保在缓存中执行查找速度很快。如果从内联缓存中检索索引比从隐藏类中检索索引花费的时间更长，则缓存没有任何用处。</p>
<p>据我所知， Chrome在中，内联缓存最多会跟踪 4 个隐藏类。在此之后，内联缓存将被禁用，信息将存储在全局缓存中。全局缓存的大小也有限制，一旦达到限制，新条目将覆盖旧条目。</p>
<p>为了最好地利用内联缓存并帮助优化编译器，应该尝试编写仅对单一类型的对象执行属性访问的函数。不仅如此，生成的代码的性能将是次优的</p>
<h2 id="内联">内联</h2>
<p>一种单独且重要的优化是内联。简而言之，这种优化用被调用函数的实现代替了函数调用。举个例子：</p>
<pre><code class="language-javascript">function map(fn, list) {
    var newList = [];
    for (var i = 0; i &lt; list.length; i++) {
        newList.push(fn(list[i]));
    }
    
    return newList;
}

function incrementNumbers(list) {
    return map(function(n) { return n + 1; }, list);
}

incrementNumbers([1, 2, 3]); // returns [2, 3, 4]
</code></pre>
<p>内联后，代码最终可能看起来像这样：</p>
<pre><code class="language-javascript">function incrementNumbers(list) {
    var newList = [];
    var fn = function(n) { return n + 1; };
    for (var i = 0; i &lt; list.length; i++) {
        newList.push(fn(list[i]));
    }
    return newList;
}

incrementNumbers([1, 2, 3]); // returns [2, 3, 4]
</code></pre>
<p>这样做的一个好处是删除了函数调用。更大的好处是 JavaScript 引擎现在可以更深入地了解函数的实际作用。基于这个新版本，JavaScript 引擎可能会决定再次执行内联：</p>
<pre><code class="language-javascript">function incrementNumbers(list) {
    var newList = [];
    for (var i = 0; i &lt; list.length; i++) {
        newList.push(list[i] + 1);
    }
	
    return newList;
}

incrementNumbers([1, 2, 3]); // returns [2, 3, 4]
</code></pre>
<p>另一个函数调用已被删除。更重要的是，优化器现在可能会推测 incrementNumbers 只会以数字列表作为参数被调用。它还可能决定内联 incrementNumbers([1, 2, 3]) 调用本身，并发现 list.length 为 3，这又可能导致：</p>
<pre><code class="language-javascript">var list = [1, 2, 3];
var newList = [];
newList.push(list[0] + 1);
newList.push(list[1] + 1);
newList.push(list[2] + 1);
list = newList;
</code></pre>
<p>简而言之，内联可以实现跨函数边界无法执行的优化。</p>
<p>但是，可以内联的内容是有限的。由于代码重复，内联会导致更大的函数，这需要额外的内存。 JavaScript 引擎对一个函数在完全跳过内联之前可以达到的大小有一个预算。</p>
<p>一些函数调用也很难内联。特别是当一个函数作为参数传入时。</p>
<p>此外，作为参数传递的函数很难内联，除非它总是同一个函数。虽然这可能会让您觉得这是一件奇怪的事情，但由于内联，最终可能会出现这种情况。</p>
<h2 id="结论">结论</h2>
<p>JavaScript 引擎有许多提高运行时性能的技巧，比这里介绍的要多得多。但是，本文中描述的优化适用于大多数浏览器，并且很容易验证它们是否被应用。因此，当我们尝试提高 <a href="https://en.wikipedia.org/wiki/Elm">Elm</a> 的运行时性能时，我们将主要关注这些优化。</p>
<h2 id="参考">参考</h2>
<p><a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">What’s up with monomorphism</a><br>
<a href="https://mathiasbynens.be/notes/shapes-ics">Shapes and inline caches</a><br>
<a href="https://mathiasbynens.be/notes/prototypes">Optimizing prototypes</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7 个可能需要的自定义 React Hook]]></title>
        <id>https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook</id>
        <link href="https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook">
        </link>
        <updated>2021-11-29T14:52:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要编制了一份清单，列出了在项目中可能会需要用到的的七个Hooks。<br>
<img src="https://umeimmense.github.io/post-images/1638197755400.jpeg" alt="" loading="lazy"></p>
<h2 id="1-usetoggle">1. useToggle</h2>
<p>这个hook很常见，它用于在 true 和 false 之间切换布尔值。当我们想要显示/隐藏模式或打开/关闭侧边菜单时，它很有用。这个hook的基本版本如下所示：</p>
<h3 id="实现v1">实现v1</h3>
<pre><code class="language-jsx">// useToggle.jsx
import { useState, useCallback } from 'react';

const useToggle = (initialValue = false) =&gt; {
  const [state, setState] = useState(initialValue);
  
  const toggle = useCallback(() =&gt; {
    setState((state) =&gt; !state);
  }, []);
  
  return [state, toggle];
};

export default useToggle;
</code></pre>
<h3 id="案例1">案例1</h3>
<pre><code class="language-jsx">import useToggle from './useToggle';
const App = () =&gt; {
  const [show, toggleShow] = useToggle();
  return (
    &lt;Modal show={show} onClose={toggleShow}&gt;
      &lt;h1&gt;Hello there&lt;/h1&gt;
    &lt;/Modal&gt;
  );
}
</code></pre>
<p>当我们想要显示/隐藏表中一行的模式时，可以稍微修改此hook以用于用例。我添加了一个 customToggle 方法，该方法将值设置为给定值，而不是切换先前的状态值。</p>
<h3 id="实现v2">实现v2</h3>
<pre><code class="language-jsx">// useToggle.jsx modified

import { useState, useCallback } from 'react';

const useToggle = (initialValue = false) =&gt; {
  const [state, setState] = useState(initialValue);

  const toggle = useCallback(() =&gt; {
    setState((state) =&gt; !state);
  }, []);

  const customToggle = useCallback((value) =&gt; {
    setState(value);
  }, []);

  return [state, toggle, customToggle];
};

export default useToggle;
</code></pre>
<h3 id="案例2">案例2</h3>
<p>假设我们在一个表格中有一堆行，我们想提供一个删除行的选项。单击删除按钮应打开一个确认模式。<br>
对于这种类型的功能，我们需要状态中的两个变量。首先，保存一个布尔值来确定是否显示删除确认模式，其次保存必须显示删除模式的行 ID。<br>
使用这个hook，我们可以用一个状态变量来完成。这是如何做到的：</p>
<pre><code class="language-jsx">import useToggle from './useToggle';

// initial data
const rows = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Doe' }
];

const App = () =&gt; {
  // using hook
  const [delModal, toggleDelModal, setDelModalCustom] = useToggle();

  return (
    &lt;div&gt;
      &lt;table&gt;
        {rows.map(row =&gt; (
          &lt;tr&gt;
            &lt;td&gt;{row.id}&lt;/td&gt;
            &lt;td&gt;{row.name}&lt;/td&gt;
            &lt;td onClick={() =&gt; setDelModalCustom(row.id)}&gt;Delete&lt;/td&gt;
          &lt;/tr&gt;
        ))}
      &lt;/table&gt;

      &lt;DeleteModal
        show={Boolean(delModal)}
        onClose={toggleDelModal}
        itemToDelete={delModal} // it will hold the current row id
      &gt;
        &lt;h1&gt;
          Are you sure you want to delete row with id {delModal}
        &lt;/h1&gt;
      &lt;/DeleteModal&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="2-usepagebottom">2. usePageBottom</h2>
<p>使用此hook，您可以确定用户是否已滚动到页面底部。非常适合无限滚动的应用程序，当用户滚动到页面底部时，您需要获取更多数据。</p>
<pre><code class="language-jsx">// usePageBottom.jsx

import { useState, useEffect } from 'react';

const usePageBottom = () =&gt; {
  const [reachedBottom, setReachedBottom] = useState(false);
  
  // event handler for determining if the user reached bottom
  const handleScroll = () =&gt; {
    const offsetHeight = document.documentElement.offsetHeight;
    const innerHeight = window.innerHeight;
    const scrollTop = document.documentElement.scrollTop;

    // if current scroll from bottom is less than equal to 10px
    const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10;

    setReachedBottom(reachingBottom);
  };

  // effect for binding event listener on window scroll
  useEffect(() =&gt; {
    window.addEventListener('scroll', handleScroll);
    
    return () =&gt; {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);
  
  return reachedBottom;
}
</code></pre>
<h3 id="案例">案例</h3>
<pre><code class="language-jsx">import usePageBottom from './usePageBottom';
const App = (props) =&gt; {
  // hook usage
  const scrolledBottom = usePageBottom();
  return (
    &lt;div className=&quot;App&quot; style={{ height: '150vh' }}&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
      &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="节流版本可选">节流版本（可选）</h3>
<p>减少像窗口滚动事件这样多次触发的事件的通知是最佳实践，我们可以使用节流设置事件侦听器。我正在使用 <code>lodash</code> 的<code>throttle</code>；你也可以使用去<code>debounce</code>。</p>
<pre><code class="language-jsx">// usePageBottom with throttle

import { useState, useEffect, useMemo } from 'react';
import { throttle } from 'lodash';

const usePageBottom = () =&gt; {
  const [reachedBottom, setReachedBottom] = useState(false);
  
  // event handler for determining if the user reached bottom
 const handleScroll = useMemo(() =&gt; {
    return throttle(() =&gt; {
      const offsetHeight = document.documentElement.offsetHeight;
      const innerHeight = window.innerHeight;
      const scrollTop = document.documentElement.scrollTop;

      // if current scroll from bottom is less than equal to 10px
      const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10;
      
      setReachedBottom(reachingBottom);
    }, 1000);
  }, []);

  // effect for binding event listener on window scroll
  useEffect(() =&gt; {
    window.addEventListener('scroll', handleScroll);
    
    return () =&gt; {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);
  
  return reachedBottom;
}
</code></pre>
<h2 id="3-useelementbottom">3. useElementBottom</h2>
<p>就像页面底部一样，我们也可以确定用户是否已经滚动到元素的底部。在这个hook中，传递了对元素的引用，因此我们可以使用元素的高度和当前滚动位置来确定元素是否滚动到底部。</p>
<pre><code class="language-jsx">// useElementBottom.jsx

import { useState, useEffect, useMemo } from 'react';
import { throttle } from 'lodash';

const useElementBottom = (element) =&gt; {
  const [reachedBottom, setReachedBottom] = useState(false);

  // event handler for determining if the user reached bottom
  const handleScroll = useMemo(() =&gt; {
    return throttle(() =&gt; {
      const { current } = element; // current holds the reference to element

      // if current scroll from bottom is less than equal to 10px
      const scrollBottom =
        current.scrollHeight - current.scrollTop - current.clientHeight;

      const reachingBottom = scrollBottom &lt;= 10;
      setReachedBottom(reachingBottom);
    }, 1000);
  }, []);

  // effect for binding event listener on element scroll
  useEffect(() =&gt; {
    const { current } = element;
    current.addEventListener('scroll', handleScroll);

    return () =&gt; current.removeEventListener('scroll', handleScroll);
  }, []);

  return reachedBottom;
};

export default useElementBottom;
</code></pre>
<h3 id="案例-2">案例</h3>
<pre><code class="language-jsx">import useElementBottom from './useElementBottom';
const App = (props) =&gt; {
  const element = useRef();
  // hook usage
  const scrolledBottom = useElementBottom(element);
  return (
    &lt;div ref={element} style={{ height: '150vh' }}&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
      &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="4-useprevious">4. usePrevious</h2>
<p>我们可以制作一个自定义hook来获取 prop 或 state 的先前值。使用 React 类组件，可以使用 componentDidUpdate 生命周期来获取之前的 prop 和 state 值。对于功能组件，我们可以使用自定义hook来完成，如下所示：</p>
<pre><code class="language-jsx">// usePrevious.jsx

import { useEffect, useRef } from 'react';

const usePrevious = (value) =&gt; {
  const ref = useRef();

  // store current value in ref
  useEffect(() =&gt; {
    ref.current = value;
  }, [value]);

  // return previous value (happens before update in useEffect above)
  return ref.current;
};

export default usePrevious;
</code></pre>
<p>我们使用 useRef hook来存储先前的值。我们的hook在 useEffect 中更新引用对象之前返回先前的值。</p>
<pre><code class="language-jsx">import usePrevious from './usePrevious';

const App = () =&gt; {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="5-usewindowsize">5. useWindowSize</h2>
<p>这个hook返回窗口的宽度和高度。我们在调整窗口大小时设置了一个受限制的 set 事件侦听器，以便我们每次都能获得正确的宽度和高度。</p>
<pre><code class="language-jsx">// useWindowSize

import { useState, useEffect, useCallback } from 'react';
import { throttle } from 'throttle';

const useWindowSize = () =&gt; {
  const [size, setSize] = useState({
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight,
  });

  // throttled set listener that runs on window resize
  const throttledSetResizeListner = useCallback(
    throttle(() =&gt; {
      // set size in state
      setSize({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight,
      });
    }, 1000),
    []
  );

  // effect for binding resize event on window
  useEffect(() =&gt; {
    // add throtelled set window resize event listener
    window.addEventListener('resize', throttledSetResizeListner);

    // remove throttled set window resize event listener
    return () =&gt;
      window.removeEventListener('resize', throttledSetResizeListner);
  }, [throttledSetResizeListner]);

  return size;
};

export default useWindowSize;
</code></pre>
<h3 id="案例-3">案例</h3>
<p>当你想根据窗口的宽度或高度在你的 JS 代码中做一些事情时，它很有用。</p>
<pre><code class="language-jsx">import useWindowSize from './useWindowSize';
const App = () =&gt; {
  const { innerWidth, innerHeight } = useWindowSize();
  return (
    &lt;div&gt;
      {innerWidth &lt;= 768 ?
        'I am on small screen' : 'I am on large screen'}
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="6-useeventlistener">6. useEventListener</h2>
<p>使用此hook可以轻松地将事件侦听器绑定到窗口或窗口元素。在hook的effect中，我们检查元素是否是来自 useRef 的引用。如果没有，我们将事件侦听器添加到全局窗口对象。</p>
<pre><code class="language-jsx">import { useEffect } from 'react';

const useEventListener = (event, handler, referencedElement) =&gt; {
  // effect for binding event handler to the element
  useEffect(() =&gt; {
    const element = referencedElement?.current || window;

    const isSupported = element &amp;&amp; element.addEventListener;

    if (!isSupported) return;

    // bind event to the element
    element.addEventListener(event, handler);

    return () =&gt; element.removeEventListener(event, handler);
  }, [referencedElement, event, handler]);

  return;
};

export default useEventListener;
</code></pre>
<pre><code class="language-jsx">import useEventListener from './useEventListener';

const App = (props) =&gt; {
  const element = useRef();
  useEventListener('mouseover', handler, element);
  const handler =&gt; () =&gt; {
    console.log('Event triggered');
  }
  return (
    &lt;div ref={element}&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
    &lt;div&gt;
  );
}
</code></pre>
<p>我们还可以使用相同的hook将事件添加到窗口</p>
<pre><code class="language-jsx">import useEventListener from './useEventListener';
const App = (props) =&gt; {
  // adding event listener on window scroll
  useEventListener('scroll', handler);
  const handler =&gt; () =&gt; {
    console.log('Event triggered');
  }
  return (
    &lt;div&gt;
      &lt;h1&gt;This is app&lt;/h1&gt;
    &lt;div&gt;
  );
}
</code></pre>
<h2 id="7-uselocalstoragestate">7. useLocalStorageState</h2>
<p>有时，可能需要在本地存储和状态之间同步一个值。这个hook的作用完全一样。我们正在使用 useState 并检查指定的键是否在本地存储中具有某个值，以便我们可以将其用作初始值。这允许我们在页面刷新时保持值与状态同步。</p>
<pre><code class="language-jsx">// useLocalStorageState

import { useState, useEffect } from 'react';

const useLocalStorageState = (key, defaultValue) =&gt; {
  const [value, setValue] = useState(() =&gt; {
    let val;

    try {
      // if there is a value in local storage for given key, set it as initial state
      val = JSON.parse(localStorage.getItem(key) || String(defaultValue));
    } catch (error) {
      // otherwise, set default value as initial state
      val = defaultValue;
    }

    return val;
  });

  // effect to update local storage when state changes
  useEffect(() =&gt; {
    localStorage.setItem(key, JSON.stringify(value));
  }, [value]);

  return [value, setValue];
};

export default useLocalStorageState;
</code></pre>
<p>当值更新时，会运行一个effect ，更新本地存储中的值。</p>
<h3 id="案例-4">案例</h3>
<p>假设你想在本地存储中存储用户主题首选项</p>
<pre><code class="language-jsx">import useLocalStorageState from './useLocalStorageState';
const App = (props) =&gt; {
  // setting default theme to light
  const [theme, setTheme] = useLocalStorageState('theme', 'light');
  return (
    &lt;div&gt;
      &lt;p&gt;Current theme is {theme}&lt;/p&gt;
      &lt;button onClick={() =&gt; setTheme('dark')}&gt;
        Change theme to dark
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>当你点击更改主题按钮时，状态和本地存储中的值都会更新。页面刷新后，你将获得存储在本地存储中的最后一个值。</p>
<h2 id="结语">结语</h2>
<p>感谢你阅读到最后。我希望这些自定义hook对你有用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10个常用的JavaScript使用技巧]]></title>
        <id>https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao</id>
        <link href="https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao">
        </link>
        <updated>2021-11-23T07:48:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>编写简短、简洁和干净的 JavaScript 代码的技巧😎<br>
<img src="https://umeimmense.github.io/post-images/1638169801723.png" alt="" loading="lazy"><br>
JavaScript 有很多很酷的特性，大多数初学者和中级开发人员都不知道。我挑选了 10 个我在日常 JavaScript 项目中使用的技巧。</p>
<h2 id="1-有条件的向对象中添加属性">1. 有条件的向对象中添加属性</h2>
<p>我们可以使用扩展运算符 <code>...</code> 来有条件地向 JavaScript 对象快速添加属性。</p>
<pre><code class="language-javascript">const condition = true;
const person = {
  id: 1,
  name: 'John Doe',
  ...(condition &amp;&amp; { age: 16 }),
};
</code></pre>
<p>如果每个操作数的计算结果都为true， &amp;&amp; 运算符将返回最后计算的表达式。因此返回一个对象 { age: 16 }，然后将其作为 person 对象的一部分。</p>
<p>如果条件为 false，则 JavaScript 将执行以下操作：</p>
<pre><code class="language-javascript">const person = {
  id: 1,
  name: 'John Doe',
  ...(false), // evaluates to false
};
// spreading false has no effect on the object
console.log(person); // { id: 1, name: 'John Doe' }
</code></pre>
<h2 id="2-检查一个属性是否存在于一个对象中">2. 检查一个属性是否存在于一个对象中</h2>
<p>我们可以使用<code>in</code>关键字来检查 JavaScript 对象中是否存在属性</p>
<pre><code class="language-javascript">const person = { name: 'John Doe', salary: 1000 };
console.log('salary' in person); // returns true
console.log('age' in person); // returns false
</code></pre>
<h2 id="3-对象中的动态属性名称">3. 对象中的动态属性名称</h2>
<p>使用动态键设置对象属性很简单。只需使用 ['key_name'] 符号添加属性</p>
<pre><code class="language-javascript">const dynamic = 'flavour';
var item = {
  name: 'Biscuit',
  [dynamic]: 'Chocolate'
}
console.log(item); // { name: 'Biscuit', flavour: 'Chocolate' }
</code></pre>
<p>同样的技巧也可用于使用动态键引用对象属性：</p>
<pre><code class="language-javascript">const keyName = 'name';
console.log(item[keyName]); // returns 'Biscuit'
</code></pre>
<h2 id="4-使用动态键进行对象解构">4. 使用动态键进行对象解构</h2>
<p>你可能知道你可以解构一个变量并立即用 : 符号重命名它。但是你知道当你不知道键名或键名是动态的时，你也可以解构对象的属性吗？<br>
首先，让我们看看如何在解构（用别名解构）时重命名变量。</p>
<pre><code class="language-javascript">const person = { id: 1, name: 'John Doe' };
const { name: personName } = person;
console.log(personName); // returns 'John Doe'
</code></pre>
<p>现在，让我们使用动态键来解构属性：</p>
<pre><code class="language-javascript">const templates = {
  'hello': 'Hello there',
  'bye': 'Good bye'
};
const templateName = 'bye';
const { [templateName]: template } = templates;
console.log(template) // returns 'Good bye'
</code></pre>
<h2 id="5-运算符">5. ?? 运算符</h2>
<p>这 <code>??</code>当你要检查变量是 null 还是 undefined 时，运算符很有用。当其左侧操作数为空或未定义时，它返回右侧操作数，否则返回其左侧操作数。</p>
<pre><code class="language-javascript">const foo = null ?? 'Hello';
console.log(foo); // returns 'Hello'
const bar = 'Not null' ?? 'Hello';
console.log(bar); // returns 'Not null'
const baz = 0 ?? 'Hello';
console.log(baz); // returns 0
</code></pre>
<p>在第三个示例中，返回 0 是因为即使 0 在 JavaScript 中被认为是假的，但它不是 null 或未定义的。你可能认为我们可以使用 ||运算符在这里，但这两者之间存在差异：</p>
<pre><code class="language-javascript">const cannotBeZero = 0 || 5;
console.log(cannotBeZero); // returns 5
const canBeZero = 0 ?? 5;
console.log(canBeZero); // returns 0
</code></pre>
<h2 id="6-可选链">6. ?. 可选链</h2>
<p>我们都可能曾经遇到过TypeError：无法读取 null 的属性“foo”之类的错误。这对每个 JavaSript 开发人员来说都是头疼的问题。引入了可选链就是为了解决这个问题。让我们来看看：</p>
<pre><code class="language-javascript">const book = { id:1, title: 'Title', author: null };
// normally, you would do this
console.log(book.author.age) // throws error
console.log(book.author &amp;&amp; book.author.age); // returns null (no error)
// with optional chaining
console.log(book.author?.age); // returns undefined
// or deep optional chaining
console.log(book.author?.address?.city); // returns undefined
</code></pre>
<p>你还可以使用具有以下功能的可选链：</p>
<pre><code class="language-javascript">const person = {
  firstName: 'Haseeb',
  lastName: 'Anwar',
  printName: function () {
    return `${this.firstName} ${this.lastName}`;
  },
};
console.log(person.printName()); // returns 'Haseeb Anwar'
console.log(persone.doesNotExist?.()); // returns undefined
</code></pre>
<h2 id="7-使用-的布尔转换符">7. 使用 !! 的布尔转换符</h2>
<p>这 <code>!!</code>运算符可用于将表达式的结果快速转换为布尔值 <code>true</code> 或 <code>false</code>。就是这样：</p>
<pre><code class="language-javascript">const greeting = 'Hello there!';
console.log(!!greeting) // returns true
const noGreeting = '';
console.log(!!noGreeting); // returns false
</code></pre>
<h2 id="8-字符串和整数转换">8. 字符串和整数转换</h2>
<p>使用 + 运算符快速将字符串转换为数字，如下所示：</p>
<pre><code class="language-javascript">const stringNumer = '123';
console.log(+stringNumer); // returns integer 123
console.log(typeof +stringNumer); // returns 'number'
</code></pre>
<p>要将数字快速转换为字符串，请使用 + 运算符后跟空字符串 &quot;&quot;：</p>
<pre><code class="language-javascript">const myString = 25 + '';
console.log(myString); // returns '25'
console.log(typeof myString); // returns 'string'
</code></pre>
<p>这些类型转换非常方便，但它们的清晰度和代码可读性较差。因此，在生产中使用它们之前，你可能需要考虑一下。不过可以用才<code>code golf</code>中。</p>
<h2 id="9-检查数组中的假值">9. 检查数组中的假值</h2>
<p>你熟悉 filter、some 和 every 数组方法。但你也应该知道，你可以仅使用布尔方法来测试真值：</p>
<pre><code class="language-javascript">const myArray = [null, false, 'Hello', undefined, 0];
// filter falsy values
const filtered = myArray.filter(Boolean);
console.log(filtered); // returns ['Hello']
// check if at least one value is truthy
const anyTruthy = myArray.some(Boolean);
console.log(anyTruthy); // returns true
// check if all values are truthy
const allTruthy = myArray.every(Boolean);
console.log(allTruthy); // returns false
</code></pre>
<p>这是它的工作原理。众所周知，这些数组方法采用回调函数，因此我们将布尔值作为回调函数传递。 <code>Boolean</code> 本身接受一个参数并根据参数的真实性返回<code>true</code>或 <code>false</code>。所以我们可以这样说：</p>
<pre><code class="language-javascript">myArray.filter(val =&gt; Boolean(val));
</code></pre>
<p>是不是和这个一样：</p>
<pre><code class="language-javascript">myArray.filter(Boolean);
</code></pre>
<h2 id="10展平数组">10.展平数组</h2>
<p>原型 Array 上有一个方法 flat 可以让你从数组的数组中创建一个数组：</p>
<pre><code class="language-javascript">const myArray = [{ id: 1 }, [{ id: 2 }], [{ id: 3 }]];
const flattedArray = myArray.flat(); 
// returns [ { id: 1 }, { id: 2 }, { id: 3 } 
</code></pre>
<p>你还可以定义一个深度级别，指定嵌套数组结构应展平的深度。例如：</p>
<pre><code class="language-javascirpt">const arr = [0, 1, 2, [[[3, 4]]]];
console.log(arr.flat(2)); // returns [0, 1, 2, [3,4]]
</code></pre>
<h2 id="结语">结语</h2>
<p>感谢你阅读到最后。我希望这些技巧对你有用。</p>
]]></content>
    </entry>
</feed>