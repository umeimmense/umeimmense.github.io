<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2022-04-17T06:27:25.968Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Sort]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort">
        </link>
        <updated>2022-04-17T06:01:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table Library 及其 useSort 插件来实现排序功能。在前面的例子中，你已经安装了 React Table Library 来创建一个 Table 组件。现在，我们将允许用户通过单击列标题对Table中的列进行排序。</p>
<h2 id="实现">实现</h2>
<p>首先，导入 useSort Hook：</p>
<pre><code class="language-jsx">import { useSort } from '@table-library/react-table-library/sort';
</code></pre>
<p>其次，使用Table的数据对其进行初始化，并将其作为 prop 传递给 Table 组件：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data);

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>之后，将你的标题列转换为可排序的：</p>
<pre><code class="language-jsx">import {
  useSort,
  HeaderCellSort ,
} from '@table-library/react-table-library/sort';

const App = () =&gt; {
  ...

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCellSort sortKey=&quot;TASK&quot;&gt;
                Task
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;DEADLINE&quot;&gt;
                Deadline
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;TYPE&quot;&gt;
                Type
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;COMPLETE&quot;&gt;
                Complete
              &lt;/HeaderCellSort&gt;
            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>然后为每个排序键创建各自的排序函数：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data, null, {
    sortFns: {
      TASK: (array) =&gt;
        array.sort((a, b) =&gt; a.name.localeCompare(b.name)),
      DEADLINE: (array) =&gt;
        array.sort((a, b) =&gt; a.deadline - b.deadline),
      TYPE: (array) =&gt;
        array.sort((a, b) =&gt; a.type.localeCompare(b.type)),
      COMPLETE: (array) =&gt;
        array.sort((a, b) =&gt; a.isComplete - b.isComplete),
    },
  });

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>只需几行，你就有一个可排序的Table。我们可以按字符串排序（按字母顺序）、按日期排序、按布尔值排序和按枚举排序。由于自己传递了 sortBy 函数，因此如何对列进行排序取决于sortBy 函数。</p>
<p>可能缺少的获取当前排序的onChange事件。让我们看看它是如何与 useSort 结合使用的：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data,
    {
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  function onSortChange(action, state) {
    console.log(action, state);
  }

  ...
};
</code></pre>
<p>onChange 回调函数使你可以访问触发排序更改的操作以及Table的实际排序状态。通过访问此信息，你可以基于它触发更多的Table或非Table事件（例如，服务器端排序等副作用）。</p>
<p>最后，值得注意的是，你传递给Table的排序对象包含排序状态——这使你能够随时访问它——以及以编程方式对列进行排序的所有函数。当在这个 React Table中使用自定义排序组件时，我们稍后会详细看到这一点。<br>
无论如何，表中的列排序通常会带来更多要求。让我们来看看其中的两个：</p>
<p>例如，有时用户想要具有初始排序状态。这也可以通过 useSort 来实现，方法是传入一个默认的排序状态：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const sort = useSort(data,
    {
      state: {
        sortKey: 'TASK',
        reverse: false,
      },
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  ...
};
</code></pre>
<p>另一个案例是将排序图标与来自第三方库（例如 Material UI）的自定义排序图标交换：</p>
<pre><code class="language-jsx">import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';

const App = () =&gt; {
  ...

  const sort = useSort(
    data,
    {
      onChange: onSortChange,
    },
    {
      sortIcon: {
        margin: '0px',
        iconDefault: &lt;UnfoldMoreOutlinedIcon /&gt;,
        iconUp: &lt;KeyboardArrowUpOutlinedIcon /&gt;,
        iconDown: (
          &lt;KeyboardArrowDownOutlinedIcon /&gt;
        ),
      },
      sortFns: ...
    }
  );

  ...
};
</code></pre>
<p>排序功能还有更多选项。只需前往 <a href="https://react-table-library.com/?path=/docs/features-sort--base">React Table 文档</a>以了解有关它们的更多信息。</p>
<p>最后，使用 React Table Library 可以完全用自定义组件交换排序组件。对于我们的表格排序插件，我们可能希望将排序标题组件与我们自己的来自第三方库的 HTML 按钮进行交换。下面，你将看到一个如何在 React 表库中使用 Material UI 组件的示例。</p>
<p>首先，从你的第三方库中导入自定义组件（和自定义图标）：</p>
<pre><code class="language-jsx">import MaterialButton from '@mui/material/Button';
import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';
</code></pre>
<p>其次Table Header 使用第三方按钮：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const getIcon = (sortKey) =&gt; {
    if (sort.state.sortKey === sortKey &amp;&amp; sort.state.reverse) {
      return &lt;KeyboardArrowDownOutlinedIcon /&gt;;
    }

    if (sort.state.sortKey === sortKey &amp;&amp; !sort.state.reverse) {
      return &lt;KeyboardArrowUpOutlinedIcon /&gt;;
    }

    return &lt;UnfoldMoreOutlinedIcon /&gt;;
  };

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCell&gt;
                &lt;MaterialButton
                  fullWidth
                  style={{ justifyContent: 'flex-start' }}
                  endIcon={getIcon('TASK')}
                  onClick={() =&gt;
                    sort.fns.onToggleSort({
                      sortKey: 'TASK',
                    })
                  }
                &gt;
                  Task
                &lt;/MaterialButton&gt;
              &lt;/HeaderCell&gt;

              ...

            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};

</code></pre>
<p>请注意 useSort 中的排序对象如何为你提供创建自定义组件所需的一切。这样，你可以为每个表格列自定义排序组件。通过使用排序状态和所有排序功能，你可以从任何地方读取和写入排序状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Resize]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize">
        </link>
        <updated>2022-04-17T05:41:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本教程中，我想向你展示如何使用 React Table Library 及其调整大小功能。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户调整表中列的大小。</p>
<h2 id="实现">实现</h2>
<p>首先在Table的列上设置 resize 属性</p>
<pre><code class="language-jsx">&lt;Header&gt;
  &lt;HeaderRow&gt;
    &lt;HeaderCell resize&gt;Task&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Deadline&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Type&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Complete&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Tasks&lt;/HeaderCell&gt;
  &lt;/HeaderRow&gt;
&lt;/Header&gt;
</code></pre>
<p>这是为Table启用可调整大小的列的最直接的方法。但是，如果你想有更多的配置选项，你可以传递一个对象。<br>
例如，如果使用默认值，你可以为每个表格列定义最小宽度。</p>
<pre><code class="language-jsx">&lt;HeaderCell resize={{ minWidth: 50 }}&gt;Task&lt;/HeaderCell&gt;
</code></pre>
<p>你还可以调整大小区域的突出显示颜色并扩大调整区域的大小：</p>
<pre><code class="language-jsx">&lt;HeaderCell
  resize={{
    resizerWidth: 15,
    resizerHighlight: '#98d8ff',
  }}
&gt;
  Task
&lt;/HeaderCell&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 React Table 实现 Fixed Column]]></title>
        <id>https://umeimmense.github.io/post/ru-he-react-table-shi-xian-gu-ding-lie</id>
        <link href="https://umeimmense.github.io/post/ru-he-react-table-shi-xian-gu-ding-lie">
        </link>
        <updated>2022-04-17T05:25:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中中，我想向你展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的列粘在一边：</p>
<h2 id="实现">实现</h2>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme({
    BaseCell: `
      &amp;:nth-of-type(1) {
        left: 0px;

        min-width: 250px;
        width: 250px;
      }

      &amp;:nth-of-type(2) {
        left: 250px;

        min-width: 150px;
        width: 150px;
      }

      &amp;:nth-of-type(3),
      &amp;:nth-of-type(4) {
        min-width: 50%;
        width: 50%;
      }
    `,
  });

  return (...);
};
</code></pre>
<p>我们将列固定在左侧。你也可以以相同的方式将列固定到右侧。缺少的是给 Cell 组件一个 <code>pinLeft</code>（或 <code>pinRight</code>）Props来指示它们固定到一边：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  return (
    &lt;Table data={data} theme={theme} layout={{ custom: true, horizontalScroll: true }}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCell pinLeft&gt;Task&lt;/HeaderCell&gt;
              &lt;HeaderCell pinLeft&gt;Deadline&lt;/HeaderCell&gt;
              &lt;HeaderCell&gt;Type&lt;/HeaderCell&gt;
              &lt;HeaderCell&gt;Complete&lt;/HeaderCell&gt;
            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            {tableList.map((item) =&gt; (
              &lt;Row key={item.id} item={item}&gt;
                &lt;Cell pinLeft&gt;{item.name}&lt;/Cell&gt;
                &lt;Cell pinLeft&gt;
                  {item.deadline.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                  })}
                &lt;/Cell&gt;
                &lt;Cell&gt;{item.type}&lt;/Cell&gt;
                &lt;Cell&gt;{item.isComplete.toString()}&lt;/Cell&gt;
              &lt;/Row&gt;
            ))}
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>一切就绪后，表格的非固定列将沿垂直方向滚动，而该列在表格的一侧保持固定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 React Table 实现 Fixed Header]]></title>
        <id>https://umeimmense.github.io/post/ru-he-reacttable-shi-xian-gu-ding-biao-ti</id>
        <link href="https://umeimmense.github.io/post/ru-he-reacttable-shi-xian-gu-ding-biao-ti">
        </link>
        <updated>2022-04-15T19:05:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中中，我想向您展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的标题粘贴到顶部：</p>
<h2 id="实现">实现</h2>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme({
    Table: `
      height: 100%;
    `,
  });

  return (
    &lt;div
      style={{
        height: '150px',
      }}
    &gt;
      &lt;Table data={data} theme={theme}&gt;
        ...
      &lt;/Table&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>固定Table标题所需的一切都是Table组件周围的容器组件。这样，Table的行将在垂直方向滚动，而标题保持在Table的顶部。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 使用 Theme]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-shi-yong-zhu-ti</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-shi-yong-zhu-ti">
        </link>
        <updated>2022-04-15T13:39:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table Library 及其 useTheme 插件来使用自定义样式对你的表格进行主题化。在前面的例子中，你已经安装了 React Table Library 来创建一个Table 组件。</p>
<h2 id="实现">实现</h2>
<p>首先，导入 useTheme Hook：</p>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';
</code></pre>
<p>其次，用它创建一个主题并将其作为Props传递给 Table 组件：</p>
<pre><code class="language-jsx">const THEME = {};

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme(THEME);

  return (
    &lt;Table data={data} theme={theme}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>只需几行，你就为表格创建了一个自定义主题。但是，主题是空的，接下来让我们看看如何使用它来调整表格的样式：</p>
<pre><code class="language-jsx">const THEME = {
  HeaderRow: `
    font-size: 14px;

    background-color: #eaf5fd;
  `,
  Row: `
    font-size: 14px;

    &amp;:nth-child(odd) {
      background-color: #d2e9fb;
    }

    &amp;:nth-child(even) {
      background-color: #eaf5fd;
    }
  `,
};
</code></pre>
<p>本质上，主题是一本字典，你可以在其中设置表格的不同组件的样式。在最后一个示例中，我们设置了标题行和行组件的样式。由于两个组件共享一些相同的样式，你也可以将此样式提取为一个共同点：</p>
<pre><code class="language-jsx">const THEME = {
  BaseRow: `
    font-size: 14px;
  `,
  HeaderRow: `
    background-color: #eaf5fd;
  `,
  Row: `
    &amp;:nth-child(odd) {
      background-color: #d2e9fb;
    }

    &amp;:nth-child(even) {
      background-color: #eaf5fd;
    }
  `,
};
</code></pre>
<p>以下组件可用作样式键：Table、HeaderRow、Row、HeaderCell、Cell、BaseRow、BaseCell。最后，这应该为你提供所有入口点，以便为表格设置所有不同组件的样式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何创建 React Table 组件]]></title>
        <id>https://umeimmense.github.io/post/ru-he-chuang-jian-react-table-zu-jian</id>
        <link href="https://umeimmense.github.io/post/ru-he-chuang-jian-react-table-zu-jian">
        </link>
        <updated>2022-04-15T12:39:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table​​库在 React 中创建Table组件。在本节之后，你可以使用库的文档继续构建许多其他示例，例如搜索、过滤、排序、选择、嵌套树表或 React 表的分页功能。但让我们从基础开始。</p>
<h2 id="实现">实现</h2>
<p>让我们从通过命令行安装 React Table Library ：</p>
<pre><code class="language-shell">npm install @table-library/react-table-library @emotion/react
</code></pre>
<p>任务是在 React Table​​组件中显示以下项列表：</p>
<pre><code class="language-js">const list = [
  {
    id: '1',
    name: 'VSCode',
    deadline: new Date(2022, 1, 17),
    type: 'SETUP',
    isComplete: true,
  },
  {
    id: '2',
    name: 'JavaScript',
    deadline: new Date(2022, 2, 28),
    type: 'LEARN',
    isComplete: true,
  },
  {
    id: '3',
    name: 'React',
    deadline: new Date(2022, 3, 8),
    type: 'LEARN',
    isComplete: false,
  }
];
</code></pre>
<p>我们将从在 Table 组件可以使用的对象中构建列表开始。组件本身从库中导入：</p>
<pre><code class="language-jsx">import * as React from 'react';
import { Table } from '@table-library/react-table-library/table';

const list = [ ... ];

const App = () =&gt; {
  const data = { nodes: list };

  return &lt;Table data={data}&gt;{(tableList) =&gt; null}&lt;/Table&gt;;
};
</code></pre>
<p>Table 组件接受一个数据对象作为带有节点属性的Props。这些节点是我们列表中的项，但是，该表使其对节点的命名更加通用，因为该表不仅可以显示列表结构，还可以显示树结构。</p>
<p>此外，Table 组件使用一个子函数作为子函数，它使我们能够以 tableList 的形式访问表中的列表。在内部，表格组件将各种修改应用于我们的列表——例如排序、分页等，如果启用了这些插件 - 因此应该使用 tableList（而不是数据或列表）来呈现表中的项。</p>
<p>React Table 库使用组合而不是配置。因此，你可以从库本身获得所有必要的构建块作为组件。让我们从表格的标题开始：</p>
<pre><code class="language-jsx">import * as React from 'react';
import {
  Table,
  Header,
  HeaderRow,
  HeaderCell,
} from '@table-library/react-table-library/table';

const list = [ ... ];

const App = () =&gt; {
  const data = { nodes: list };

  return (
    &lt;Table data={data}&gt;
      {(tableList) =&gt; (
        &lt;Header&gt;
          &lt;HeaderRow&gt;
            &lt;HeaderCell&gt;Task&lt;/HeaderCell&gt;
            &lt;HeaderCell&gt;Deadline&lt;/HeaderCell&gt;
            &lt;HeaderCell&gt;Type&lt;/HeaderCell&gt;
            &lt;HeaderCell&gt;Complete&lt;/HeaderCell&gt;
          &lt;/HeaderRow&gt;
        &lt;/Header&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>通过使用这些组件，你可以将表创建为组件的组合，而每个组件都有自己的职责。例如，我们不是只有一个 Table 组件可以接受一个大型配置对象，而是有可组合的组件——例如 Header、HeaderRow 和 HeaderCell，它们可以接收专用的 props。</p>
<p>接下来，让我们像在 React 中渲染列表时所习惯的那样显示我们的项，方法是渲染 Row 组件，并为 Body 组件中的每个项提供一个键：</p>
<pre><code class="language-jsx">import * as React from 'react';
import {
  Table,
  Header,
  HeaderRow,
  HeaderCell,
  Body,
  Row,
  Cell,
} from '@table-library/react-table-library/table';

const list = [ ... ];

const App = () =&gt; {
  const data = { nodes: list };

  return (
    &lt;Table data={data}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            ...
          &lt;/Header&gt;

          &lt;Body&gt;
            {tableList.map((item) =&gt; (
              &lt;Row key={item.id} item={item}&gt;
                &lt;Cell&gt;{item.name}&lt;/Cell&gt;
                &lt;Cell&gt;
                  {item.deadline.toLocaleDateString(
                    'en-US',
                    {
                      year: 'numeric',
                      month: '2-digit',
                      day: '2-digit',
                    }
                  )}
                &lt;/Cell&gt;
                &lt;Cell&gt;{item.type}&lt;/Cell&gt;
                &lt;Cell&gt;{item.isComplete.toString()}&lt;/Cell&gt;
              &lt;/Row&gt;
            ))}
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>由于你可以完全控制在 Cell 组件中呈现的内容，因此你可以根据需要格式化数据。布尔值可以转换为字符串，日期可以格式化为可读版本。 Cell 组件没有特殊的props来完成渲染。使用 React 表格​​库可以直接在 React 中呈现表格组件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook：获取滚动条宽度]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-tiao-kuan-du</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-tiao-kuan-du">
        </link>
        <updated>2022-04-14T08:02:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本节实现一个简洁的自定义 React Hook，它可以让你获得滚动条的宽度。你可以在任何 React 组件中使用它，它会返回这个特定浏览器（和操作系统）的滚动条的宽度：</p>
<pre><code class="language-jsx">import * as React from 'react';

export const useScrollbarWidth = () =&gt; {
  const didCompute = React.useRef(false);
  const widthRef = React.useRef(0);

  if (didCompute.current) return widthRef.current;

  // Creating invisible container
  const outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll'; // forcing scrollbar to appear
  outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
  document.body.appendChild(outer);

  // Creating inner element and placing it in the container
  const inner = document.createElement('div');
  outer.appendChild(inner);

  // Calculating difference between container's full width and the child width
  const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;

  // Removing temporary elements from the DOM
  outer.parentNode.removeChild(outer);

  didCompute.current = true;
  widthRef.current = scrollbarWidth;

  return scrollbarWidth;
};
</code></pre>
<p>本质上，自定义Hook只是将隐藏的滚动条呈现到项目中，对其进行测量，然后再次将其删除。之后它返回结果。</p>
<p>作为替代方案，如果你希望在水平滚动容器的情况下使用高度而不是滚动条的宽度，则只需将宽度属性替换为高度属性。</p>
<p>就我个人而言，我自己从未遇到过这个问题，但是，当我们在客户端机器上测试应用程序时，在某些情况下滚动条没有覆盖并占用空间。通常这没关系，但是，我们遇到了一些用例，我们必须拥有滚动条的大小才能解决有关应用程序布局的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook：获取滚动方向]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-fang-xiang</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-fang-xiang">
        </link>
        <updated>2022-04-14T08:01:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本节我们实现一个简洁的自定义 React Hook，它可以检测用户的滚动方向：</p>
<pre><code class="language-jsx">import * as React from 'react';

const THRESHOLD = 0;

const useScrollDirection = () =&gt; {
  const [scrollDirection, setScrollDirection] = React.useState('up');

  const blocking = React.useRef(false);
  const prevScrollY = React.useRef(0);

  React.useEffect(() =&gt; {
    prevScrollY.current = window.pageYOffset;

    const updateScrollDirection = () =&gt; {
      const scrollY = window.pageYOffset;

      if (Math.abs(scrollY - prevScrollY.current) &gt;= THRESHOLD) {
        const newScrollDirection =
          scrollY &gt; prevScrollY.current ? 'down' : 'up';

        setScrollDirection(newScrollDirection);

        prevScrollY.current = scrollY &gt; 0 ? scrollY : 0;
      }

      blocking.current = false;
    };

    const onScroll = () =&gt; {
      if (!blocking.current) {
        blocking.current = true;
        window.requestAnimationFrame(updateScrollDirection);
      }
    };

    window.addEventListener('scroll', onScroll);

    return () =&gt; window.removeEventListener('scroll', onScroll);
  }, [scrollDirection]);

  return scrollDirection;
};

export { useScrollDirection };
</code></pre>
<p>在一个函数组件中，自定义的 React Hook可以这样使用：</p>
<pre><code class="language-jsx">import * as React from 'react';

import { useScrollDirection } from './useScrollDirection';

const App = () =&gt; {
  const scrollDirection = useScrollDirection(ref);
  console.log('up');

  return (...);
};
</code></pre>
<p>最后，可能有很多方法可以改进这个自定义Hook（例如，检查水平而不是垂直滚动方向）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook：检查是否溢出]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-cha-shi-fou-yi-chu</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-cha-shi-fou-yi-chu">
        </link>
        <updated>2022-04-14T08:01:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本节我们实现一个简洁的自定义 React Hook，它检查元素的内容是否溢出（这里：垂直溢出）：</p>
<pre><code class="language-jsx">import * as React from 'react';

export const useIsOverflow = (ref, callback) =&gt; {
  const [isOverflow, setIsOverflow] = React.useState(undefined);

  React.useLayoutEffect(() =&gt; {
    const { current } = ref;

    const trigger = () =&gt; {
      const hasOverflow = current.scrollHeight &gt; current.clientHeight;

      setIsOverflow(hasOverflow);

      if (callback) callback(hasOverflow);
    };

    if (current) {
      trigger();
    }
  }, [callback, ref]);

  return isOverflow;
};
</code></pre>
<p>如果你想检测水平溢出，可以将 hasOverflow 分配交换为以下内容：</p>
<pre><code class="language-jsx">const hasOverflow = current.scrollWidth &gt; current.clientWidth;
</code></pre>
<p>在一个函数组件中，自定义的 React Hook可以这样使用：</p>
<pre><code class="language-jsx">import * as React from 'react';

import { useIsOverflow } from './useIsOverflow';

const App = () =&gt; {
  const ref = React.useRef();
  const isOverflow = useIsOverflow(ref);

  console.log(isOverflow);
  // true

  return (
    &lt;div style={{ overflow: 'auto', height: '100px' }} ref={ref}&gt;
      &lt;div style={{ height: '200px' }}&gt;Hello React&lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Hook第一次返回未定义，因为状态尚未设置。</p>
<p>自定义Hook还接受一个可选的回调函数，该函数在检查溢出后触发：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const ref = React.useRef();
  const isOverflow = useIsOverflow(ref, (isOverflowFromCallback) =&gt; {
    console.log(isOverflowFromCallback);
    // true
  });

  console.log(isOverflow);
  // true

  return (
    &lt;div style={{ overflow: 'auto', height: '100px' }} ref={ref}&gt;
      &lt;div style={{ height: '200px' }}&gt;Hello React&lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>如果元素的大小发生变化，你可以调整自定义Hook以再次检查验证溢出，但前提是浏览器支持 ResizeObserver：</p>
<pre><code class="language-jsx">import * as React from 'react';

export const useIsOverflow = (ref, callback) =&gt; {
  const [isOverflow, setIsOverflow] = React.useState(undefined);

  React.useLayoutEffect(() =&gt; {
    const { current } = ref;

    const trigger = () =&gt; {
      const hasOverflow = current.scrollHeight &gt; current.clientHeight;

      setIsOverflow(hasOverflow);

      if (callback) callback(hasOverflow);
    };

    if (current) {
      if ('ResizeObserver' in window) {
        new ResizeObserver(trigger).observe(current);
      }

      trigger();
    }
  }, [callback, ref]);

  return isOverflow;
};
</code></pre>
<p>最后，可能有很多方法可以改进这个自定义Hook（例如，在自定义Hook中初始化 ref 并从自定义Hook返回它以将其附加到元素，只触发一次自定义Hook）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook：使用LocalStorage]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookshi-yong-localstorage</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookshi-yong-localstorage">
        </link>
        <updated>2022-04-14T08:00:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-uselocalstorage">实现 useLocalStorage</h2>
<p>一个简洁的自定义 React Hook，展示了如何在 React 中使用本地存储来存储状态。你可以在任何 React 组件中使用它，它允许你在本地存储中写入和读取状态：</p>
<pre><code class="language-jsx">import * as React from 'react';

const useLocalStorage = (storageKey, fallbackState) =&gt; {
  const [value, setValue] = React.useState(
    JSON.parse(localStorage.getItem(storageKey)) ?? fallbackState
  );

  React.useEffect(() =&gt; {
    localStorage.setItem(storageKey, JSON.stringify(value));
  }, [value, storageKey]);

  return [value, setValue];
};

const App = () =&gt; {
  const [isOpen, setOpen] = useLocalStorage('is-open', false);

  const handleToggle = () =&gt; {
    setOpen(!isOpen);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handleToggle}&gt;Toggle&lt;/button&gt;
      {isOpen &amp;&amp; &lt;div&gt;Content&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p>本地存储Hook只是作为一种学习体验。如果你在生产环境中依赖 React 应用程序的本地存储，你应该检查更广泛使用的Hook（因此是健壮的）。</p>
]]></content>
    </entry>
</feed>