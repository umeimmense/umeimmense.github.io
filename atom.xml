<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2022-05-01T15:56:27.367Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[Shell 工具和脚本]]></title>
        <id>https://umeimmense.github.io/post/shell-gong-ju-he-jiao-ben</id>
        <link href="https://umeimmense.github.io/post/shell-gong-ju-he-jiao-ben">
        </link>
        <updated>2022-05-01T15:50:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="shell-工具和脚本">Shell 工具和脚本</h1>
<blockquote>
<p>课程链接：<a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
</blockquote>
<h2 id="shell-脚本">Shell 脚本</h2>
<p>到目前为止，我们已经学习来如何在shell中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>
<p>shell脚本是一种更加复杂度的工具。</p>
<p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对shell所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是shell脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于bash脚本，因为它最流行，应用更为广泛。</p>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。<br>
需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。<br>
总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash中的字符串通过<code>'</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</p>
<pre><code class="language-bash">foo=bar
echo &quot;$foo&quot;
# 打印 bar
echo '$foo'
# 打印 $foo
</code></pre>
<p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地，<br>
, <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个函数并使用<code>cd</code>进入该文件夹。</p>
<pre><code class="language-bash">mcd () {
    mkdir -p &quot;$1&quot;
    cd &quot;$1&quot;
}
</code></pre>
<p>这里 <code>$1</code> 是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。<br>
返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p>
<p>退出码可以搭配<code>&amp;&amp;</code> (与操作符) 和 <code>||</code> (或操作符)使用，用来进行条件判断，决定是否执行其他程序。同一行的多个命令可以用<code>;</code>分隔。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。让我们看几个例子</p>
<pre><code class="language-bash">false || echo &quot;Oops, fail&quot;
# Oops, fail

true || echo &quot;Will not be printed&quot;
#

true &amp;&amp; echo &quot;Things went well&quot;
# Things went well

false &amp;&amp; echo &quot;Will not be printed&quot;
#

false ; echo &quot;This will always run&quot;
# This will always run
</code></pre>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em> (<em>command substitution</em>)实现。</p>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，然后它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<pre><code class="language-bash">#!/bin/bash

echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间

echo &quot;Running program $0 with $# arguments with pid $$&quot;

for file in $@; do
    grep foobar $file &gt; /dev/null 2&gt; /dev/null
    # 如果模式没有找到，则grep退出状态为 1
    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息
    if [[ $? -ne 0 ]]; then
        echo &quot;File $file does not have any foobar, adding one&quot;
        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;
    fi
done
</code></pre>
<p>在条件语句中，我们比较 <code>$?</code> 是否等于0。<br>
Bash实现了许多类似的比较操作，您可以查看 <a href="http://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。<br>
在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见<a href="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</p>
<p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 <em>通配</em>（ <em>globbing</em>）</p>
<ul>
<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
</ul>
<pre><code class="language-bash">convert image.{png,jpg}
# 会展开为
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# 会展开为
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# 也可以结合通配使用
mv *{.py,.sh} folder
# 会移动所有 *.py 和 *.sh 文件

mkdir foo bar

# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件
touch {foo,bar}/{a..h}
touch foo/x bar/y
# 显示foo和bar文件的不同
diff &lt;(ls foo) &lt;(ls bar)
# 输出
# &lt; x
# ---
# &gt; y
</code></pre>
<!-- Lastly, pipes `|` are a core feature of scripting. Pipes connect one program's output to the next program's input. We will cover them more in detail in the data wrangling lecture. -->
<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a>这样的工具可以帮助你定位sh/bash脚本中的错误。</p>
<p>注意，脚本并不一定只有用bash写才能在终端里调用。比如说，这是一段Python脚本，作用是将输入的参数倒序输出：</p>
<pre><code class="language-python">#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
</code></pre>
<p>shell知道去用python解释器而不是shell命令来运行这段脚本，是因为脚本的开头第一行的<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p>
<p>在 <code>shebang</code> 行中使用 <a href="http://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。<br>
例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code>。</p>
<p>shell函数和脚本有如下一些不同点：</p>
<ul>
<li>函数只能用与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="http://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ul>
<h1 id="shell-工具">Shell 工具</h1>
<h2 id="查看命令如何使用">查看命令如何使用</h2>
<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？<br>
一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>
<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<a href="http://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。<br>
事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code>来获取帮助。</p>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。<br>
<a href="https://tldr.sh/">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>
<p>例如，自己就常常在tldr上搜索<a href="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <a href="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a> 的用法。</p>
<h2 id="查找文件">查找文件</h2>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <a href="http://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a>的工具，它是shell上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p>
<pre><code class="language-bash"># 查找所有名称为src的文件夹
find . -name src -type d
# 查找所有文件夹路径中包含test的python文件
find . -path '**/test/**/*.py' -type f
# 查找前一天修改的所有文件
find . -mtime -1
# 查找所有大小在500k至10M的tar.gz文件
find . -size +500k -size -10M -name '*.tar.gz'
</code></pre>
<p>除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<pre><code class="language-bash"># Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;
# Find all PNG files and convert them to JPG
find . -name '*.png' -exec convert {} {}.jpg \;
</code></pre>
<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用alias设置别名来简化上述操作，但shell的哲学之一便是寻找（更好用的）替代方案。<br>
记住，shell最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如， <a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="http://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。<br>
<code>locate</code> 使用一个由 <a href="http://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="http://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">here</a>有一个更详细的对比。</p>
<h2 id="查找代码">查找代码</h2>
<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>
<p>为了实现这一点，很多类UNIX的系统都提供了<a href="http://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>
<p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p>
<p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>
<pre><code class="language-bash"># 查找所有使用了 requests 库的文件
rg -t py 'import requests'
# 查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match &quot;^#!&quot;
# 查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
# 打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN
</code></pre>
<p>与 <code>find</code>/<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>
<h2 id="查找-shell-命令">查找 shell 命令</h2>
<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。<br>
<code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a>中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。<br>
这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>最后，有一点值得注意，输入命令时，如果您在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
<h2 id="文件夹导航">文件夹导航</h2>
<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录<br>
间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <a href="http://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a>创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>
<p>对于本课程的主题来说，我们希望对常用的情况进行优化。使用<a href="https://github.com/clvv/fasd"><code>fasd</code></a>可以查找最常用和/或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en/The_Places_frecency_algorithm"><em>frecency</em></a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em> ）和时效（ <em>recency</em>）进行排序。</p>
<p>最直接的用法是自动跳转 （<em>autojump</em>），对于经常访问的目录，在目录名子串前加入一个命令 <code>z</code> 就可以快速切换命令到该目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<h1 id="课后练习">课后练习</h1>
<ol>
<li>
<p>阅读 <a href="http://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p>
<ul>
<li>所有文件（包括隐藏文件）</li>
<li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li>
<li>文件以最近访问顺序排序</li>
<li>以彩色文本显示输出结果</li>
</ul>
<p>典型输出如下：✔️</p>
<pre><code>-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
<pre><code class="language-shell">ls -lath --color=auto
</code></pre>
</li>
<li>
<p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。✔️</p>
<pre><code class="language-shell">marco(){
    export MARCO=$(pwd)  
}

polo(){
    cd &quot;$MARCO&quot;
}
</code></pre>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。✔️</p>
<pre><code class="language-shell"> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
    echo &quot;Something went wrong&quot;
    &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
    exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
<pre><code class="language-shell"># errcheck.sh
#! /bin/bash
./err.sh &gt; ./record.txt 2&gt; ./record.txt
m=1
while [ $? -eq 0 ]
do
    let m++
    ./err.sh &gt;&gt; ./record.txt 2&gt;&gt; ./record.txt
done
cat ./record.txt
echo &quot;run times: $m&quot;

</code></pre>
</li>
<li>
<p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="http://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p>
<p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>）✔️</p>
<ul>
<li>--delimiter=&quot;\n\b&quot; 以回车换行为分隔符</li>
</ul>
<pre><code class="language-shell"> find -name &quot;*.html&quot; | xargs --delimiter=&quot;\n\b&quot; zip -r taylorswift.zip
</code></pre>
<pre><code class="language-shell"> find . -type f -name &quot;*.html&quot; | xargs -d '\n'  tar -cvzf archive.tar.gz
</code></pre>
</li>
<li>
<p>(进阶) 编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？✔️</p>
<pre><code class="language-shell">find ./test/ -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head 
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[课程概览与 shell]]></title>
        <id>https://umeimmense.github.io/post/ke-cheng-gai-lan-yu-shell</id>
        <link href="https://umeimmense.github.io/post/ke-cheng-gai-lan-yu-shell">
        </link>
        <updated>2022-05-01T13:52:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>课程链接：<a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
</blockquote>
<h2 id="动机">动机</h2>
<p>作为计算机科学家，我们都知道计算机最擅长帮助我们完成重复性的工作。<br>
但是我们却常常忘记这一点也适用于我们使用计算机的方式，而不仅仅是利用计算机程序去帮我们求解问题。<br>
在从事与计算机相关的工作时，我们有很多触手可及的工具可以帮助我们更高效的解决问题。<br>
但是我们中的大多数人实际上只利用了这些工具中的很少一部分，我们常常只是死记硬背一些如咒语般的命令，<br>
或是当我们卡住的时候，盲目地从网上复制粘贴一些命令。</p>
<p>本课程意在帮你解决这一问题。</p>
<p>我们希望教会您如何挖掘现有工具的潜力，并向您介绍一些新的工具。也许我们还可以促使您想要去探索（甚至是去开发）更多的工具。<br>
我们认为这是大多数计算机科学相关课程中缺少的重要一环。</p>
<h2 id="课程结构">课程结构</h2>
<p>本课程包含 11 个时长在一小时左右的讲座，每一个讲座都会关注一个<br>
<a href="/missing-semester/2020/">特定的主题</a>。尽管这些讲座之间基本上是各自独立的，但随着课程的进行，我们会假定您已经掌握了之前的内容。<br>
每个讲座都有在线笔记供查阅，但是课上的很多内容并不会包含在笔记中。因此我们也会把课程录制下来发布到互联网上供大家观看学习。</p>
<p>我们希望能在这 11 个一小时讲座中涵盖大部分必须的内容，因此课程的信息密度是相当大的。为了能帮助您以自己的节奏来掌握讲座内容，每次课程都包含一组练习来帮助您掌握本节课的重点。<br>
课后我们会安排答疑的时间来回答您的问题。如果您参加的是在线课程，可以发送邮件到<br>
<a href="mailto:missing-semester@mit.edu">missing-semester@mit.edu</a> 来联系我们。</p>
<p>由于时长的限制，我们不可能达到那些专门课程一样的细致程度，我们会适时地将您介绍一些优秀的资源，帮助您深入的理解相关的工具或主题。<br>
但是如果您还有一些特别关注的话题，也请联系我们。</p>
<h1 id="shell-是什么">shell 是什么？</h1>
<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。<br>
这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。<br>
为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>
<p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>本节课我们会使用 Bourne Again SHell, 简称 &quot;bash&quot; 。<br>
这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开shell <em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>
<h2 id="使用-shell">使用 shell</h2>
<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>
<pre><code class="language-shell">missing:~$ 
</code></pre>
<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（&quot;current working directory&quot;）或者说您当前所在的位置是 <code>~</code> (表示 &quot;home&quot;)。 <code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入 <em>命令</em> ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p>
<pre><code class="language-shell">missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
</code></pre>
<p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日前和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em> ：</p>
<pre><code class="language-shell">missing:~$ echo hello
hello
</code></pre>
<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。<br>
shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em>  <code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p>
<pre><code class="language-shell">missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用<br>
<code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p>
<h2 id="在shell中导航">在shell中导航</h2>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如：<br>
<code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p>
<pre><code class="language-shell">missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
</code></pre>
<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>
<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>
<pre><code class="language-shell">missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
</code></pre>
<p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p>
<pre><code class="language-shell">  -l                         use a long listing format
</code></pre>
<pre><code class="language-shell">missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
</code></pre>
<p>这个参数可以打印出更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示<br>
<code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。<br>
（<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。</p>
<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <code>mv</code>（用于重命名或移动文件）、 <code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>
<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p>
<pre><code class="language-console">missing:~$ man ls
</code></pre>
<h2 id="在程序间创建连接">在程序间创建连接</h2>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。<br>
当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。<br>
通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。<br>
但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<pre><code class="language-sh">missing:~$ echo hello &gt; hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat &lt; hello.txt
hello
missing:~$ cat &lt; hello.txt &gt; hello2.txt
missing:~$ cat hello2.txt
hello
</code></pre>
<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。<br>
<code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<pre><code class="language-sh">missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
</code></pre>
<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>
<h2 id="一个功能全面又强大的工具">一个功能全面又强大的工具</h2>
<p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。<br>
您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。<br>
通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。<br>
取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。<br>
当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>
<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。<br>
因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p>
<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p>
<pre><code class="language-sh">/sys/class/backlight
</code></pre>
<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>
<pre><code class="language-sh">$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 &gt; brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
</code></pre>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了<br>
<code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。<br>
<code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。<br>
对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p>
<p>明白这一点后，我们可以这样操作：</p>
<pre><code class="language-sh">$ echo 3 | sudo tee brightness
</code></pre>
<p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。<br>
这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p>
<pre><code class="language-sh">$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
</code></pre>
<h2 id="接下来">接下来.....</h2>
<p>学到这里，您掌握的 shell 知识已经可以完成一些基础的任务了。您应该已经可以查找感兴趣的文件并使用大多数程序的基本功能了。<br>
在下一场讲座中，我们会探讨如何利用 shell 及其他工具执行并自动化更复杂的任务。</p>
<h1 id="课后练习">课后练习</h1>
<ol>
<li>
<p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。✔️</p>
<pre><code class="language-shell">mkdir missing
</code></pre>
</li>
<li>
<p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。✔️</p>
<pre><code class="language-shell">man touch
</code></pre>
</li>
<li>
<p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。✔️</p>
<pre><code class="language-shell">touch semester
</code></pre>
</li>
<li>
<p>将以下内容一行一行地写入<code>semester</code>文件：</p>
<pre><code class="language-shell"> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting手册</a>✔️</p>
<pre><code class="language-shell">echo \#'!'/bin/sh &gt; semester
echo curl --head --silent https://missing.csail.mit.edu &gt;&gt; semester
</code></pre>
</li>
<li>
<p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code>命令来获取信息并理解其不能执行的原因。✔️</p>
<blockquote>
<p>提示权限不够</p>
<p>执行<code>ls -l</code>命令</p>
<p>显示<code>-rw-r--r-- ...</code>显然没有可执行<code>x</code>权限</p>
</blockquote>
</li>
<li>
<p>查看 <code>chmod</code> 的手册(例如，使用<code>man chmod</code>命令)✔️</p>
<pre><code class="language-shell">man chmod
</code></pre>
</li>
<li>
<p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用<code>sh semester</code>来执行该程序。您的shell是如何知晓这个文件需要使用<code>sh</code>来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>✔️</p>
<pre><code class="language-shell">chmod ugo+x semester
./semester
</code></pre>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入根目录下的 <code>last-modified.txt</code> 的文件中✔️</p>
<pre><code class="language-shell">./semester | grep -i &quot;last-modified&quot; &gt; /home/last-modified.txt
</code></pre>
</li>
<li>
<p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机CPU的温度。注意：macOS并没有sysfs，所以mac用户可以跳过这一题✔️</p>
<pre><code class="language-shell">cat /sys/class/power_supply/battery/capacity
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是 DNS？ | DNS 的工作方式]]></title>
        <id>https://umeimmense.github.io/post/shi-me-shi-dns-or-dns-de-gong-zuo-fang-shi</id>
        <link href="https://umeimmense.github.io/post/shi-me-shi-dns-or-dns-de-gong-zuo-fang-shi">
        </link>
        <updated>2022-04-28T14:13:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>阅读本文后，你将能够了解到一下内容：</p>
<ul>
<li>定义 DNS</li>
<li>理解 DNS 的工作方式</li>
<li>区分递归和迭代 DNS 查找</li>
<li>将权威性域名服务器与递归 DNS 解析器分开</li>
<li>探索 DNS 高速缓存的工作方式</li>
</ul>
<h2 id="什么是-dns">什么是 DNS？</h2>
<p>域名系统 (DNS) 是互联网的电话簿。人们通过例如 nytimes.com 或 espn.com 等域名在线访问信息。Web 浏览器通过 互联网协议 （IP） 地址进行交互。DNS 将域名转换为 IP 地址，以便浏览器能够加载互联网资源。<br>
连接到 Internet 的每个设备都有一个唯一 IP 地址，其他计算机可使用该 IP 地址查找此设备。DNS 服务器使人们无需存储例如 192.168.1.1（IPv4 中）等 IP 地址或更复杂的较新字母数字 IP 地址，例如 2400:cb00:2048:1::c629:d7a2（IPv6 中）。</p>
<h2 id="dns-如何工作">DNS 如何工作？</h2>
<p>DNS 解析过程涉及将主机名（例如 www.example.com）转换为计算机友好的 IP 地址（例如 192.168.1.1）。Internet 上的每个设备都被分配了一个 IP 地址，必须有该地址才能找到相应的 Internet 设备 - 就像使用街道地址来查找特定住所一样。当用户想要加载网页时，用户在 Web 浏览器中键入的内容（example.com）与查找 example.com 网页所需的机器友好地址之间必须进行转换。</p>
<p>为理解 DNS 解析过程，务必了解 DNS 查询必须通过的各种硬件设备。对于 Web 浏览器而言，DNS 查询是“在幕后”发生的，除了初始请求外，不需要从用户的计算机进行任何交互。</p>
<h2 id="加载网页涉及-4-个-dns-服务器">加载网页涉及 4 个 DNS 服务器：</h2>
<ul>
<li><code>DNS 解析器</code> - 该解析器可被视为被要求去图书馆的某个地方查找特定图书的图书馆员。DNS 解析器是一种服务器，旨在通过 Web 浏览器等应用程序接收客户端计算机的查询。然后，解析器一般负责发出其他请求，以便满足客户端的 DNS 查询。</li>
<li><code>根域名服务器</code> - 根域名服务器是将人类可读的主机名转换（解析）为 IP 地址的第一步。可将其视为指向不同书架的图书馆中的索引 - 一般其作为对其他更具体位置的引用。</li>
<li><code>TLD 名称服务器</code> —— 顶级域名服务器（TLD）可看做是图书馆中一个特殊的书架。这个域名服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 example.com 中，TLD 服务器为 “com”）。</li>
<li><code>权威性域名服务器</code> - 可将这个最终域名服务器视为书架上的字典，其中特定名称可被转换成其定义。权威性域名服务器是域名服务器查询中的最后一站。如果权威性域名服务器能够访问请求的记录，则其会将已请求主机名的 IP 地址返回到发出初始请求的 DNS 解析器（图书管理员）。</li>
</ul>
<h2 id="权威性-dns-服务器与递归-dns-解析器之间的区别是什么">权威性 DNS 服务器与递归 DNS 解析器之间的区别是什么？</h2>
<p>这两个概念都是指 DNS 基础设施不可或缺的服务器（服务器组），但各自担当不同的角色，并且位于 DNS 查询管道内的不同位置。考虑二者差异的一种方式是，递归解析器位于 DNS 查询的开头，而权威性域名服务器位于末尾。</p>
<h3 id="递归-dns-解析器">递归 DNS 解析器</h3>
<p>递归解析器是一种计算机，其响应来自客户端的递归请求并花时间追踪 DNS 记录。为执行此操作，其发出一系列请求，直至到达用于所请求的记录的权威性 DNS 域名服务器为止（或者超时，或者如果未找到记录，则返回错误）。幸运的是，递归 DNS 解析器并不总是需要发出多个请求才能追踪响应客户端所需的记录；缓存是一种数据持久性过程，可通过在 DNS 查找中更早地服务于所请求的资源记录来为所需的请求提供捷径。</p>
<figure data-type="image" tabindex="1"><img src="https://umeimmense.github.io/post-images/1651069131124.webp" alt="" loading="lazy"></figure>
<h3 id="权威性-dns-服务器">权威性 DNS 服务器</h3>
<p>简言之，权威性 DNS 服务器是实际持有并负责 DNS 资源记录的服务器。这是位于 DNS 查找链底部的服务器，其将使用所查询的资源记录进行响应，从而最终允许发出请求的 Web 浏览器达到访问网站或其他 Web 资源所需的 IP 地址。权威性域名服务器从自身数据满足查询需求，无需查询其他来源，因为这是某些 DNS 记录的最终真实来源。<br>
<img src="https://umeimmense.github.io/post-images/1651069180375.webp" alt="" loading="lazy"><br>
值得一提的是，在查询对象为子域（例如 foo.example.com 或 blog.example.com）的情况下，将向权威性域名服务器之后的序列添加一个附加域名服务器，其负责存储该子域的 CNAME 记录。<br>
<img src="https://umeimmense.github.io/post-images/1651069212505.webp" alt="" loading="lazy"></p>
<h2 id="dns-查找有哪些步骤">DNS 查找有哪些步骤？</h2>
<p>大多数情况下，DNS 与正被转换为相应 IP 地址的域名有关。要了解此过程的工作方式，在 DNS 查找从 Web 浏览器经过 DNS 查找过程然后再返回时，跟踪 DNS 查找的路径会有所帮助。我们来看一下这些步骤。</p>
<p>注意：通常，DNS 查找信息将本地缓存在查询计算机内，或者远程缓存在 DNS 基础设施内。DNS 查找通常有 8 个步骤。缓存 DNS 信息时，将从 DNS 查找过程中跳过一些步骤，从而使该过程更快。以下示例概述了不缓存任何内容时的所有 8 个步骤。</p>
<h3 id="dns-查找的-8-个步骤">DNS 查找的 8 个步骤：</h3>
<ol>
<li>
<p>用户在 Web 浏览器中键入 “example.com”，查询传输到 Internet 中，并被 DNS 递归解析器接收。</p>
</li>
<li>
<p>接着，解析器查询 DNS 根域名服务器（.）。</p>
</li>
<li>
<p>然后，根服务器使用存储其域信息的顶级域（TLD）DNS 服务器（例如 .com 或 .net）的地址响应该解析器。在搜索 example.com 时，我们的请求指向 .com TLD。</p>
</li>
<li>
<p>然后，解析器向 .com TLD 发出请求。</p>
</li>
<li>
<p>TLD 服务器随后使用该域的域名服务器 example.com 的 IP 地址进行响应。</p>
</li>
<li>
<p>最后，递归解析器将查询发送到域的域名服务器。</p>
</li>
<li>
<p>example.com 的 IP 地址而后从域名服务器返回解析器。</p>
</li>
<li>
<p>然后 DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。<br>
DNS 查找的这 8 个步骤返回 example.com 的 IP 地址后，浏览器便能发出对该网页的请求：</p>
</li>
<li>
<p>浏览器向该 IP 地址发出 HTTP 请求。</p>
</li>
<li>
<p>位于该 IP 的服务器返回将在浏览器中呈现的网页（第 10 步）。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://umeimmense.github.io/post-images/1651069273938.webp" alt="" loading="lazy"></figure>
<h3 id="什么是-dns-解析器">什么是 DNS 解析器？</h3>
<p>DNS 解析器是 DNS 查找的第一站，其负责与发出初始请求的客户端打交道。解析器启动查询序列，最终使 URL 转换为必要的 IP 地址。</p>
<p>注意：典型的未缓存 DNS 查找将涉及递归查询和迭代查询。</p>
<p>务必区分递归 DNS 查询和递归 DNS 解析器。该查询是指向需要解析该查询的 DNS 解析器发出的请求。DNS 递归解析器是一种计算机，其接受递归查询并通过发出必要的请求来处理响应。<br>
<img src="https://umeimmense.github.io/post-images/1651069314691.webp" alt="" loading="lazy"></p>
<h2 id="dns-查询有哪些类型">DNS 查询有哪些类型？</h2>
<p>典型 DNS 查找中会出现三种类型的查询。通过组合使用这些查询，优化的 DNS 解析过程可缩短传输距离。在理想情况下，可以使用缓存的记录数据，从而使 DNS 域名服务器能够返回非递归查询。<br>
3 种 DNS 查询类型：</p>
<ol>
<li>递归查询 - 在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息。</li>
<li>迭代查询 - 在这种情况下，DNS 客户端将允许 DNS 服务器返回其能够给出的最佳应答。如果所查询的 DNS 服务器与查询名称不匹配，则其将返回对较低级别域名空间具有权威性的 DNS 服务器的引用。然后，DNS 客户端将对引用地址进行查询。此过程继续使用查询链中的其他 DNS 服务器，直至发生错误或超时为止。</li>
<li>非递归查询 - 当 DNS 解析器客户端查询 DNS 服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。DNS 服务器通常会缓存 DNS 记录，以防止更多带宽消耗和上游服务器上的负载。</li>
</ol>
<h2 id="什么是-dns-高速缓存dns-高速缓存发生在哪里">什么是 DNS 高速缓存？DNS 高速缓存发生在哪里？</h2>
<p>缓存的目的是将数据临时存储在某个位置，从而提高数据请求的性能和可靠性。DNS 高速缓存涉及将数据存储在更靠近请求客户端的位置，以便能够更早地解析 DNS 查询，并且能够避免在 DNS 查找链中进一步向下的额外查询，从而缩短加载时间并减少带宽/CPU 消耗。DNS 数据可缓存到各种不同的位置上，每个位置均将存储 DNS 记录并保存由生存时间（TTL）决定的一段时间。</p>
<h3 id="浏览器-dns-缓存">浏览器 DNS 缓存</h3>
<p>现代 Web 浏览器设计为默认将 DNS 记录缓存一段时间。目的很明显；越靠近 Web 浏览器进行 DNS 缓存，为检查缓存并向 IP 地址发出正确请求而必须采取的处理步骤就越少。发出对 DNS 记录的请求时，浏览器缓存是针对所请求的记录而检查的第一个位置。</p>
<p>在 Chrome 浏览器中，您可以转到 chrome://net-internals/#dns 查看 DNS 缓存的状态。</p>
<h3 id="操作系统os级-dns-缓存">操作系统（OS）级 DNS 缓存</h3>
<p>操作系统级 DNS 解析器是 DNS 查询离开您计算机前的第二站，也是本地最后一站。操作系统内旨在处理此查询的过程通常称为“存根解析器”或 DNS 客户端。当存根解析器获取来自某个应用程序的请求时，其首先检查自己的缓存，以便查看是否有此记录。如果没有，则将本地网络外部的 DNS 查询（设置了递归标记）发送到 Internet 服务提供商（ISP）内部的 DNS 递归解析器。</p>
<p>与先前所有步骤一样，当 ISP 内的递归解析器收到 DNS 查询时，其还将查看所请求的主机到 IP 地址转换是否已经存储在其本地持久性层中。</p>
<p>根据其缓存中具有的记录类型，递归解析器还具有其他功能：</p>
<p>如果解析器没有 A 记录，但确实有针对权威性域名服务器的 NS 记录，则其将直接查询这些域名服务器，从而绕过 DNS 查询中的几个步骤。此快捷方式可防止从根和 .com 域名服务器（在我们对 example.com 的搜索中）进行查找，并且有助于更快地解析 DNS 查询。<br>
如果解析器没有 NS 记录，它会向 TLD 服务器（本例中为 .com）发送查询，从而跳过根服务器。<br>
万一解析器没有指向 TLD 服务器的记录，其将查询根服务器。这种情况通常在清除了 DNS 高速缓存后发生。</p>
<blockquote>
<p><a href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/">原文地址</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook: 实现 useHash 获取 url 上的 hash 值]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hook-shi-xian-usehash-huo-qu-url-shang-de-hash-zhi</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hook-shi-xian-usehash-huo-qu-url-shang-de-hash-zhi">
        </link>
        <updated>2022-04-27T14:47:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-usehash">实现 useHash</h2>
<p>本节我们实现自定义React hook useHash，它能实时获取浏览器的hash值，并允许更改它。</p>
<ul>
<li>使用 useState hook 获取 Location 对象的 hash 属性。</li>
<li>使用 useCallback hook 创建一个更新状态的处理程序。</li>
<li>在挂载时使用 useEffect hook为“hashchange”事件添加监听器，并在卸载时清理它。</li>
<li>使用 useCallback hook 创建一个函数，该函数使用给定值更新 Location 对象的哈希属性。</li>
</ul>
<h3 id="实现">实现</h3>
<pre><code class="language-jsx">const useHash = () =&gt; {
const [hash, setHash] = React.useState(() =&gt; window.location.hash);

const hashChangeHandler = React.useCallback(() =&gt; {
  setHash(window.location.hash);
}, []);

React.useEffect(() =&gt; {
  window.addEventListener('hashchange', hashChangeHandler);
  return () =&gt; {
    window.removeEventListener('hashchange', hashChangeHandler);
  };
}, []);

const updateHash = React.useCallback(
  newHash =&gt; {
    if (newHash !== hash) window.location.hash = newHash;
  },
  [hash]
);

return [hash, updateHash];
};
</code></pre>
<h3 id="样例">样例</h3>
<pre><code class="language-jsx">  const MyApp = () =&gt; {
  const [hash, setHash] = useHash();

  React.useEffect(() =&gt; {
    setHash('#list');
  }, []);

  return (
    &lt;&gt;
      &lt;p&gt;window.location.href: {window.location.href}&lt;/p&gt;
      &lt;p&gt;Edit hash: &lt;/p&gt;
      &lt;input value={hash} onChange={e =&gt; setHash(e.target.value)} /&gt;
    &lt;/&gt;
  );
};

ReactDOM.render(&lt;MyApp /&gt;, document.getElementById('root'));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook: 实现只在更新时执行的 useUpdateEffect]]></title>
        <id>https://umeimmense.github.io/post/react-zi-ding-yi-hooks-useupdateeffect</id>
        <link href="https://umeimmense.github.io/post/react-zi-ding-yi-hooks-useupdateeffect">
        </link>
        <updated>2022-04-27T14:03:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-useupdateeffect">实现 useUpdateEffect</h2>
<p>本节我们实现自定义React hook useUpdateEffect ，它会忽略第一次的副作用，只在后续更新时执行。</p>
<pre><code class="language-jsx">import * as React from 'react';

const App = () =&gt; {
  const [toggle, setToggle] = React.useState(true);

  const handleToggle = () =&gt; {
    setToggle(!toggle);
  };

  const didMount = React.useRef(false);

  React.useEffect(() =&gt; {
    if (didMount.current) {
      console.log('I run only if toggle changes.');
    } else {
      didMount.current = true;
    }
  }, [toggle]);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;

      {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p>如果你定义一个可复用的自定义Hook，它只在更新时（而不是在挂载时）触发效果函数，你可以使用下面的hook：</p>
<pre><code class="language-jsx">import * as React from 'react';

const useEffectOnlyOnUpdate = (callback, dependencies) =&gt; {
  const didMount = React.useRef(false);

  React.useEffect(() =&gt; {
    if (didMount.current) {
      callback(dependencies);
    } else {
      didMount.current = true;
    }
  }, [callback, dependencies]);
};

const App = () =&gt; {
  const [toggle, setToggle] = React.useState(true);

  const handleToggle = () =&gt; {
    setToggle(!toggle);
  };

  useEffectOnlyOnUpdate((dependencies) =&gt; {
    console.log('I run only if toggle changes.');
  }, [toggle]);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;

      {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Search]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-search</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-search">
        </link>
        <updated>2022-04-17T08:13:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，将实现带有搜索功能的 React Table。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户在表中搜索数据。</p>
<h2 id="实现">实现</h2>
<p>React Table库没有自带搜索功能，但是，由于你可以从外部访问数据，因此你可以在将其传递给表之前对其进行操作。让我们看看这是如何工作的。</p>
<p>首先，创建一个 React useState Hook - 保存搜索的状态 - 和一个新的事件处理程序 - 作为稍后用户交互的回调函数：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  ...
};
</code></pre>
<p>接下来，在 Table 组件中，添加一个 HTML 输入字段来设置搜索状态：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>搜索状态生效。最后 展示的就是Table 组件之前搜索项目列表：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  const data = {
    nodes: nodes.filter((item) =&gt;
      item.name.includes(search)
    ),
  };

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  const data = {
    nodes: nodes.filter((item) =&gt;
      item.name.includes(search)
    ),
  };

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>如果你希望Table搜索不区分大小写，则需要调整过滤器功能：</p>
<pre><code class="language-jsx">const data = {
  nodes: nodes.filter((item) =&gt;
    item.name.toLowerCase().includes(search.toLowerCase())
  ),
};
</code></pre>
<p>React Table 没有为搜索功能提供原生插件。但是，你可以将搜索到的列表从外部传递到Table并从外部进行搜索，因此你拥有所有选项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Sort]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort">
        </link>
        <updated>2022-04-17T06:01:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table Library 及其 useSort 插件来实现排序功能。在前面的例子中，你已经安装了 React Table Library 来创建一个 Table 组件。现在，我们将允许用户通过单击列标题对Table中的列进行排序。</p>
<h2 id="实现">实现</h2>
<p>首先，导入 useSort Hook：</p>
<pre><code class="language-jsx">import { useSort } from '@table-library/react-table-library/sort';
</code></pre>
<p>其次，使用Table的数据对其进行初始化，并将其作为 prop 传递给 Table 组件：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data);

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>之后，将你的标题列转换为可排序的：</p>
<pre><code class="language-jsx">import {
  useSort,
  HeaderCellSort ,
} from '@table-library/react-table-library/sort';

const App = () =&gt; {
  ...

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCellSort sortKey=&quot;TASK&quot;&gt;
                Task
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;DEADLINE&quot;&gt;
                Deadline
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;TYPE&quot;&gt;
                Type
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;COMPLETE&quot;&gt;
                Complete
              &lt;/HeaderCellSort&gt;
            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>然后为每个排序键创建各自的排序函数：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data, null, {
    sortFns: {
      TASK: (array) =&gt;
        array.sort((a, b) =&gt; a.name.localeCompare(b.name)),
      DEADLINE: (array) =&gt;
        array.sort((a, b) =&gt; a.deadline - b.deadline),
      TYPE: (array) =&gt;
        array.sort((a, b) =&gt; a.type.localeCompare(b.type)),
      COMPLETE: (array) =&gt;
        array.sort((a, b) =&gt; a.isComplete - b.isComplete),
    },
  });

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>只需几行，你就有一个可排序的Table。我们可以按字符串排序（按字母顺序）、按日期排序、按布尔值排序和按枚举排序。由于自己传递了 sortBy 函数，因此如何对列进行排序取决于sortBy 函数。</p>
<p>可能缺少的获取当前排序的onChange事件。让我们看看它是如何与 useSort 结合使用的：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data,
    {
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  function onSortChange(action, state) {
    console.log(action, state);
  }

  ...
};
</code></pre>
<p>onChange 回调函数使你可以访问触发排序更改的操作以及Table的实际排序状态。通过访问此信息，你可以基于它触发更多的Table或非Table事件（例如，服务器端排序等副作用）。</p>
<p>最后，值得注意的是，你传递给Table的排序对象包含排序状态——这使你能够随时访问它——以及以编程方式对列进行排序的所有函数。当在这个 React Table中使用自定义排序组件时，我们稍后会详细看到这一点。<br>
无论如何，表中的列排序通常会带来更多要求。让我们来看看其中的两个：</p>
<p>例如，有时用户想要具有初始排序状态。这也可以通过 useSort 来实现，方法是传入一个默认的排序状态：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const sort = useSort(data,
    {
      state: {
        sortKey: 'TASK',
        reverse: false,
      },
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  ...
};
</code></pre>
<p>另一个案例是将排序图标与来自第三方库（例如 Material UI）的自定义排序图标交换：</p>
<pre><code class="language-jsx">import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';

const App = () =&gt; {
  ...

  const sort = useSort(
    data,
    {
      onChange: onSortChange,
    },
    {
      sortIcon: {
        margin: '0px',
        iconDefault: &lt;UnfoldMoreOutlinedIcon /&gt;,
        iconUp: &lt;KeyboardArrowUpOutlinedIcon /&gt;,
        iconDown: (
          &lt;KeyboardArrowDownOutlinedIcon /&gt;
        ),
      },
      sortFns: ...
    }
  );

  ...
};
</code></pre>
<p>排序功能还有更多选项。只需前往 <a href="https://react-table-library.com/?path=/docs/features-sort--base">React Table 文档</a>以了解有关它们的更多信息。</p>
<p>最后，使用 React Table Library 可以完全用自定义组件交换排序组件。对于我们的表格排序插件，我们可能希望将排序标题组件与我们自己的来自第三方库的 HTML 按钮进行交换。下面，你将看到一个如何在 React 表库中使用 Material UI 组件的示例。</p>
<p>首先，从你的第三方库中导入自定义组件（和自定义图标）：</p>
<pre><code class="language-jsx">import MaterialButton from '@mui/material/Button';
import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';
</code></pre>
<p>其次Table Header 使用第三方按钮：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const getIcon = (sortKey) =&gt; {
    if (sort.state.sortKey === sortKey &amp;&amp; sort.state.reverse) {
      return &lt;KeyboardArrowDownOutlinedIcon /&gt;;
    }

    if (sort.state.sortKey === sortKey &amp;&amp; !sort.state.reverse) {
      return &lt;KeyboardArrowUpOutlinedIcon /&gt;;
    }

    return &lt;UnfoldMoreOutlinedIcon /&gt;;
  };

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCell&gt;
                &lt;MaterialButton
                  fullWidth
                  style={{ justifyContent: 'flex-start' }}
                  endIcon={getIcon('TASK')}
                  onClick={() =&gt;
                    sort.fns.onToggleSort({
                      sortKey: 'TASK',
                    })
                  }
                &gt;
                  Task
                &lt;/MaterialButton&gt;
              &lt;/HeaderCell&gt;

              ...

            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};

</code></pre>
<p>请注意 useSort 中的排序对象如何为你提供创建自定义组件所需的一切。这样，你可以为每个表格列自定义排序组件。通过使用排序状态和所有排序功能，你可以从任何地方读取和写入排序状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Resize]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize">
        </link>
        <updated>2022-04-17T05:41:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本教程中，我想向你展示如何使用 React Table Library 及其调整大小功能。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户调整表中列的大小。</p>
<h2 id="实现">实现</h2>
<p>首先在Table的列上设置 resize 属性</p>
<pre><code class="language-jsx">&lt;Header&gt;
  &lt;HeaderRow&gt;
    &lt;HeaderCell resize&gt;Task&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Deadline&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Type&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Complete&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Tasks&lt;/HeaderCell&gt;
  &lt;/HeaderRow&gt;
&lt;/Header&gt;
</code></pre>
<p>这是为Table启用可调整大小的列的最直接的方法。但是，如果你想有更多的配置选项，你可以传递一个对象。<br>
例如，如果使用默认值，你可以为每个表格列定义最小宽度。</p>
<pre><code class="language-jsx">&lt;HeaderCell resize={{ minWidth: 50 }}&gt;Task&lt;/HeaderCell&gt;
</code></pre>
<p>你还可以调整大小区域的突出显示颜色并扩大调整区域的大小：</p>
<pre><code class="language-jsx">&lt;HeaderCell
  resize={{
    resizerWidth: 15,
    resizerHighlight: '#98d8ff',
  }}
&gt;
  Task
&lt;/HeaderCell&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 React Table 实现 Fixed Column]]></title>
        <id>https://umeimmense.github.io/post/ru-he-react-table-shi-xian-gu-ding-lie</id>
        <link href="https://umeimmense.github.io/post/ru-he-react-table-shi-xian-gu-ding-lie">
        </link>
        <updated>2022-04-16T05:25:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中中，我想向你展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的列粘在一边：</p>
<h2 id="实现">实现</h2>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme({
    BaseCell: `
      &amp;:nth-of-type(1) {
        left: 0px;

        min-width: 250px;
        width: 250px;
      }

      &amp;:nth-of-type(2) {
        left: 250px;

        min-width: 150px;
        width: 150px;
      }

      &amp;:nth-of-type(3),
      &amp;:nth-of-type(4) {
        min-width: 50%;
        width: 50%;
      }
    `,
  });

  return (...);
};
</code></pre>
<p>我们将列固定在左侧。你也可以以相同的方式将列固定到右侧。缺少的是给 Cell 组件一个 <code>pinLeft</code>（或 <code>pinRight</code>）Props来指示它们固定到一边：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  return (
    &lt;Table data={data} theme={theme} layout={{ custom: true, horizontalScroll: true }}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCell pinLeft&gt;Task&lt;/HeaderCell&gt;
              &lt;HeaderCell pinLeft&gt;Deadline&lt;/HeaderCell&gt;
              &lt;HeaderCell&gt;Type&lt;/HeaderCell&gt;
              &lt;HeaderCell&gt;Complete&lt;/HeaderCell&gt;
            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            {tableList.map((item) =&gt; (
              &lt;Row key={item.id} item={item}&gt;
                &lt;Cell pinLeft&gt;{item.name}&lt;/Cell&gt;
                &lt;Cell pinLeft&gt;
                  {item.deadline.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                  })}
                &lt;/Cell&gt;
                &lt;Cell&gt;{item.type}&lt;/Cell&gt;
                &lt;Cell&gt;{item.isComplete.toString()}&lt;/Cell&gt;
              &lt;/Row&gt;
            ))}
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>一切就绪后，表格的非固定列将沿垂直方向滚动，而该列在表格的一侧保持固定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 React Table 实现 Fixed Header]]></title>
        <id>https://umeimmense.github.io/post/ru-he-reacttable-shi-xian-gu-ding-biao-ti</id>
        <link href="https://umeimmense.github.io/post/ru-he-reacttable-shi-xian-gu-ding-biao-ti">
        </link>
        <updated>2022-04-15T19:05:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中中，我想向您展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的标题粘贴到顶部：</p>
<h2 id="实现">实现</h2>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme({
    Table: `
      height: 100%;
    `,
  });

  return (
    &lt;div
      style={{
        height: '150px',
      }}
    &gt;
      &lt;Table data={data} theme={theme}&gt;
        ...
      &lt;/Table&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>固定Table标题所需的一切都是Table组件周围的容器组件。这样，Table的行将在垂直方向滚动，而标题保持在Table的顶部。</p>
]]></content>
    </entry>
</feed>