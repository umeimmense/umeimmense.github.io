<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2022-04-28T14:56:03.895Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[什么是 DNS？ | DNS 的工作方式]]></title>
        <id>https://umeimmense.github.io/post/shi-me-shi-dns-or-dns-de-gong-zuo-fang-shi</id>
        <link href="https://umeimmense.github.io/post/shi-me-shi-dns-or-dns-de-gong-zuo-fang-shi">
        </link>
        <updated>2022-04-28T14:13:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>阅读本文后，你将能够了解到一下内容：</p>
<ul>
<li>定义 DNS</li>
<li>理解 DNS 的工作方式</li>
<li>区分递归和迭代 DNS 查找</li>
<li>将权威性域名服务器与递归 DNS 解析器分开</li>
<li>探索 DNS 高速缓存的工作方式</li>
</ul>
<h2 id="什么是-dns">什么是 DNS？</h2>
<p>域名系统 (DNS) 是互联网的电话簿。人们通过例如 nytimes.com 或 espn.com 等域名在线访问信息。Web 浏览器通过 互联网协议 （IP） 地址进行交互。DNS 将域名转换为 IP 地址，以便浏览器能够加载互联网资源。<br>
连接到 Internet 的每个设备都有一个唯一 IP 地址，其他计算机可使用该 IP 地址查找此设备。DNS 服务器使人们无需存储例如 192.168.1.1（IPv4 中）等 IP 地址或更复杂的较新字母数字 IP 地址，例如 2400:cb00:2048:1::c629:d7a2（IPv6 中）。</p>
<h2 id="dns-如何工作">DNS 如何工作？</h2>
<p>DNS 解析过程涉及将主机名（例如 www.example.com）转换为计算机友好的 IP 地址（例如 192.168.1.1）。Internet 上的每个设备都被分配了一个 IP 地址，必须有该地址才能找到相应的 Internet 设备 - 就像使用街道地址来查找特定住所一样。当用户想要加载网页时，用户在 Web 浏览器中键入的内容（example.com）与查找 example.com 网页所需的机器友好地址之间必须进行转换。</p>
<p>为理解 DNS 解析过程，务必了解 DNS 查询必须通过的各种硬件设备。对于 Web 浏览器而言，DNS 查询是“在幕后”发生的，除了初始请求外，不需要从用户的计算机进行任何交互。</p>
<h2 id="加载网页涉及-4-个-dns-服务器">加载网页涉及 4 个 DNS 服务器：</h2>
<ul>
<li><code>DNS 解析器</code> - 该解析器可被视为被要求去图书馆的某个地方查找特定图书的图书馆员。DNS 解析器是一种服务器，旨在通过 Web 浏览器等应用程序接收客户端计算机的查询。然后，解析器一般负责发出其他请求，以便满足客户端的 DNS 查询。</li>
<li><code>根域名服务器</code> - 根域名服务器是将人类可读的主机名转换（解析）为 IP 地址的第一步。可将其视为指向不同书架的图书馆中的索引 - 一般其作为对其他更具体位置的引用。</li>
<li><code>TLD 名称服务器</code> —— 顶级域名服务器（TLD）可看做是图书馆中一个特殊的书架。这个域名服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 example.com 中，TLD 服务器为 “com”）。</li>
<li><code>权威性域名服务器</code> - 可将这个最终域名服务器视为书架上的字典，其中特定名称可被转换成其定义。权威性域名服务器是域名服务器查询中的最后一站。如果权威性域名服务器能够访问请求的记录，则其会将已请求主机名的 IP 地址返回到发出初始请求的 DNS 解析器（图书管理员）。</li>
</ul>
<h2 id="权威性-dns-服务器与递归-dns-解析器之间的区别是什么">权威性 DNS 服务器与递归 DNS 解析器之间的区别是什么？</h2>
<p>这两个概念都是指 DNS 基础设施不可或缺的服务器（服务器组），但各自担当不同的角色，并且位于 DNS 查询管道内的不同位置。考虑二者差异的一种方式是，递归解析器位于 DNS 查询的开头，而权威性域名服务器位于末尾。</p>
<h3 id="递归-dns-解析器">递归 DNS 解析器</h3>
<p>递归解析器是一种计算机，其响应来自客户端的递归请求并花时间追踪 DNS 记录。为执行此操作，其发出一系列请求，直至到达用于所请求的记录的权威性 DNS 域名服务器为止（或者超时，或者如果未找到记录，则返回错误）。幸运的是，递归 DNS 解析器并不总是需要发出多个请求才能追踪响应客户端所需的记录；缓存是一种数据持久性过程，可通过在 DNS 查找中更早地服务于所请求的资源记录来为所需的请求提供捷径。</p>
<figure data-type="image" tabindex="1"><img src="https://umeimmense.github.io/post-images/1651069131124.webp" alt="" loading="lazy"></figure>
<h3 id="权威性-dns-服务器">权威性 DNS 服务器</h3>
<p>简言之，权威性 DNS 服务器是实际持有并负责 DNS 资源记录的服务器。这是位于 DNS 查找链底部的服务器，其将使用所查询的资源记录进行响应，从而最终允许发出请求的 Web 浏览器达到访问网站或其他 Web 资源所需的 IP 地址。权威性域名服务器从自身数据满足查询需求，无需查询其他来源，因为这是某些 DNS 记录的最终真实来源。<br>
<img src="https://umeimmense.github.io/post-images/1651069180375.webp" alt="" loading="lazy"><br>
值得一提的是，在查询对象为子域（例如 foo.example.com 或 blog.example.com）的情况下，将向权威性域名服务器之后的序列添加一个附加域名服务器，其负责存储该子域的 CNAME 记录。<br>
<img src="https://umeimmense.github.io/post-images/1651069212505.webp" alt="" loading="lazy"></p>
<h2 id="dns-查找有哪些步骤">DNS 查找有哪些步骤？</h2>
<p>大多数情况下，DNS 与正被转换为相应 IP 地址的域名有关。要了解此过程的工作方式，在 DNS 查找从 Web 浏览器经过 DNS 查找过程然后再返回时，跟踪 DNS 查找的路径会有所帮助。我们来看一下这些步骤。</p>
<p>注意：通常，DNS 查找信息将本地缓存在查询计算机内，或者远程缓存在 DNS 基础设施内。DNS 查找通常有 8 个步骤。缓存 DNS 信息时，将从 DNS 查找过程中跳过一些步骤，从而使该过程更快。以下示例概述了不缓存任何内容时的所有 8 个步骤。</p>
<h3 id="dns-查找的-8-个步骤">DNS 查找的 8 个步骤：</h3>
<ol>
<li>
<p>用户在 Web 浏览器中键入 “example.com”，查询传输到 Internet 中，并被 DNS 递归解析器接收。</p>
</li>
<li>
<p>接着，解析器查询 DNS 根域名服务器（.）。</p>
</li>
<li>
<p>然后，根服务器使用存储其域信息的顶级域（TLD）DNS 服务器（例如 .com 或 .net）的地址响应该解析器。在搜索 example.com 时，我们的请求指向 .com TLD。</p>
</li>
<li>
<p>然后，解析器向 .com TLD 发出请求。</p>
</li>
<li>
<p>TLD 服务器随后使用该域的域名服务器 example.com 的 IP 地址进行响应。</p>
</li>
<li>
<p>最后，递归解析器将查询发送到域的域名服务器。</p>
</li>
<li>
<p>example.com 的 IP 地址而后从域名服务器返回解析器。</p>
</li>
<li>
<p>然后 DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。<br>
DNS 查找的这 8 个步骤返回 example.com 的 IP 地址后，浏览器便能发出对该网页的请求：</p>
</li>
<li>
<p>浏览器向该 IP 地址发出 HTTP 请求。</p>
</li>
<li>
<p>位于该 IP 的服务器返回将在浏览器中呈现的网页（第 10 步）。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://umeimmense.github.io/post-images/1651069273938.webp" alt="" loading="lazy"></figure>
<h3 id="什么是-dns-解析器">什么是 DNS 解析器？</h3>
<p>DNS 解析器是 DNS 查找的第一站，其负责与发出初始请求的客户端打交道。解析器启动查询序列，最终使 URL 转换为必要的 IP 地址。</p>
<p>注意：典型的未缓存 DNS 查找将涉及递归查询和迭代查询。</p>
<p>务必区分递归 DNS 查询和递归 DNS 解析器。该查询是指向需要解析该查询的 DNS 解析器发出的请求。DNS 递归解析器是一种计算机，其接受递归查询并通过发出必要的请求来处理响应。<br>
<img src="https://umeimmense.github.io/post-images/1651069314691.webp" alt="" loading="lazy"></p>
<h2 id="dns-查询有哪些类型">DNS 查询有哪些类型？</h2>
<p>典型 DNS 查找中会出现三种类型的查询。通过组合使用这些查询，优化的 DNS 解析过程可缩短传输距离。在理想情况下，可以使用缓存的记录数据，从而使 DNS 域名服务器能够返回非递归查询。<br>
3 种 DNS 查询类型：</p>
<ol>
<li>递归查询 - 在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息。</li>
<li>迭代查询 - 在这种情况下，DNS 客户端将允许 DNS 服务器返回其能够给出的最佳应答。如果所查询的 DNS 服务器与查询名称不匹配，则其将返回对较低级别域名空间具有权威性的 DNS 服务器的引用。然后，DNS 客户端将对引用地址进行查询。此过程继续使用查询链中的其他 DNS 服务器，直至发生错误或超时为止。</li>
<li>非递归查询 - 当 DNS 解析器客户端查询 DNS 服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。DNS 服务器通常会缓存 DNS 记录，以防止更多带宽消耗和上游服务器上的负载。</li>
</ol>
<h2 id="什么是-dns-高速缓存dns-高速缓存发生在哪里">什么是 DNS 高速缓存？DNS 高速缓存发生在哪里？</h2>
<p>缓存的目的是将数据临时存储在某个位置，从而提高数据请求的性能和可靠性。DNS 高速缓存涉及将数据存储在更靠近请求客户端的位置，以便能够更早地解析 DNS 查询，并且能够避免在 DNS 查找链中进一步向下的额外查询，从而缩短加载时间并减少带宽/CPU 消耗。DNS 数据可缓存到各种不同的位置上，每个位置均将存储 DNS 记录并保存由生存时间（TTL）决定的一段时间。</p>
<h3 id="浏览器-dns-缓存">浏览器 DNS 缓存</h3>
<p>现代 Web 浏览器设计为默认将 DNS 记录缓存一段时间。目的很明显；越靠近 Web 浏览器进行 DNS 缓存，为检查缓存并向 IP 地址发出正确请求而必须采取的处理步骤就越少。发出对 DNS 记录的请求时，浏览器缓存是针对所请求的记录而检查的第一个位置。</p>
<p>在 Chrome 浏览器中，您可以转到 chrome://net-internals/#dns 查看 DNS 缓存的状态。</p>
<h3 id="操作系统os级-dns-缓存">操作系统（OS）级 DNS 缓存</h3>
<p>操作系统级 DNS 解析器是 DNS 查询离开您计算机前的第二站，也是本地最后一站。操作系统内旨在处理此查询的过程通常称为“存根解析器”或 DNS 客户端。当存根解析器获取来自某个应用程序的请求时，其首先检查自己的缓存，以便查看是否有此记录。如果没有，则将本地网络外部的 DNS 查询（设置了递归标记）发送到 Internet 服务提供商（ISP）内部的 DNS 递归解析器。</p>
<p>与先前所有步骤一样，当 ISP 内的递归解析器收到 DNS 查询时，其还将查看所请求的主机到 IP 地址转换是否已经存储在其本地持久性层中。</p>
<p>根据其缓存中具有的记录类型，递归解析器还具有其他功能：</p>
<p>如果解析器没有 A 记录，但确实有针对权威性域名服务器的 NS 记录，则其将直接查询这些域名服务器，从而绕过 DNS 查询中的几个步骤。此快捷方式可防止从根和 .com 域名服务器（在我们对 example.com 的搜索中）进行查找，并且有助于更快地解析 DNS 查询。<br>
如果解析器没有 NS 记录，它会向 TLD 服务器（本例中为 .com）发送查询，从而跳过根服务器。<br>
万一解析器没有指向 TLD 服务器的记录，其将查询根服务器。这种情况通常在清除了 DNS 高速缓存后发生。</p>
<blockquote>
<p><a href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/">原文地址</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook: 实现 useHash 获取 url 上的 hash 值]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hook-shi-xian-usehash-huo-qu-url-shang-de-hash-zhi</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hook-shi-xian-usehash-huo-qu-url-shang-de-hash-zhi">
        </link>
        <updated>2022-04-27T14:47:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-usehash">实现 useHash</h2>
<p>本节我们实现自定义React hook useHash，它能实时获取浏览器的hash值，并允许更改它。</p>
<ul>
<li>使用 useState hook 获取 Location 对象的 hash 属性。</li>
<li>使用 useCallback hook 创建一个更新状态的处理程序。</li>
<li>在挂载时使用 useEffect hook为“hashchange”事件添加监听器，并在卸载时清理它。</li>
<li>使用 useCallback hook 创建一个函数，该函数使用给定值更新 Location 对象的哈希属性。</li>
</ul>
<h3 id="实现">实现</h3>
<pre><code class="language-jsx">const useHash = () =&gt; {
const [hash, setHash] = React.useState(() =&gt; window.location.hash);

const hashChangeHandler = React.useCallback(() =&gt; {
  setHash(window.location.hash);
}, []);

React.useEffect(() =&gt; {
  window.addEventListener('hashchange', hashChangeHandler);
  return () =&gt; {
    window.removeEventListener('hashchange', hashChangeHandler);
  };
}, []);

const updateHash = React.useCallback(
  newHash =&gt; {
    if (newHash !== hash) window.location.hash = newHash;
  },
  [hash]
);

return [hash, updateHash];
};
</code></pre>
<h3 id="样例">样例</h3>
<pre><code class="language-jsx">  const MyApp = () =&gt; {
  const [hash, setHash] = useHash();

  React.useEffect(() =&gt; {
    setHash('#list');
  }, []);

  return (
    &lt;&gt;
      &lt;p&gt;window.location.href: {window.location.href}&lt;/p&gt;
      &lt;p&gt;Edit hash: &lt;/p&gt;
      &lt;input value={hash} onChange={e =&gt; setHash(e.target.value)} /&gt;
    &lt;/&gt;
  );
};

ReactDOM.render(&lt;MyApp /&gt;, document.getElementById('root'));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义 React Hook: 实现只在更新时执行的useEffect]]></title>
        <id>https://umeimmense.github.io/post/react-zi-ding-yi-hooks-useupdateeffect</id>
        <link href="https://umeimmense.github.io/post/react-zi-ding-yi-hooks-useupdateeffect">
        </link>
        <updated>2022-04-27T14:03:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-useupdateeffect">实现 useUpdateEffect</h2>
<p>本节我们实现自定义React hook useUpdateEffect ，它会忽略第一次的副作用，只在后续更新时执行。</p>
<pre><code class="language-jsx">import * as React from 'react';

const App = () =&gt; {
  const [toggle, setToggle] = React.useState(true);

  const handleToggle = () =&gt; {
    setToggle(!toggle);
  };

  const didMount = React.useRef(false);

  React.useEffect(() =&gt; {
    if (didMount.current) {
      console.log('I run only if toggle changes.');
    } else {
      didMount.current = true;
    }
  }, [toggle]);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;

      {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p>如果你定义一个可复用的自定义Hook，它只在更新时（而不是在挂载时）触发效果函数，你可以使用下面的hook：</p>
<pre><code class="language-jsx">import * as React from 'react';

const useEffectOnlyOnUpdate = (callback, dependencies) =&gt; {
  const didMount = React.useRef(false);

  React.useEffect(() =&gt; {
    if (didMount.current) {
      callback(dependencies);
    } else {
      didMount.current = true;
    }
  }, [callback, dependencies]);
};

const App = () =&gt; {
  const [toggle, setToggle] = React.useState(true);

  const handleToggle = () =&gt; {
    setToggle(!toggle);
  };

  useEffectOnlyOnUpdate((dependencies) =&gt; {
    console.log('I run only if toggle changes.');
  }, [toggle]);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;

      {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Search]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-search</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-search">
        </link>
        <updated>2022-04-17T08:13:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，将实现带有搜索功能的 React Table。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户在表中搜索数据。</p>
<h2 id="实现">实现</h2>
<p>React Table库没有自带搜索功能，但是，由于你可以从外部访问数据，因此你可以在将其传递给表之前对其进行操作。让我们看看这是如何工作的。</p>
<p>首先，创建一个 React useState Hook - 保存搜索的状态 - 和一个新的事件处理程序 - 作为稍后用户交互的回调函数：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  ...
};
</code></pre>
<p>接下来，在 Table 组件中，添加一个 HTML 输入字段来设置搜索状态：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>搜索状态生效。最后 展示的就是Table 组件之前搜索项目列表：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  const data = {
    nodes: nodes.filter((item) =&gt;
      item.name.includes(search)
    ),
  };

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};const App = () =&gt; {
  const [search, setSearch] = React.useState('');

  const handleSearch = (event) =&gt; {
    setSearch(event.target.value);
  };

  const data = {
    nodes: nodes.filter((item) =&gt;
      item.name.includes(search)
    ),
  };

  return (
    &lt;&gt;
      &lt;label htmlFor=&quot;search&quot;&gt;
        Search by Task:
        &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt;
      &lt;/label&gt;

      &lt;Table data={data}&gt;
        ...
      &lt;/Table&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>如果你希望Table搜索不区分大小写，则需要调整过滤器功能：</p>
<pre><code class="language-jsx">const data = {
  nodes: nodes.filter((item) =&gt;
    item.name.toLowerCase().includes(search.toLowerCase())
  ),
};
</code></pre>
<p>React Table 没有为搜索功能提供原生插件。但是，你可以将搜索到的列表从外部传递到Table并从外部进行搜索，因此你拥有所有选项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Sort]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort">
        </link>
        <updated>2022-04-17T06:01:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table Library 及其 useSort 插件来实现排序功能。在前面的例子中，你已经安装了 React Table Library 来创建一个 Table 组件。现在，我们将允许用户通过单击列标题对Table中的列进行排序。</p>
<h2 id="实现">实现</h2>
<p>首先，导入 useSort Hook：</p>
<pre><code class="language-jsx">import { useSort } from '@table-library/react-table-library/sort';
</code></pre>
<p>其次，使用Table的数据对其进行初始化，并将其作为 prop 传递给 Table 组件：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data);

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>之后，将你的标题列转换为可排序的：</p>
<pre><code class="language-jsx">import {
  useSort,
  HeaderCellSort ,
} from '@table-library/react-table-library/sort';

const App = () =&gt; {
  ...

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCellSort sortKey=&quot;TASK&quot;&gt;
                Task
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;DEADLINE&quot;&gt;
                Deadline
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;TYPE&quot;&gt;
                Type
              &lt;/HeaderCellSort&gt;
              &lt;HeaderCellSort sortKey=&quot;COMPLETE&quot;&gt;
                Complete
              &lt;/HeaderCellSort&gt;
            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>然后为每个排序键创建各自的排序函数：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data, null, {
    sortFns: {
      TASK: (array) =&gt;
        array.sort((a, b) =&gt; a.name.localeCompare(b.name)),
      DEADLINE: (array) =&gt;
        array.sort((a, b) =&gt; a.deadline - b.deadline),
      TYPE: (array) =&gt;
        array.sort((a, b) =&gt; a.type.localeCompare(b.type)),
      COMPLETE: (array) =&gt;
        array.sort((a, b) =&gt; a.isComplete - b.isComplete),
    },
  });

  return (
    &lt;Table data={data} sort={sort}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>只需几行，你就有一个可排序的Table。我们可以按字符串排序（按字母顺序）、按日期排序、按布尔值排序和按枚举排序。由于自己传递了 sortBy 函数，因此如何对列进行排序取决于sortBy 函数。</p>
<p>可能缺少的获取当前排序的onChange事件。让我们看看它是如何与 useSort 结合使用的：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const data = { nodes };

  const sort = useSort(data,
    {
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  function onSortChange(action, state) {
    console.log(action, state);
  }

  ...
};
</code></pre>
<p>onChange 回调函数使你可以访问触发排序更改的操作以及Table的实际排序状态。通过访问此信息，你可以基于它触发更多的Table或非Table事件（例如，服务器端排序等副作用）。</p>
<p>最后，值得注意的是，你传递给Table的排序对象包含排序状态——这使你能够随时访问它——以及以编程方式对列进行排序的所有函数。当在这个 React Table中使用自定义排序组件时，我们稍后会详细看到这一点。<br>
无论如何，表中的列排序通常会带来更多要求。让我们来看看其中的两个：</p>
<p>例如，有时用户想要具有初始排序状态。这也可以通过 useSort 来实现，方法是传入一个默认的排序状态：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const sort = useSort(data,
    {
      state: {
        sortKey: 'TASK',
        reverse: false,
      },
      onChange: onSortChange,
    }, {
      sortFns: ...,
    }
  );

  ...
};
</code></pre>
<p>另一个案例是将排序图标与来自第三方库（例如 Material UI）的自定义排序图标交换：</p>
<pre><code class="language-jsx">import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';

const App = () =&gt; {
  ...

  const sort = useSort(
    data,
    {
      onChange: onSortChange,
    },
    {
      sortIcon: {
        margin: '0px',
        iconDefault: &lt;UnfoldMoreOutlinedIcon /&gt;,
        iconUp: &lt;KeyboardArrowUpOutlinedIcon /&gt;,
        iconDown: (
          &lt;KeyboardArrowDownOutlinedIcon /&gt;
        ),
      },
      sortFns: ...
    }
  );

  ...
};
</code></pre>
<p>排序功能还有更多选项。只需前往 <a href="https://react-table-library.com/?path=/docs/features-sort--base">React Table 文档</a>以了解有关它们的更多信息。</p>
<p>最后，使用 React Table Library 可以完全用自定义组件交换排序组件。对于我们的表格排序插件，我们可能希望将排序标题组件与我们自己的来自第三方库的 HTML 按钮进行交换。下面，你将看到一个如何在 React 表库中使用 Material UI 组件的示例。</p>
<p>首先，从你的第三方库中导入自定义组件（和自定义图标）：</p>
<pre><code class="language-jsx">import MaterialButton from '@mui/material/Button';
import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined';
import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined';
import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined';
</code></pre>
<p>其次Table Header 使用第三方按钮：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  const getIcon = (sortKey) =&gt; {
    if (sort.state.sortKey === sortKey &amp;&amp; sort.state.reverse) {
      return &lt;KeyboardArrowDownOutlinedIcon /&gt;;
    }

    if (sort.state.sortKey === sortKey &amp;&amp; !sort.state.reverse) {
      return &lt;KeyboardArrowUpOutlinedIcon /&gt;;
    }

    return &lt;UnfoldMoreOutlinedIcon /&gt;;
  };

  return (
    &lt;Table data={data} sort={sort}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCell&gt;
                &lt;MaterialButton
                  fullWidth
                  style={{ justifyContent: 'flex-start' }}
                  endIcon={getIcon('TASK')}
                  onClick={() =&gt;
                    sort.fns.onToggleSort({
                      sortKey: 'TASK',
                    })
                  }
                &gt;
                  Task
                &lt;/MaterialButton&gt;
              &lt;/HeaderCell&gt;

              ...

            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            ...
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};

</code></pre>
<p>请注意 useSort 中的排序对象如何为你提供创建自定义组件所需的一切。这样，你可以为每个表格列自定义排序组件。通过使用排序状态和所有排序功能，你可以从任何地方读取和写入排序状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 中实现 Resize]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize">
        </link>
        <updated>2022-04-17T05:41:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本教程中，我想向你展示如何使用 React Table Library 及其调整大小功能。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户调整表中列的大小。</p>
<h2 id="实现">实现</h2>
<p>首先在Table的列上设置 resize 属性</p>
<pre><code class="language-jsx">&lt;Header&gt;
  &lt;HeaderRow&gt;
    &lt;HeaderCell resize&gt;Task&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Deadline&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Type&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Complete&lt;/HeaderCell&gt;
    &lt;HeaderCell resize&gt;Tasks&lt;/HeaderCell&gt;
  &lt;/HeaderRow&gt;
&lt;/Header&gt;
</code></pre>
<p>这是为Table启用可调整大小的列的最直接的方法。但是，如果你想有更多的配置选项，你可以传递一个对象。<br>
例如，如果使用默认值，你可以为每个表格列定义最小宽度。</p>
<pre><code class="language-jsx">&lt;HeaderCell resize={{ minWidth: 50 }}&gt;Task&lt;/HeaderCell&gt;
</code></pre>
<p>你还可以调整大小区域的突出显示颜色并扩大调整区域的大小：</p>
<pre><code class="language-jsx">&lt;HeaderCell
  resize={{
    resizerWidth: 15,
    resizerHighlight: '#98d8ff',
  }}
&gt;
  Task
&lt;/HeaderCell&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 React Table 实现 Fixed Column]]></title>
        <id>https://umeimmense.github.io/post/ru-he-react-table-shi-xian-gu-ding-lie</id>
        <link href="https://umeimmense.github.io/post/ru-he-react-table-shi-xian-gu-ding-lie">
        </link>
        <updated>2022-04-16T05:25:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中中，我想向你展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的列粘在一边：</p>
<h2 id="实现">实现</h2>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme({
    BaseCell: `
      &amp;:nth-of-type(1) {
        left: 0px;

        min-width: 250px;
        width: 250px;
      }

      &amp;:nth-of-type(2) {
        left: 250px;

        min-width: 150px;
        width: 150px;
      }

      &amp;:nth-of-type(3),
      &amp;:nth-of-type(4) {
        min-width: 50%;
        width: 50%;
      }
    `,
  });

  return (...);
};
</code></pre>
<p>我们将列固定在左侧。你也可以以相同的方式将列固定到右侧。缺少的是给 Cell 组件一个 <code>pinLeft</code>（或 <code>pinRight</code>）Props来指示它们固定到一边：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  ...

  return (
    &lt;Table data={data} theme={theme} layout={{ custom: true, horizontalScroll: true }}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            &lt;HeaderRow&gt;
              &lt;HeaderCell pinLeft&gt;Task&lt;/HeaderCell&gt;
              &lt;HeaderCell pinLeft&gt;Deadline&lt;/HeaderCell&gt;
              &lt;HeaderCell&gt;Type&lt;/HeaderCell&gt;
              &lt;HeaderCell&gt;Complete&lt;/HeaderCell&gt;
            &lt;/HeaderRow&gt;
          &lt;/Header&gt;

          &lt;Body&gt;
            {tableList.map((item) =&gt; (
              &lt;Row key={item.id} item={item}&gt;
                &lt;Cell pinLeft&gt;{item.name}&lt;/Cell&gt;
                &lt;Cell pinLeft&gt;
                  {item.deadline.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                  })}
                &lt;/Cell&gt;
                &lt;Cell&gt;{item.type}&lt;/Cell&gt;
                &lt;Cell&gt;{item.isComplete.toString()}&lt;/Cell&gt;
              &lt;/Row&gt;
            ))}
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>一切就绪后，表格的非固定列将沿垂直方向滚动，而该列在表格的一侧保持固定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 React Table 实现 Fixed Header]]></title>
        <id>https://umeimmense.github.io/post/ru-he-reacttable-shi-xian-gu-ding-biao-ti</id>
        <link href="https://umeimmense.github.io/post/ru-he-reacttable-shi-xian-gu-ding-biao-ti">
        </link>
        <updated>2022-04-15T19:05:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中中，我想向您展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的标题粘贴到顶部：</p>
<h2 id="实现">实现</h2>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme({
    Table: `
      height: 100%;
    `,
  });

  return (
    &lt;div
      style={{
        height: '150px',
      }}
    &gt;
      &lt;Table data={data} theme={theme}&gt;
        ...
      &lt;/Table&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>固定Table标题所需的一切都是Table组件周围的容器组件。这样，Table的行将在垂直方向滚动，而标题保持在Table的顶部。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React Table 使用 Theme]]></title>
        <id>https://umeimmense.github.io/post/ru-he-zai-react-table-shi-yong-zhu-ti</id>
        <link href="https://umeimmense.github.io/post/ru-he-zai-react-table-shi-yong-zhu-ti">
        </link>
        <updated>2022-04-15T13:39:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table Library 及其 useTheme 插件来使用自定义样式对你的表格进行主题化。在前面的例子中，你已经安装了 React Table Library 来创建一个Table 组件。</p>
<h2 id="实现">实现</h2>
<p>首先，导入 useTheme Hook：</p>
<pre><code class="language-jsx">import { useTheme } from '@table-library/react-table-library/theme';
</code></pre>
<p>其次，用它创建一个主题并将其作为Props传递给 Table 组件：</p>
<pre><code class="language-jsx">const THEME = {};

const App = () =&gt; {
  const data = { nodes };

  const theme = useTheme(THEME);

  return (
    &lt;Table data={data} theme={theme}&gt;
      ...
    &lt;/Table&gt;
  );
};
</code></pre>
<p>只需几行，你就为表格创建了一个自定义主题。但是，主题是空的，接下来让我们看看如何使用它来调整表格的样式：</p>
<pre><code class="language-jsx">const THEME = {
  HeaderRow: `
    font-size: 14px;

    background-color: #eaf5fd;
  `,
  Row: `
    font-size: 14px;

    &amp;:nth-child(odd) {
      background-color: #d2e9fb;
    }

    &amp;:nth-child(even) {
      background-color: #eaf5fd;
    }
  `,
};
</code></pre>
<p>本质上，主题是一本字典，你可以在其中设置表格的不同组件的样式。在最后一个示例中，我们设置了标题行和行组件的样式。由于两个组件共享一些相同的样式，你也可以将此样式提取为一个共同点：</p>
<pre><code class="language-jsx">const THEME = {
  BaseRow: `
    font-size: 14px;
  `,
  HeaderRow: `
    background-color: #eaf5fd;
  `,
  Row: `
    &amp;:nth-child(odd) {
      background-color: #d2e9fb;
    }

    &amp;:nth-child(even) {
      background-color: #eaf5fd;
    }
  `,
};
</code></pre>
<p>以下组件可用作样式键：Table、HeaderRow、Row、HeaderCell、Cell、BaseRow、BaseCell。最后，这应该为你提供所有入口点，以便为表格设置所有不同组件的样式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何创建 React Table 组件]]></title>
        <id>https://umeimmense.github.io/post/ru-he-chuang-jian-react-table-zu-jian</id>
        <link href="https://umeimmense.github.io/post/ru-he-chuang-jian-react-table-zu-jian">
        </link>
        <updated>2022-04-15T12:39:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我想向你展示如何使用 React Table​​库在 React 中创建Table组件。在本节之后，你可以使用库的文档继续构建许多其他示例，例如搜索、过滤、排序、选择、嵌套树表或 React 表的分页功能。但让我们从基础开始。</p>
<h2 id="实现">实现</h2>
<p>让我们从通过命令行安装 React Table Library ：</p>
<pre><code class="language-shell">npm install @table-library/react-table-library @emotion/react
</code></pre>
<p>任务是在 React Table​​组件中显示以下项列表：</p>
<pre><code class="language-js">const list = [
  {
    id: '1',
    name: 'VSCode',
    deadline: new Date(2022, 1, 17),
    type: 'SETUP',
    isComplete: true,
  },
  {
    id: '2',
    name: 'JavaScript',
    deadline: new Date(2022, 2, 28),
    type: 'LEARN',
    isComplete: true,
  },
  {
    id: '3',
    name: 'React',
    deadline: new Date(2022, 3, 8),
    type: 'LEARN',
    isComplete: false,
  }
];
</code></pre>
<p>我们将从在 Table 组件可以使用的对象中构建列表开始。组件本身从库中导入：</p>
<pre><code class="language-jsx">import * as React from 'react';
import { Table } from '@table-library/react-table-library/table';

const list = [ ... ];

const App = () =&gt; {
  const data = { nodes: list };

  return &lt;Table data={data}&gt;{(tableList) =&gt; null}&lt;/Table&gt;;
};
</code></pre>
<p>Table 组件接受一个数据对象作为带有节点属性的Props。这些节点是我们列表中的项，但是，该表使其对节点的命名更加通用，因为该表不仅可以显示列表结构，还可以显示树结构。</p>
<p>此外，Table 组件使用一个子函数作为子函数，它使我们能够以 tableList 的形式访问表中的列表。在内部，表格组件将各种修改应用于我们的列表——例如排序、分页等，如果启用了这些插件 - 因此应该使用 tableList（而不是数据或列表）来呈现表中的项。</p>
<p>React Table 库使用组合而不是配置。因此，你可以从库本身获得所有必要的构建块作为组件。让我们从表格的标题开始：</p>
<pre><code class="language-jsx">import * as React from 'react';
import {
  Table,
  Header,
  HeaderRow,
  HeaderCell,
} from '@table-library/react-table-library/table';

const list = [ ... ];

const App = () =&gt; {
  const data = { nodes: list };

  return (
    &lt;Table data={data}&gt;
      {(tableList) =&gt; (
        &lt;Header&gt;
          &lt;HeaderRow&gt;
            &lt;HeaderCell&gt;Task&lt;/HeaderCell&gt;
            &lt;HeaderCell&gt;Deadline&lt;/HeaderCell&gt;
            &lt;HeaderCell&gt;Type&lt;/HeaderCell&gt;
            &lt;HeaderCell&gt;Complete&lt;/HeaderCell&gt;
          &lt;/HeaderRow&gt;
        &lt;/Header&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>通过使用这些组件，你可以将表创建为组件的组合，而每个组件都有自己的职责。例如，我们不是只有一个 Table 组件可以接受一个大型配置对象，而是有可组合的组件——例如 Header、HeaderRow 和 HeaderCell，它们可以接收专用的 props。</p>
<p>接下来，让我们像在 React 中渲染列表时所习惯的那样显示我们的项，方法是渲染 Row 组件，并为 Body 组件中的每个项提供一个键：</p>
<pre><code class="language-jsx">import * as React from 'react';
import {
  Table,
  Header,
  HeaderRow,
  HeaderCell,
  Body,
  Row,
  Cell,
} from '@table-library/react-table-library/table';

const list = [ ... ];

const App = () =&gt; {
  const data = { nodes: list };

  return (
    &lt;Table data={data}&gt;
      {(tableList) =&gt; (
        &lt;&gt;
          &lt;Header&gt;
            ...
          &lt;/Header&gt;

          &lt;Body&gt;
            {tableList.map((item) =&gt; (
              &lt;Row key={item.id} item={item}&gt;
                &lt;Cell&gt;{item.name}&lt;/Cell&gt;
                &lt;Cell&gt;
                  {item.deadline.toLocaleDateString(
                    'en-US',
                    {
                      year: 'numeric',
                      month: '2-digit',
                      day: '2-digit',
                    }
                  )}
                &lt;/Cell&gt;
                &lt;Cell&gt;{item.type}&lt;/Cell&gt;
                &lt;Cell&gt;{item.isComplete.toString()}&lt;/Cell&gt;
              &lt;/Row&gt;
            ))}
          &lt;/Body&gt;
        &lt;/&gt;
      )}
    &lt;/Table&gt;
  );
};
</code></pre>
<p>由于你可以完全控制在 Cell 组件中呈现的内容，因此你可以根据需要格式化数据。布尔值可以转换为字符串，日期可以格式化为可读版本。 Cell 组件没有特殊的props来完成渲染。使用 React 表格​​库可以直接在 React 中呈现表格组件。</p>
]]></content>
    </entry>
</feed>