<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://umeimmense.github.io</id>
    <title>Cool Coding</title>
    <updated>2022-04-14T14:04:45.091Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://umeimmense.github.io"/>
    <link rel="self" href="https://umeimmense.github.io/atom.xml"/>
    <logo>https://umeimmense.github.io/images/avatar.png</logo>
    <icon>https://umeimmense.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cool Coding</rights>
    <entry>
        <title type="html"><![CDATA[自定义React Hook：获取滚动条宽度]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-tiao-kuan-du</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-tiao-kuan-du">
        </link>
        <updated>2022-04-14T08:02:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本节实现一个简洁的自定义 React Hook，它可以让你获得滚动条的宽度。你可以在任何 React 组件中使用它，它会返回这个特定浏览器（和操作系统）的滚动条的宽度：</p>
<pre><code class="language-jsx">import * as React from 'react';

export const useScrollbarWidth = () =&gt; {
  const didCompute = React.useRef(false);
  const widthRef = React.useRef(0);

  if (didCompute.current) return widthRef.current;

  // Creating invisible container
  const outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll'; // forcing scrollbar to appear
  outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
  document.body.appendChild(outer);

  // Creating inner element and placing it in the container
  const inner = document.createElement('div');
  outer.appendChild(inner);

  // Calculating difference between container's full width and the child width
  const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;

  // Removing temporary elements from the DOM
  outer.parentNode.removeChild(outer);

  didCompute.current = true;
  widthRef.current = scrollbarWidth;

  return scrollbarWidth;
};
</code></pre>
<p>本质上，自定义Hook只是将隐藏的滚动条呈现到项目中，对其进行测量，然后再次将其删除。之后它返回结果。</p>
<p>作为替代方案，如果你希望在水平滚动容器的情况下使用高度而不是滚动条的宽度，则只需将宽度属性替换为高度属性。</p>
<p>就我个人而言，我自己从未遇到过这个问题，但是，当我们在客户端机器上测试应用程序时，在某些情况下滚动条没有覆盖并占用空间。通常这没关系，但是，我们遇到了一些用例，我们必须拥有滚动条的大小才能解决有关应用程序布局的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义React Hook：获取滚动方向]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-fang-xiang</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-fang-xiang">
        </link>
        <updated>2022-04-14T08:01:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本节我们实现一个简洁的自定义 React Hook，它可以检测用户的滚动方向：</p>
<pre><code class="language-jsx">import * as React from 'react';

const THRESHOLD = 0;

const useScrollDirection = () =&gt; {
  const [scrollDirection, setScrollDirection] = React.useState('up');

  const blocking = React.useRef(false);
  const prevScrollY = React.useRef(0);

  React.useEffect(() =&gt; {
    prevScrollY.current = window.pageYOffset;

    const updateScrollDirection = () =&gt; {
      const scrollY = window.pageYOffset;

      if (Math.abs(scrollY - prevScrollY.current) &gt;= THRESHOLD) {
        const newScrollDirection =
          scrollY &gt; prevScrollY.current ? 'down' : 'up';

        setScrollDirection(newScrollDirection);

        prevScrollY.current = scrollY &gt; 0 ? scrollY : 0;
      }

      blocking.current = false;
    };

    const onScroll = () =&gt; {
      if (!blocking.current) {
        blocking.current = true;
        window.requestAnimationFrame(updateScrollDirection);
      }
    };

    window.addEventListener('scroll', onScroll);

    return () =&gt; window.removeEventListener('scroll', onScroll);
  }, [scrollDirection]);

  return scrollDirection;
};

export { useScrollDirection };
</code></pre>
<p>在一个函数组件中，自定义的 React Hook可以这样使用：</p>
<pre><code class="language-jsx">import * as React from 'react';

import { useScrollDirection } from './useScrollDirection';

const App = () =&gt; {
  const scrollDirection = useScrollDirection(ref);
  console.log('up');

  return (...);
};
</code></pre>
<p>最后，可能有很多方法可以改进这个自定义Hook（例如，检查水平而不是垂直滚动方向）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义React Hook：检查是否溢出]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-cha-shi-fou-yi-chu</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-cha-shi-fou-yi-chu">
        </link>
        <updated>2022-04-14T08:01:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本节我们实现一个简洁的自定义 React Hook，它检查元素的内容是否溢出（这里：垂直溢出）：</p>
<pre><code class="language-jsx">import * as React from 'react';

export const useIsOverflow = (ref, callback) =&gt; {
  const [isOverflow, setIsOverflow] = React.useState(undefined);

  React.useLayoutEffect(() =&gt; {
    const { current } = ref;

    const trigger = () =&gt; {
      const hasOverflow = current.scrollHeight &gt; current.clientHeight;

      setIsOverflow(hasOverflow);

      if (callback) callback(hasOverflow);
    };

    if (current) {
      trigger();
    }
  }, [callback, ref]);

  return isOverflow;
};
</code></pre>
<p>如果你想检测水平溢出，可以将 hasOverflow 分配交换为以下内容：</p>
<pre><code class="language-jsx">const hasOverflow = current.scrollWidth &gt; current.clientWidth;
</code></pre>
<p>在一个函数组件中，自定义的 React Hook可以这样使用：</p>
<pre><code class="language-jsx">import * as React from 'react';

import { useIsOverflow } from './useIsOverflow';

const App = () =&gt; {
  const ref = React.useRef();
  const isOverflow = useIsOverflow(ref);

  console.log(isOverflow);
  // true

  return (
    &lt;div style={{ overflow: 'auto', height: '100px' }} ref={ref}&gt;
      &lt;div style={{ height: '200px' }}&gt;Hello React&lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Hook第一次返回未定义，因为状态尚未设置。</p>
<p>自定义Hook还接受一个可选的回调函数，该函数在检查溢出后触发：</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const ref = React.useRef();
  const isOverflow = useIsOverflow(ref, (isOverflowFromCallback) =&gt; {
    console.log(isOverflowFromCallback);
    // true
  });

  console.log(isOverflow);
  // true

  return (
    &lt;div style={{ overflow: 'auto', height: '100px' }} ref={ref}&gt;
      &lt;div style={{ height: '200px' }}&gt;Hello React&lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>如果元素的大小发生变化，你可以调整自定义Hook以再次检查验证溢出，但前提是浏览器支持 ResizeObserver：</p>
<pre><code class="language-jsx">import * as React from 'react';

export const useIsOverflow = (ref, callback) =&gt; {
  const [isOverflow, setIsOverflow] = React.useState(undefined);

  React.useLayoutEffect(() =&gt; {
    const { current } = ref;

    const trigger = () =&gt; {
      const hasOverflow = current.scrollHeight &gt; current.clientHeight;

      setIsOverflow(hasOverflow);

      if (callback) callback(hasOverflow);
    };

    if (current) {
      if ('ResizeObserver' in window) {
        new ResizeObserver(trigger).observe(current);
      }

      trigger();
    }
  }, [callback, ref]);

  return isOverflow;
};
</code></pre>
<p>最后，可能有很多方法可以改进这个自定义Hook（例如，在自定义Hook中初始化 ref 并从自定义Hook返回它以将其附加到元素，只触发一次自定义Hook）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义React Hook：使用LocalStorage]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookshi-yong-localstorage</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookshi-yong-localstorage">
        </link>
        <updated>2022-04-14T08:00:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现-uselocalstorage">实现 useLocalStorage</h2>
<p>一个简洁的自定义 React Hook，展示了如何在 React 中使用本地存储来存储状态。你可以在任何 React 组件中使用它，它允许你在本地存储中写入和读取状态：</p>
<pre><code class="language-jsx">import * as React from 'react';

const useLocalStorage = (storageKey, fallbackState) =&gt; {
  const [value, setValue] = React.useState(
    JSON.parse(localStorage.getItem(storageKey)) ?? fallbackState
  );

  React.useEffect(() =&gt; {
    localStorage.setItem(storageKey, JSON.stringify(value));
  }, [value, storageKey]);

  return [value, setValue];
};

const App = () =&gt; {
  const [isOpen, setOpen] = useLocalStorage('is-open', false);

  const handleToggle = () =&gt; {
    setOpen(!isOpen);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handleToggle}&gt;Toggle&lt;/button&gt;
      {isOpen &amp;&amp; &lt;div&gt;Content&lt;/div&gt;}
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p>本地存储Hook只是作为一种学习体验。如果你在生产环境中依赖 React 应用程序的本地存储，你应该检查更广泛使用的Hook（因此是健壮的）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义React Hook：检测组件外部的点击]]></title>
        <id>https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-ce-zu-jian-wai-bu-de-dian-ji</id>
        <link href="https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-ce-zu-jian-wai-bu-de-dian-ji">
        </link>
        <updated>2022-04-14T08:00:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章我们一起来聊聊如何创建自定义 React Hook来检测 React 组件外部的点击。例如，你可能希望为各种组件（如对话框或下拉菜单）提供此类自定义 React Hook，因为当用户单击它们外部时它们应该关闭。所以我们需要一种方法来找出这个外部点击。<br>
在这里学到的大部分内容都可以追溯到 JavaScript 中事件冒泡和捕获的概念。因此，如果你需要对冒泡、目标和捕获阶段进行复习，我建议你阅读以下文章，之前该文章涉及 React 的这个主题。</p>
<h2 id="实现">实现</h2>
<p>让我们从 React 中的一个函数组件开始，我们使用 React 的 useState Hook 和一个事件处理程序来增加一个计数器：</p>
<pre><code class="language-jsx">import * as React from 'react';

const style = {
  padding: '10px',
  border: '1px solid black',
  display: 'flex',
  justifyContent: 'flex-end',
};

function App() {
  const [count, setCount] = React.useState(0);

  const handleClick = () =&gt; {
    setCount((state) =&gt; state + 1);
  };

  return (
    &lt;div style={style}&gt;
      &lt;button type=&quot;button&quot; onClick={handleClick}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>一切都按预期工作。接下来，我们要在用户单击按钮外部时重置状态（此处为：计数）。我们可以编写用于重置状态的事件处理程序，但是尚不清楚在哪里使用它：</p>
<pre><code class="language-jsx">function App() {
  const [count, setCount] = React.useState(0);

  const handleClickOutside = () =&gt; {
    setCount(0);
  };

  const handleClick = () =&gt; {
    setCount((state) =&gt; state + 1);
  };

  return (
    &lt;div style={style}&gt;
      &lt;button type=&quot;button&quot; onClick={handleClick}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>一种原始的方法是在顶级组件的最外层 HTML 元素（这里：<div>）上使用这个新的处理程序。但是，更好的方法是在文档级别使用此事件处理程序作为最佳实践，因为最外层的 HTML 元素可能会在开发过程中发生变化。<br>
我们将直接在自定义Hook中实现这一点，以避免冗余重构：</p>
<pre><code class="language-jsx">const useOutsideClick = (callback) =&gt; {
  const ref = React.useRef();

  React.useEffect(() =&gt; {
    const handleClick = (event) =&gt; {
      callback();
    };

    document.addEventListener('click', handleClick);

    return () =&gt; {
      document.removeEventListener('click', handleClick);
    };
  }, []);

  return ref;
};
</code></pre>
<p>自定义Hook会启动一个最终返回的 React ref。它还没有真正用在Hook的实现细节中。此外，自定义Hook使用 React 的 useEffect Hook在文档级别分配（和删除）一个事件监听器（这里：单击事件）。毕竟，每当单击文档时，处理程序以及传递的回调函数都会运行。</p>
<p>现在自定义Hook可以在我们的 React 组件中以下列方式使用：将事件处理程序作为回调函数传递给Hook——只要单击文档就会执行。此外，使用返回的引用（此处为：ref）并将其分配给按钮 HTML 元素：</p>
<pre><code class="language-jsx">function App() {
  const [count, setCount] = React.useState(0);

  const handleClickOutside = () =&gt; {
    setCount(0);
  };

  const ref = useOutsideClick(handleClickOutside);

  const handleClick = () =&gt; {
    setCount((state) =&gt; state + 1);
  };

  return (
    &lt;div style={style}&gt;
      &lt;button ref={ref} type=&quot;button&quot; onClick={handleClick}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>但是，你会注意到，处理程序将始终触发，即使在单击按钮本身时也是如此。如果你再次检查自定义Hook，你将看到该引用（ref）并没有真正在其中使用。我们想要完成的事情：仅在单击传递的 ref（此处表示按钮）之外的任何内容时执行回调函数，而不是在单击 ref 本身（或其内容）时执行回调函数：</p>
<pre><code class="language-jsx">const useOutsideClick = (callback) =&gt; {
  const ref = React.useRef();

  React.useEffect(() =&gt; {
    const handleClick = (event) =&gt; {
      if (ref.current &amp;&amp; !ref.current.contains(event.target)) {
        callback();
      }
    };

    document.addEventListener('click', handleClick);

    return () =&gt; {
      document.removeEventListener('click', handleClick);
    };
  }, [ref]);

  return ref;
};
</code></pre>
<p>就是这样。分配给按钮的引用是触发按钮的事件处理程序和文档的事件处理程序之间的边界。在参考之外点击的所有内容都将被视为外部点击。</p>
<p>但是缺少一个小的改进：如果我们需要通过在事件处理程序上使用 stopPropagation() 方法来停止某些边缘情况下的事件冒泡怎么办。例如，在下面我们通过单击容器元素来扩展组件并在那里停止事件的传播：</p>
<pre><code class="language-jsx">const style = {
  padding: '10px',
  border: '1px solid black',
  display: 'flex',
  justifyContent: 'space-between',
};

...

function App() {
  const [count, setCount] = React.useState(0);

  const handleClickOutside = () =&gt; {
    setCount(0);
  };

  const ref = useOutsideClick(handleClickOutside);

  const handleClick = () =&gt; {
    setCount((state) =&gt; state + 1);
  };

  const handleHeaderClick = (event) =&gt; {
    // do something

    event.stopPropagation();
  };

  return (
    &lt;div style={style} onClick={handleHeaderClick}&gt;
      &lt;div&gt;Header&lt;/div&gt;
      &lt;button ref={ref} type=&quot;button&quot; onClick={handleClick}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>当我们尝试这个例子时，我们会看到容器上的点击不会作为“外部点击”，因为即使它是外部点击，由于事件停止冒泡，它永远不会到达文档的事件侦听器。</p>
<p>通过使用冒泡和捕获阶段，我们可以调整自定义Hook以在捕获阶段触发。因为捕获阶段发生在冒泡阶段之前，所以即使事件在冒泡阶段停止传播，对文档的点击也将始终运行：</p>
<pre><code class="language-jsx">const useOutsideClick = (callback) =&gt; {
  const ref = React.useRef();

  React.useEffect(() =&gt; {
    const handleClick = (event) =&gt; {
      if (ref.current &amp;&amp; !ref.current.contains(event.target)) {
        callback();
      }
    };

    document.addEventListener('click', handleClick, true);

    return () =&gt; {
      document.removeEventListener('click', handleClick, true);
    };
  }, [ref]);

  return ref;
};
</code></pre>
<p>就是这样。你创建了一个自定义挂钩来检测引用的组件/元素之外的点击。建议你再次阅读事件冒泡和捕获文章，以更深入地解释这些阶段发生的事情。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何创建自定义 React Hook ]]></title>
        <id>https://umeimmense.github.io/post/ru-he-chuang-jian-zi-ding-yi-react-hook</id>
        <link href="https://umeimmense.github.io/post/ru-he-chuang-jian-zi-ding-yi-react-hook">
        </link>
        <updated>2022-04-13T07:35:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>React 很久以前就引入了 Hooks。随着 Hooks 的发布，函数组件能够使用内置 Hooks 的状态和副作用，例如 React 的 useState Hook 和 React 的 useEffect Hook。<br>
不过，React 只提供了少数内置 Hook（例如 useReducer、useCallback、useMemo、useContext）。但是，通过使用这些 Hooks 作为基础，React 开发人员可以创建自己的称为自定义 Hooks 的 Hooks。</p>
<p>在我们创建自定义Hook之前，你需要知道创建一个有两个规则：</p>
<ul>
<li>自定义 Hooks 以“use”为前缀命名。例如，自定义Hook可以命名为 useLocalStorage 或 useAuthentication。在我们的例子中，自定义Hook将被命名为 useBoolean。</li>
<li>自定义 Hooks 由内置的 React Hooks 或其他自定义 Hooks 组成。因此，自定义 Hook 始终是一个或多个 Hook 的新组合。如果自定义 Hook 在内部不使用任何Hook，则它不是自定义 Hook，不应具有前缀“use”。</li>
</ul>
<h2 id="自定义hook">自定义Hook</h2>
<p>我们将创建一个名为 useBoolean 的自定义 Hook，让我们看看它为我们解决了什么问题。让我们从一个小例子开始：</p>
<pre><code class="language-jsx">import * as React from 'react';

function App() {
  const [isToggle, setToggle] = React.useState(false);

  const handleToggle = () =&gt; setToggle(!isToggle);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;

      {isToggle.toString()}
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>该组件呈现一个用于切换布尔值的按钮。在React 应用程序中，要么切换它（如上一个示例），要么将其显式设置为 true 或 false（如下一个示例）：</p>
<pre><code class="language-jsx">import * as React from 'react';

function App() {
  const [isToggle, setToggle] = React.useState(false);

  const handleToggle = () =&gt; setToggle(!isToggle);
  const handleTrue = () =&gt; setToggle(true);
  const handleFalse = () =&gt; setToggle(false);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleToggle}&gt;
        Toggle
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; onClick={handleTrue}&gt;
        To True
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; onClick={handleFalse}&gt;
        To False
      &lt;/button&gt;

      {isToggle.toString()}
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>一些观点可能会争辩说，我们本可以使用内联处理程序，这样就不会有事件处理程序的重复声明。然而，我个人尽量避免使用内联处理程序，因为它们向 JSX 注入了太多逻辑，而应该在组件的函数签名和返回语句之间定义。但这只是个人喜好。<br>
无论如何，每次使用有状态布尔值时，都会遇到相同的实现细节：要么切换布尔值，要么将其设置为两个可能值之一。为了在多个 React 组件中使用有状态布尔值时屏蔽这些重复代码，我开始为它创建一个自定义Hook：</p>
<pre><code class="language-jsx">const useBoolean = () =&gt; {
  const [state, setState] = React.useState();

  const handleTrue = () =&gt; setState(true);
  const handleFalse = () =&gt; setState(false);
  const handleToggle = () =&gt; setState(!state);

  return [
    state,
    {
      setTrue: handleTrue,
      setFalse: handleFalse,
      setToggle: handleToggle,
    },
  ];
};
</code></pre>
<p>基本上所有实现细节，即状态和事件处理程序，都移到了这个名为 useBoolean 的自定义Hook中。此外，自定义Hook返回状态和更新数组中状态的函数。<br>
从自定义Hook返回多个值时，返回一个数组是最佳实践，因为 React 的内置 Hooks（在返回多个值的情况下）利用了数组，因此也使用了数组解构。使用数组解构的好处是可以为解构的值赋予任何名称（在对象解构的情况下，代码比重命名值要少）。</p>
<pre><code class="language-jsx">const useBoolean = (initialState = false) =&gt; {
  const [state, setState] = React.useState(initialState);

  const handleTrue = () =&gt; setState(true);
  const handleFalse = () =&gt; setState(false);
  const handleToggle = () =&gt; setState(!state);

  return [
    state,
    {
      setTrue: handleTrue,
      setFalse: handleFalse,
      setToggle: handleToggle,
    },
  ];
};
</code></pre>
<p>一个很好的补充是也添加一个初始状态（如最后一个代码片段所示）。回到我们的 App 组件，我们可以通过向它传递初始状态并使用它的返回值来显示状态并更新它来使用这个新的自定义Hook：</p>
<pre><code class="language-jsx">function App() {
  const [isToggle, { setToggle }] = useBoolean(false);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={setToggle}&gt;
        Toggle
      &lt;/button&gt;

      {isToggle.toString()}
    &lt;/div&gt;
  );
}
</code></pre>
<p>由于自定义Hook不仅提供了切换有状态布尔值的功能，而且还可以将其显式设置为True或False，我们也可以使用这些功能：</p>
<pre><code class="language-jsx">function App() {
  const [isToggle, {
    setToggle,
    setTrue,
    setFalse,
  }] = useBoolean(false);

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={setToggle}&gt;
        Toggle
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; onClick={setTrue}&gt;
        To True
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; onClick={setFalse}&gt;
        To False
      &lt;/button&gt;

      {isToggle.toString()}
    &lt;/div&gt;
  );
}
</code></pre>
<p>本质上，我们将有状态的布尔值和所有在布尔值上运行的事件处理程序提取到一个自定义Hook中。通过每次我们需要一个有状态的布尔值时使用这个自定义钩子，我们可以节省定义事件处理程序，其中包括有关如何操作布尔值的实现细节，而不是使用从钩子返回的函数。</p>
<p>总之，我们已经学习了如何使用 React 的内置 Hook 之一（称为 useState）来创建自定义钩子。这个自定义钩子并不复杂，但是，它应该向你展示如何减少 React 项目中的复杂性和冗余。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React中的事件处理]]></title>
        <id>https://umeimmense.github.io/post/react-de-shi-jian-chu-li</id>
        <link href="https://umeimmense.github.io/post/react-de-shi-jian-chu-li">
        </link>
        <updated>2022-04-12T08:18:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在本节中，我们将了解 React 中用于 HTML 元素（例如按钮和输入元素）的事件处理程序。你将学习如何使用带有 onClick 事件的按钮，以及如何定义和使用不同类型的事件处理程序。本质上，我们将介绍三种事件处理程序：事件处理程序、内联事件处理程序和回调事件处理程序。</p>
<h2 id="react中的事件处理程序">React中的事件处理程序</h2>
<p>首先，我们将从 React 中针对特定 onClick 事件处理程序的按钮示例开始。这是关于如何在 React 中使用事件处理程序（也称为事件处理程序函数或处理程序）处理事件的最基本示例。按钮具有接收函数的 onClick 属性。每次触发事件时都会调用此函数（此处：单击按钮时）：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  function handleClick() {
    console.log('Button click ...');
  }

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleClick}&gt;
        Event Handler
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>对于其他属性，如 onChange（onChange 事件处理程序）和 onSubmit（onSubmit 事件处理程序），它的工作方式类似。对于初学者来说，onClick 经常不起作用，因为他们没有传递函数，而是直接在 JSX 中调用函数。例如，在下一个版本中，事件处理程序仅在第一次渲染组件时被调用一次。其他每一次单击都不会调用事件处理函数，因为函数的返回值用于 onClick 属性而不是函数本身。所以没有什么可调用的；除非函数返回另一个函数：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  function handleClick() {
    console.log('Button click ...');
  }

  // don't do this
  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleClick()}&gt;
        Event Handler
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>通过使用 JavaScript 箭头函数，可以使事件处理函数更加简洁。不过，这是一个可选步骤。就个人而言，我喜欢将事件处理程序作为箭头函数：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const handleClick = () =&gt; {
    console.log('Button click ...');
  };

  return (
    &lt;div&gt;
      &lt;button type=&quot;button&quot; onClick={handleClick}&gt;
        Event Handler
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>但是一旦更多的事件处理程序在 React 组件中添加，通过再次给它们函数语句来使它们与其他变量更容易区分是很好的：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const user = {
    id: '123abc',
    username: 'Robin Wieruch',
  };

  function handleUserSignIn() {
    // do something
  }

  function handleUserSignUp() {
    // do something
  }

  function handleUserSignOut() {
    // do something
  }

  ...
}
</code></pre>
<p>毕竟，onClick 事件的事件处理程序应该实现一些业务逻辑。在本例中，React 的 useState Hook 用于通过 onClick 按钮事件更新某些状态：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    &lt;div&gt;
      Count: {count}

      &lt;button type=&quot;button&quot; onClick={handleClick}&gt;
        Increase Count
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>下一个示例向你展示了一个输入字段而不是一个按钮。在那里，我们使用的是始终作为第一个参数传递给事件处理函数的实际事件。该事件是来自 React 的合成事件，它本质上封装了原生 HTML 事件并在其之上添加了一些功能。每次有人使用事件的目标属性输入输入字段时，此事件都会为你提供输入字段的值：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [text, setText] = React.useState('');

  function handleChange(event) {
    setText(event.target.value);
  }

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={handleChange} /&gt;

      {text}
    &lt;/div&gt;
  );
}
</code></pre>
<p>以前我们没有使用过该事件，因为在我们的按钮示例中我们不需要它。在输入字段示例中，我们需要它。最后但同样重要的是，不要忘记将值传递给输入元素以使其成为受控组件：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [text, setText] = React.useState('');

  function handleChange(event) {
    setText(event.target.value);
  }

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; value={text} onChange={handleChange} /&gt;

      {text}
    &lt;/div&gt;
  );
}
</code></pre>
<p>简而言之，这就是事件处理程序。让我们了解 React 中更高级的处理程序。</p>
<h2 id="react-中的内联事件处理程序">React 中的内联事件处理程序</h2>
<p>内联事件处理程序，也称为内联处理程序，通过直接在 JSX 中使用事件处理程序为我们提供了许多新选项：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  return (
    &lt;div&gt;
      Count: {count}

      &lt;button
        type=&quot;button&quot;
        onClick={function() {
          setCount(count + 1);
        }}
      &gt;
        Increase Count
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>在 JSX 中使用通用函数语句虽然很冗长。因此，JavaScript 箭头函数可以方便地定义更简洁的内联处理程序：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  return (
    &lt;div&gt;
      Count: {count}

      &lt;button
        type=&quot;button&quot;
        onClick={() =&gt; setCount(count + 1)}
      &gt;
        Increase Count
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>一般来说，开发者都是懒惰的人，所以经常使用内联事件处理程序来避免在 JSX 之外进行额外的函数声明。然而，这会将大量业务逻辑转移到 JSX 中，这使得它的可读性、可维护性和易错性降低。就个人而言，我喜欢在没有内联事件处理程序的情况下保持 JSX 干净，并在 JSX 之外声明事件处理程序。<br>
内联处理程序也用于将参数传递给在 JSX 之外定义的更通用的处理程序：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  function handleCount(delta) {
    setCount(count + delta);
  }

  return (
    &lt;div&gt;
      Count: {count}

      &lt;button type=&quot;button&quot; onClick={() =&gt; handleCount(1)}&gt;
        Increase Count
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; onClick={() =&gt; handleCount(-1)}&gt;
        Decrease Count
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>这样，也可以并行传递事件和参数。即使在此示例中不需要它，但你肯定会在将来遇到需要该事件的一种或另一种情况（例如 React Forms 的 preventDefault ）：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  function handleCount(event, delta) {
    setCount(count + delta);
  }

  return (
    &lt;div&gt;
      Count: {count}

      &lt;button type=&quot;button&quot; onClick={event =&gt; handleCount(event, 1)}&gt;
        Increase Count
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; onClick={event =&gt; handleCount(event, -1)}&gt;
        Decrease Count
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>因此，当你需要传递事件和参数时，例如当你需要为 onClick 事件提供额外参数时，内联事件处理程序可能会为你提供帮助。然后 JSX 之外的更通用的事件处理程序可以使用这个额外的参数。</p>
<h2 id="react-中的回调事件处理程序">React 中的回调事件处理程序</h2>
<p>简而言之，有回调事件处理程序或回调处理程序。当子组件需要与父组件通信时使用它们。由于 React props 只在组件树中向下传递，因此使用回调处理程序（其核心是一个函数）进行向上通信：</p>
<pre><code class="language-jsx">import React from 'react';

function App() {
  const [text, setText] = React.useState('');

  // 1
  function handleTextChange(event) {
    setText(event.target.value); // 3
  }

  return (
    &lt;div&gt;
      &lt;MyInput inputValue={text} onInputChange={handleTextChange} /&gt;

      {text}
    &lt;/div&gt;
  );
}

// 2
function MyInput({ inputValue, onInputChange }) {
  return (
    &lt;input type=&quot;text&quot; value={inputValue} onChange={onInputChange} /&gt;
  );
}
</code></pre>
<p>回调处理程序在某处定义 (1)，在其他地方使用 (2)，但回调到其定义的位置 (3)。这样，就可以从子组件到父组件进行通信。回调处理程序通过 React props 向下传递，并在调用函数时向上通信。</p>
<p>你已经了解了 React 的事件处理程序、内联事件处理程序和回调事件处理程序，以及如何在按钮中为它们的 onClick 事件和在输入字段中为它们的 onChange 事件使用它们。还有其他事件处理程序，例如表单元素的 onSubmit，实际上需要该事件来阻止本机浏览器行为。无论如何，所有这些事件处理程序都有其特定目的。你的目标应该是让你的代码保持可读性和可维护性，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React中的事件冒泡和捕获]]></title>
        <id>https://umeimmense.github.io/post/react-shi-jian-mou-pao-he-bu-huo</id>
        <link href="https://umeimmense.github.io/post/react-shi-jian-mou-pao-he-bu-huo">
        </link>
        <updated>2022-04-12T08:17:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文主题是React事件冒泡和捕获的 。大多数 JavaScript 开发人员可能已经熟悉这个主题，因为它起源于 JavaScript 及其 DOM API。但是，在本文中，我想为 React 中的事件冒泡和捕获整理一些信息。</p>
<p>React 中的事件处理程序可用于侦听特定事件（例如单击事件）。我们将从 React 中的一个函数组件开始，我们使用 React 的 useState Hook 来增加一个计数器：</p>
<pre><code class="language-jsx">import * as React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  const handleClick = () =&gt; {
    setCount(count + 1);
  };

  return (
    &lt;button type=&quot;button&quot; onClick={handleClick}&gt;
      Count: {count}
    &lt;/button&gt;
  );
}

export default App;
</code></pre>
<p>在原生 JavaScript 中，这相当于 element.addEventListener('click', handleClick);。 React 中有很多事件。下面显示了鼠标和触摸事件的事件列表：</p>
<ul>
<li>touchstart</li>
<li>touchmove</li>
<li>touchend</li>
<li>mousemove</li>
<li>mousedown</li>
<li>mouseup</li>
<li>click<br>
此特定事件列表按其执行顺序显示。因此，如果在 HTML 元素中添加了 mouseup 和 click 事件侦听器，则 mouseup 事件将在 click 事件之前触发：</li>
</ul>
<pre><code class="language-jsx">import * as React from 'react';

function App() {
  const handleClick = () =&gt; {
    alert('click');
  };

  const handleMouseUp = () =&gt; {
    alert('mouseup');
  };

  return (
    &lt;button
      type=&quot;button&quot;
      onClick={handleClick}
      onMouseUp={handleMouseUp}
    &gt;
      Which one fires first?
    &lt;/button&gt;
  );
}

export default App;
</code></pre>
<p>在某些情况下，你可能希望在另一个事件触发时阻止其中一个事件。例如，当触摸事件发生并被处理时，你可能希望阻止所有点击事件。</p>
<p>无论如何，在前面的示例中，所有事件都发生在同一个 HTML 元素上。关于事件冒泡或捕获还没有什么可看的。接下来，让我们探索使用多个 HTML 元素的事件冒泡：</p>
<pre><code class="language-jsx">import * as React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  const handleCount = () =&gt; {
    setCount((state) =&gt; state + 1);
  };

  return (
    &lt;div onClick={handleCount}&gt;
      &lt;button type=&quot;button&quot; onClick={handleCount}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>在这个例子中，按钮似乎被点击了两次，因为计数器增加了 2 而不是 1。然而，发生的事情是包装容器元素也调用了它的事件处理程序。进入在 React 中事件冒泡。</p>
<h2 id="react-中的事件冒泡">React 中的事件冒泡</h2>
<p>下面的示例显示了两个具有相同样式的 HTML 元素。为了简单起见，我们在这里使用内联样式，但是，你可以随意使用更复杂的方式来设置你的 React 应用程序的样式。</p>
<p>无论如何，让我们进入事件冒泡的话题。如你所见，在下一个示例中，只有外部容器元素侦听单击事件，而不是内部容器元素。但无论你是单击外部元素还是内部元素，都会触发事件处理程序：</p>
<pre><code class="language-jsx">import * as React from 'react';

const style = {
  padding: '10px 30px',
  border: '1px solid black',
};

function App() {
  const handleClick = () =&gt; {
    alert('click');
  };

  return (
    &lt;div style={style} onClick={handleClick}&gt;
      &lt;div style={style}&gt;Click Me&lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>在 JavaScript 中，这个原理称为事件冒泡。每当在 HTML 元素（例如内部 HTML 元素）上发生事件时，它就会开始运行通过该特定元素的处理程序，然后是其父 HTML 元素（例如外部 HTML 元素，它实际上在其中找到侦听处理程序）的处理程序，然后一直向上遍历每个祖先 HTML 元素，直到它到达文档的根。<br>
<img src="https://umeimmense.github.io/post-images/1649934566165.png" alt="" loading="lazy"><br>
在下一个示例中尝试一下，当单击内部 HTML 元素时，两个事件处理程序都会被触发。如果单击外部 HTML 元素，则仅触发外部元素的事件处理程序：</p>
<pre><code class="language-jsx">import * as React from 'react';

const style = {
  padding: '10px 30px',
  border: '1px solid black',
};

function App() {
  const handleOuterClick = () =&gt; {
    alert('outer click');
  };

  const handleInnerClick = () =&gt; {
    alert('inner click');
  };

  return (
    &lt;div style={style} onClick={handleOuterClick}&gt;
      &lt;div style={style} onClick={handleInnerClick}&gt;
        Click Me
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>换句话说，事件从它们的起源开始冒泡整个文档。通过 React 的 useEffect Hook 在文档上添加一个事件监听器，自己验证这种行为：</p>
<pre><code class="language-jsx">import * as React from 'react';

const style = {
  padding: '10px 30px',
  border: '1px solid black',
};

function App() {
  const handleOuterClick = () =&gt; {
    alert('outer click');
  };

  const handleInnerClick = () =&gt; {
    alert('inner click');
  };

  React.useEffect(() =&gt; {
    const handleDocumentClick = () =&gt; {
      alert('document click');
    };

    document.addEventListener('click', handleDocumentClick);

    return () =&gt; {
      document.removeEventListener('click', handleDocumentClick);
    };
  }, []);

  return (
    &lt;div style={style} onClick={handleOuterClick}&gt;
      &lt;div style={style} onClick={handleInnerClick}&gt;
        Click Me
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>因此，如果一个事件从其交互元素中冒出整个文档，那么在某些情况下如何停止冒泡呢？在 React 中输入 stopPropagation</p>
<h2 id="react-stoppropagation">React  stopPropagation</h2>
<p>stopPropagation() 方法是 DOM API 的原生方法。由于 React 将事件包装到称为合成事件的 React 版本中，因此该 API 仍然可用于 React 事件，它还可以用于停止事件的传播：</p>
<pre><code class="language-jsx">import * as React from 'react';

function App() {
  const [count, setCount] = React.useState(0);

  const handleCount = (event) =&gt; {
    setCount((state) =&gt; state + 1);

    event.stopPropagation();
  };

  return (
    &lt;div onClick={handleCount}&gt;
      &lt;button type=&quot;button&quot; onClick={handleCount}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>我们通过对事件使用 stopPropagation() 方法扩展了前面的示例之一。这样，当按钮被点击时，事件不会冒泡，也不会触发周围容器元素的事件处理程序。<br>
<img src="https://umeimmense.github.io/post-images/1649934812136.png" alt="" loading="lazy"><br>
反之，当容器元素被显式点击时（在这种情况下不太可能没有任何进一步的样式），只有容器的事件处理程序会触发。这里容器元素上的 stopPropagation() 有点多余，因为它上面没有事件处理程序。</p>
<p>最佳时机：默认情况下不要停止事件传播。例如，如果你将在项目中的每个按钮上使用 stopPropagation()，但稍后你想在文档级别跟踪用户点击，你将不会再收到这些事件。默认情况下使用 stopPropagation() 往往会导致错误，因此仅在必要时使用它。</p>
<p>当停止事件传播有意义时，让我们看看更复杂的场景。例如，可能有一个可点击的标题，可以将用户从任何页面导航到主页，但是，在标题内有一个按钮可以让用户从应用程序中注销。两个元素都应该是可点击的，不会相互干扰：</p>
<pre><code class="language-jsx">import * as React from 'react';

const styleHeader = {
  padding: '10px',
  border: '1px solid black',
  boxSizing: 'border-box',
  width: '100%',
  display: 'flex',
  justifyContent: 'space-between',
};

function App() {
  const [isActive, setActive] = React.useState(false);

  const handleHeaderClick = () =&gt; {
    alert('header click (e.g. navigate to home page)');
  };

  const handleButtonClick = (event) =&gt; {
    alert('button click (e.g. log out user)');

    if (isActive) {
      event.stopPropagation();
    }
  };

  return (
    &lt;&gt;
      &lt;div style={styleHeader} onClick={handleHeaderClick}&gt;
        &lt;div&gt;Header&lt;/div&gt;
        &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt;
          Log Out
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;button type=&quot;button&quot; onClick={() =&gt; setActive(!isActive)}&gt;
        Stop Propagation: {isActive.toString()}
      &lt;/button&gt;
    &lt;/&gt;
  );
}

export default App;
</code></pre>
<p>在不停止传播的情况下，注销按钮将触发它自己的事件处理程序，但也会触发标题上的事件处理程序，因为事件会冒泡到它上面。当 stopPropagation() 被激活时，单击注销按钮不会导致标题上的冒泡事件，因为该事件被阻止冒泡。</p>
<p>总之，只要有一个带有处理程序的元素嵌套在另一个带有处理程序的元素中，两者都在侦听相同的事件（这里：单击事件），使用 stopPropagation() 将有助于将事件委托给正确的处理程序（通过防止他们从冒泡）。</p>
<h2 id="target-currenttarget">target &amp;&amp; currentTarget</h2>
<p>当单击带有监听器（事件处理程序）的 HTML 元素时，你可以访问它的事件（在 React 中它是合成事件）。在其他属性中，事件可以访问表示导致事件的元素的目标属性。因此，如果按钮具有事件处理程序并且用户单击此按钮，则该事件将以按钮元素作为目标。</p>
<p>即使这个事件冒泡到另一个事件处理程序，如果一个嵌套元素导致了这个事件，那么目标仍然由这个嵌套元素表示。因此，在所有处理程序中，事件的目标都不会改变。</p>
<p>从事件处理程序到事件处理程序的变化是事件的 currentTarget，因为它表示实际事件处理程序正在运行的元素：</p>
<pre><code class="language-jsx">import * as React from 'react';

const style = {
  display: 'block',
  padding: '10px 30px',
  border: '1px solid black',
};

function App() {
  const handleDivClick = (event) =&gt; {
    alert(`
      &lt;div /&gt; \n
      event.target: ${event.target} \n
      event.currentTarget: ${event.currentTarget}
    `);
  };

  const handleSpanClick = (event) =&gt; {
    alert(`
      &lt;span /&gt; \n
      event.target: ${event.target} \n
      event.currentTarget: ${event.currentTarget}
    `);
  };

  return (
    &lt;div style={style} onClick={handleDivClick}&gt;
      &lt;span style={style} onClick={handleSpanClick}&gt;
        Click Me
      &lt;/span&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>通常你将与事件的目标进行交互，例如停止事件的传播或阻止默认行为。但是，有时你希望从正在运行的事件处理程序访问元素，因此你可以改用 currentTarget。</p>
<h2 id="react-中的事件捕获">React 中的事件捕获</h2>
<p>当谈到 JavaScript 中的事件冒泡时，不得不提的是存在事件捕获的概念。实际上两者都是依次发生的：当用户与元素交互时，DOM API 会向下遍历文档（捕获阶段）到目标元素（目标阶段），然后 DOM API 才会再次向上遍历（冒泡阶段）。<br>
<img src="https://umeimmense.github.io/post-images/1649935104214.png" alt="" loading="lazy"></p>
<p>在某些情况下，你可能希望在捕获阶段中的事件到达冒泡阶段之前对其进行拦截。然后，你可以使用 onClickCapture 而不是 onClick 来处理 JSX 中的单击事件，或者使用 addEventListener() 方法的第三个参数来激活在捕获阶段而不是冒泡阶段的监听：</p>
<pre><code class="language-jsx">function App() {
  const handleOuterClick = () =&gt; {
    alert('outer click');
  };

  const handleInnerClick = () =&gt; {
    alert('inner click');
  };

  React.useEffect(() =&gt; {
    const handleDocumentClick = () =&gt; {
      alert('document click');
    };

    document.addEventListener(
      'click',
      handleDocumentClick,
      true
    );

    return () =&gt; {
      document.removeEventListener(
        'click',
        handleDocumentClick,
        true
      );
    };
  }, []);

  return (
    &lt;div style={style} onClickCapture={handleOuterClick}&gt;
      &lt;div style={style} onClickCapture={handleInnerClick}&gt;
        Click Me
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>谈到“某些情况”有点含糊。因此，让我们回到前面的示例，其中我们将注销按钮嵌套在标题元素中。如果单击该按钮以不触发标头的事件处理程序，则该按钮将停止事件的传播。现在，如果你想通过在顶级文档级别引入分析跟踪来扩展此示例，你可以验证自己对于单击按钮，你不会收到分析跟踪，而只会收到标题，因为按钮阻止了从冒泡到文档的事件：</p>
<pre><code class="language-jsx">function App() {
  const handleHeaderClick = () =&gt; {
    alert('header click (e.g. navigate to home page)');
  };

  const handleButtonClick = (event) =&gt; {
    alert('button click (e.g. log out user)');

    // important: stops event from appearing
    // in the document's event handler
    event.stopPropagation();
  };

  React.useEffect(() =&gt; {
    const handleDocumentClick = (event) =&gt; {
      alert(`
        document clicked - \n
        run analytics for clicked element: ${event.target}
      `);
    };

    document.addEventListener('click', handleDocumentClick);

    return () =&gt; {
      document.removeEventListener('click', handleDocumentClick);
    };
  }, []);

  return (
    &lt;&gt;
      &lt;div style={styleHeader} onClick={handleHeaderClick}&gt;
        &lt;div&gt;Header&lt;/div&gt;
        &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt;
          Log Out
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>凭借我们对捕获阶段的了解，我们可以在实际用户交互冒泡之前对事件进行分析跟踪。在这种情况下，我们通过将第三个参数设置为 true（使用捕获阶段而不是冒泡阶段）在文档上添加事件侦听器：</p>
<pre><code class="language-jsx">function App() {
  const handleHeaderClick = () =&gt; {
    alert('header click (e.g. navigate to home page)');
  };

  const handleButtonClick = (event) =&gt; {
    alert('button click (e.g. log out user)');

    // important: stops event from appearing
    // in the document's event handler
    event.stopPropagation();
  };

  React.useEffect(() =&gt; {
    const handleDocumentClick = (event) =&gt; {
      alert(`
        document clicked - \n
        run analytics for clicked element: ${event.target}
      `);
    };

    document.addEventListener(
      'click',
      handleDocumentClick,
      true
    );

    return () =&gt; {
      document.removeEventListener(
        'click',
        handleDocumentClick,
        true
      );
    };
  }, []);

  return (
    &lt;&gt;
      &lt;div style={styleHeader} onClick={handleHeaderClick}&gt;
        &lt;div&gt;Header&lt;/div&gt;
        &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt;
          Log Out
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>当点击注销按钮时，捕获阶段从上到下遍历所有处理程序，从而触发文档级别的处理程序进行分析跟踪。然后它向下遍历元素到目标（此处：按钮），因为没有其他事件处理程序正在侦听捕获阶段（例如，通过使用 onClickCapture 代替）。从那里，事件冒泡并触发按钮的事件处理程序，阻止事件传播到标题的事件处理程序。<br>
<img src="https://umeimmense.github.io/post-images/1649935259980.png" alt="" loading="lazy"></p>
<p>在日常工作中，大多数开发人员使用冒泡阶段通过使用事件处理程序来拦截事件，并使用 stopPropagation() 方法阻止事件传播。因此，在开发人员的脑海中，总是有事件模型在 HTML 树中冒泡。然而，正如某些边缘情况所示，了解捕获阶段也是有意义的。</p>
<p>理解 JavaScript 中的事件冒泡对于在 React 中使用它至关重要。每当你有一个复杂的页面，其中带有事件处理程序的伪按钮被包装到其他伪按钮中时，就无法绕过本机 stopPropagation 方法。但是，请谨慎使用它，而不是默认使用它，否则从长远来看，你可能会遇到错误。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 中的浅比较是如何工作的？]]></title>
        <id>https://umeimmense.github.io/post/react-zhong-de-qian-bi-jiao-shi-ru-he-gong-zuo-de</id>
        <link href="https://umeimmense.github.io/post/react-zhong-de-qian-bi-jiao-shi-ru-he-gong-zuo-de">
        </link>
        <updated>2022-04-11T07:34:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>浅比较在 React 开发中无处不在。它在不同的流程中起着关键作用，也可以在 React 组件生命周期的多个地方找到。类组件是否应该更新的机制，React hooks 的依赖数组，通过 React.memo 进行记忆等等。</p>
<p>如果你曾经阅读过 React 的官方文档，你很可能已经经常看到浅比较这个术语。因此，本文将研究浅比较的概念，它到底是什么，它是如何工作的。</p>
<h2 id="什么是浅比较">什么是浅比较？</h2>
<p>理解浅层比较最直接的方法是深入研究它的实现。相应的代码可以在共享子包的 <a href="https://github.com/facebook/react/blob/main/packages/shared/shallowEqual.js">React Github</a> 项目中找到。例如下面的实现：</p>
<pre><code class="language-jsx">import is from './objectIs';
import hasOwnProperty from './hasOwnProperty';

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) {
    return true;
  }

  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (let i = 0; i &lt; keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}
</code></pre>
<p>这过程中发生了很多事情，所以让我们将其拆分并逐步执行该功能。</p>
<pre><code class="language-jsx">function shallowEqual(objA: mixed, objB: mixed): boolean {
	// ...
}
</code></pre>
<p>从函数定义开始，函数接受两个将相互比较的实体。与 TypeScript 不同，此代码使用 Flow 作为类型检查系统。两个函数参数都是使用特殊的混合 Flow 类型键入的，类似于 TypeScript 的未知数。它表明参数可以是任何类型的值，该函数将找出其余的并使其工作。</p>
<pre><code class="language-jsx">import is from './objectIs';

function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) {
    return true;
  }
	// ...
}
</code></pre>
<p>其次，首先使用来自 React 内部对象的 is 函数将函数参数相互比较。导入的函数只不过是 JavaScript 的 Object.is 函数的 polyfill 版本。这个比较函数基本上等同于常见的 === 运算符，但有两个例外：</p>
<ul>
<li>Object.is 认为相反的有符号零（+0 和 -0）不相等，而 === 认为它们相等。</li>
<li>Object.is 认为 Number.NaN 和 NaN 相等，而 === 认为它们不相等。</li>
</ul>
<p>基本上，第一个条件语句处理所有简单的情况：如果两个函数参数具有相同的值，对于原始类型，或引用相同的对象，对于数组和对象，那么它们被认为是浅比较相等的。</p>
<pre><code class="language-jsx">function shallowEqual(objA: mixed, objB: mixed): boolean {
	// ...

  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

	// ...
}
</code></pre>
<p>在处理了两个函数参数值相等或引用同一个对象的所有简单情况之后，我们想要进入更复杂的结构（对象和数组）。但是，如果任何一个参数是原始值，前面的条件语句仍然可以给我们留下原始值。</p>
<p>因此，为了确保我们从现在开始处理两个复杂的结构，代码会检查任一参数是否不是对象类型或等于 null。前一个检查确保我们正在处理对象或数组，而后一个检查是过滤掉空值，因为它们的类型也是对象。如果任一条件成立，我们肯定是在处理不相等的参数（否则前面的条件语句会将它们过滤掉），因此浅比较返回 false。</p>
<pre><code class="language-jsx">function shallowEqual(objA: mixed, objB: mixed): boolean {
	// ...

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

	// ...
}
</code></pre>
<p>现在可以确定我们只处理数组和对象，我们可以专注于浅比较这些数据结构。为此，我们必须深入研究复杂数据结构的值，并在两个函数参数之间进行比较。</p>
<p>但在我们这样做之前，我们可以通过一个简单的检查来确保两个参数具有相同数量的值。如果不是，则通过浅层比较可以保证它们不相等，这可以节省我们一些精力。为此，我们使用参数的键。对于对象，键数组将由实际键组成，而对于数组，键数组将由字符串中原始数组中占用的索引组成。</p>
<pre><code class="language-jsx">import hasOwnProperty from './hasOwnProperty';

function shallowEqual(objA: mixed, objB: mixed): boolean {
	// ...

  // Test for A's keys different from B.
  for (let i = 0; i &lt; keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}
</code></pre>
<p>作为最后一步，我们按键迭代两个函数参数的值，并逐个验证它们以确定它们是否等效。为此，代码使用在上一步中生成的键数组，使用 hasOwnProperty 检查键是否实际上是参数的属性，并使用与比较值之前相同的 Object.is 函数。</p>
<p>如果事实证明任何键在两个参数之间没有等效值，那么通过浅比较可以肯定它们不相等。因此，我们缩短了 for 循环，并从 shallowEqual 函数中返回 false。如果所有值都相等，那么我们可以通过浅比较调用函数参数相等并从函数返回 true。</p>
<h2 id="一些有趣的点">一些有趣的点</h2>
<p>现在我们了解了浅层比较及其背后的实现，我们可以从这些知识中学到一些有趣的东西：</p>
<ul>
<li>浅比较不使用严格相等、=== 运算符，而是使用 Object.is 函数。</li>
<li>通过浅比较，空对象和数组是等价的。</li>
<li>通过浅比较，以索引为键的对象等效于在各个索引处具有相同值的数组。例如。 { 0: 2, 1: 3 } 等价于 [2, 3]。</li>
<li>由于 Object.is 优于 === 的使用，通过浅比较，+0 和 -0 不等价，NaN 和 Number.NaN 也不等价。- 如果它们在复杂结构内进行比较，这也适用。<br>
虽然两个内联创建的对象（或数组）通过浅比较相等（{} 和 [] 浅相等），但具有嵌套内联对象的内联对象不相等（{ someKey: {} } 和 { someKey: [] } 不浅平等的）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Suspense 基本指南]]></title>
        <id>https://umeimmense.github.io/post/react-suspense-ji-ben-zhi-nan</id>
        <link href="https://umeimmense.github.io/post/react-suspense-ji-ben-zhi-nan">
        </link>
        <updated>2022-03-21T19:16:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在 React 18 中发布的另一个重要特性是 Suspense。如果你在之前使用过 React ，那么你就会知道 Suspense 功能并不是特别新。早在 2018 年，Suspense 作为 React 16.6 版的一部分作为实验性功能发布。然后，它主要针对与React.lazy。</p>
<p>但是现在，有了 React 18，Suspense 的正式发布就在我们面前。伴随着并发渲染的发布，Suspense 的真正威力终于解锁了。Suspense 和并发渲染之间的交互为改善用户体验开辟了广阔的世界。</p>
<p>但就像所有功能一样，就像并发渲染一样，从基础开始很重要。Suspense 到底是什么？为什么我们首先需要Suspense ？Suspense 如何解决这个问题？有什么好处？为了帮助你理解这些基础知识，本文将详细介绍这些问题，并为你提供有关 Suspense 的知识基础。</p>
<h2 id="什么是suspense">什么是Suspense？</h2>
<p>本质上，Suspense 是 React 开发人员向 React 指示组件正在等待数据准备好的一种机制。然后 React 知道它应该等待该数据被获取。同时，将向用户显示一个反馈，并且 React 将继续渲染应用程序的其余部分。数据准备好后，React 会返回到那个特定的 UI 并相应地更新它。</p>
<p>从根本上说，这听起来与 React 开发人员必须实现数据获取流程的当前方式没有太大区别：使用某种状态来指示组件是否仍在等待数据，useEffect开始获取数据，显示加载状态基于数据的状态，并在数据准备好后更新 UI。</p>
<p>但在实践中，Suspense 使这在技术上完全不同。与上面提到的数据获取流程相反，Suspense 与 React 深度集成，允许开发人员更直观地编排加载状态，并避免竞争条件。为了更好地理解这些细节，了解我们为什么需要 Suspense 很重要。</p>
<h2 id="为什么我们需要suspense">为什么我们需要Suspense？</h2>
<p>在没有 Suspense 的情况下，实现数据获取流程的主要方法有两种：<strong>渲染时获取</strong>和<strong>渲染后获取</strong>。但是，这些传统的数据获取流程存在一些问题。要了解 Suspense，我们必须深入研究这些流程的问题和局限性。</p>
<h3 id="渲染时获取">渲染时获取</h3>
<p>useEffect大多数人将使用和状态变量来实现前面提到的数据获取流程。这意味着只有在组件呈现时才开始获取数据。所有数据获取都发生在组件的副作用和生命周期方法中。</p>
<p>这种方法的主要问题是:组件仅在渲染时触发数据获取，异步特性迫使组件必须等待其他组件的数据请求。</p>
<p>假设我们有一个ComponentA获取一些数据并具有加载状态的组件。在内部，ComponentA还呈现另一个组件ComponentB，该组件也自己执行一些数据获取。但是由于数据获取的实现方式，ComponentB只有在渲染时才开始获取数据。这意味着它必须等到ComponentA完成获取数据然后渲染ComponentB。</p>
<p>这导致了瀑布式方法，其中组件之间的数据获取顺序发生，这实质上意味着它们相互阻塞。</p>
<pre><code class="language-jsx">function ComponentA() {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    fetchAwesomeData().then(data =&gt; setData(data));
  }, []);

  if (user === null) {
    return &lt;p&gt;Loading data...&lt;/p&gt;;
  }

  return (
    &lt;&gt;
      &lt;h1&gt;{data.title}&lt;/h1&gt;
      &lt;ComponentB /&gt;
    &lt;/&gt;
  );
}

function ComponentB() {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    fetchGreatData().then(data =&gt; setData(data));
  }, []);

  return data === null ? &lt;h2&gt;Loading data...&lt;/h2&gt; : &lt;SomeComponent data={data} /&gt;;
}
</code></pre>
<h3 id="渲染后获取">渲染后获取</h3>
<p>为了防止组件之间数据获取的顺序阻塞，一种替代方法是尽早开始所有数据获取。因此，与其让组件负责处理渲染时的数据获取，而且数据请求都单独发生，而是在树开始渲染之前启动所有请求。</p>
<p>这种方法的优点是所有数据请求都是一起发起的，因此ComponentB不必等待ComponentA完成。这解决了组件顺序阻塞彼此数据流的问题。但是，它引入了另一个问题，我们必须等待所有数据请求完成，然后才能为用户呈现任何内容。可以想象，这不是最佳体验。</p>
<pre><code class="language-jsx">// Start fetching before rendering the entire tree
function fetchAllData() {
  return Promise.all([
		fetchAwesomeData(),
		fetchGreatData()
  ]).then(([awesomeData, greatData]) =&gt; ({
    awesomeData,
		greatData
  }))
}

const promise = fetchAllData();

function ComponentA() {
  const [awesomeData, setAwesomeData] = useState(null);
  const [greatData, setGreatData] = useState(null);

  useEffect(() =&gt; {
    promise.then(({ awesomeData, greatData }) =&gt; {
      setAwesomeData(awesomeData);
      setGreatData(greatData);
    });
  }, []);

  if (user === null) {
    return &lt;p&gt;Loading data...&lt;/p&gt;;
  }

  return (
    &lt;&gt;
      &lt;h1&gt;{data.title}&lt;/h1&gt;
      &lt;ComponentB /&gt;
    &lt;/&gt;
  );
}

function ComponentB({data}) {
  return data === null ? &lt;h2&gt;Loading data...&lt;/h2&gt; : &lt;SomeComponent data={data} /&gt;;
}
</code></pre>
<h2 id="suspense-如何解决数据获取问题">Suspense 如何解决数据获取问题？</h2>
<p>从本质上讲，**fetch-on-render **和 <strong>fetch-then-render</strong> 的主要问题归结为我们试图强制同步两个不同的流程，即数据获取流程和 React 生命周期。借助 Suspense，我们获得了一种不同类型的数据获取方法，即所谓的 <strong>render-as-you-fetch</strong> 方法。</p>
<pre><code class="language-jsx">const specialSuspenseResource = fetchAllDataSuspense();

function App() {
  return (
    &lt;Suspense fallback={&lt;h1&gt;Loading data...&lt;/h1&gt;}&gt;
      &lt;ComponentA /&gt;
      &lt;Suspense fallback={&lt;h2&gt;Loading data...&lt;/h2&gt;}&gt;
        &lt;ComponentB /&gt;
      &lt;/Suspense&gt;
    &lt;/Suspense&gt;
  );
}

function ComponentA() {
  const data = specialSuspenseResource.awesomeData.read();
  return &lt;h1&gt;{data.title}&lt;/h1&gt;;
}

function ComponentB() {
	const data = specialSuspenseResource.greatData.read();
  return &lt;SomeComponent data={data} /&gt;;
}
</code></pre>
<p>与之前实现的不同之处在于它允许组件在 React 到达它的那一刻启动数据获取。这甚至发生在组件渲染之前，并且 React 并没有就此停止。然后它继续评估组件的子树，并在等待数据获取完成时继续尝试渲染它。</p>
<p>这意味着 Suspense 不会阻塞渲染，这意味着子组件不必等待父组件完成后再发起其数据获取请求。React 尝试尽可能多地渲染，同时启动适当的数据获取请求。请求完成后，React 将重新访问相应的组件并使用新接收的数据相应地更新 UI。</p>
<h2 id="suspense有什么好处">Suspense有什么好处？</h2>
<ul>
<li>尽早开始获取数据。Suspense 引入的 render-as-you-fetch 方法最大和最直接的好处是数据获取尽早启动。这意味着用户必须等待的时间更少，应用程序更快，这对任何前端应用程序都是普遍有益的。</li>
<li>更直观的加载状态。使用 Suspense，组件不必再包含大量的 if 语句或单独跟踪状态来实现加载状态。相反，加载状态被集成到它所属的组件本身中。这使得组件更直观，通过保持加载代码接近相关代码，并且更可重用，因为加载状态包含在组件中。</li>
<li>避免竞争条件。我没有在本文中深入讨论的现有数据获取实现的问题之一是竞争条件。在某些情况下，传统的 fetch-on-render 和 fetch-then-render 实现可能会导致竞争条件，具体取决于时间、用户输入和参数化数据请求等不同因素。主要的潜在问题是我们试图强制同步两个不同的进程，React 和数据获取。但是使用 Suspense，这可以更优雅、更集成地完成，从而避免了上述问题。</li>
<li>更集成的错误处理。使用 Suspense，我们基本上已经为数据请求流创建了边界。最重要的是，由于 Suspense 使其与组件代码的集成更加直观，它允许 React 开发人员还为 React 代码和数据请求实现更集成的错误处理。</li>
</ul>
<h2 id="总结">总结</h2>
<p>React Suspense 已经被关注了 3 年多。但是随着 React 18 的发布，官方发布的时间越来越近了。除了并发渲染，它将是作为 React 版本的一部分发布的最大功能之一。就其本身而言，它可以将数据获取和加载状态实现提升到一个新的直观和优雅水平。</p>
<p>为了帮助你了解 Suspense 的基础知识，本文介绍了几个对其很重要的问题和方面。这涉及到 Suspense 是什么，为什么我们首先需要像 Suspense 这样的东西，它如何解决某些数据获取问题以及 Suspense 带来的所有好处。</p>
]]></content>
    </entry>
</feed>