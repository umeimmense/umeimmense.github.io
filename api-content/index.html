{"posts":[{"title":"JavaScript 中的稀疏数组与密集数组的区别？","content":"前言 JavaScript 中的数组非常易于使用。但是，你应该注意一个细微差别：某些数组中可能存在漏洞。 在这篇文章中，我将描述 JavaScript 中稀疏数组和密集数组之间的区别。此外，你将找到创建稀疏数组的常用方法。 密集数组 JavaScript 中的数组是一个对象，表示元素的有序集合。数组中的元素有一个确切的顺序。你可以使用索引访问数组的第 n 项。 const names = ['Batman', 'Joker', 'Bane']; console.log(names[0]); // logs 'Batman' console.log(names[1]); // logs 'Joker' console.log(names[2]); // logs 'Bane' console.log(names.length); // logs 3 names[0] 访问索引 0（第一个元素）处的数组项。 数组还有一个属性长度，它表示数组中的项数。在前面的示例中，names.length 为 3，因为数组中的元素个数为 3。 上面创建的名称数组是一个密集数组：这意味着它包含每个索引处的元素，从 0 开始，直到 names.length - 1。 我们定义这是一个函数 isDense(array) ，用于确定数组是否在每个索引处都有元素： function isDense(array) { for (let index = 0; index &lt; array.length; index++) { if (!(index in array)) { return false; } } return true; } const names = ['Batman', 'Joker', 'Bane']; console.log(isDense(names)); // logs true 其中 index in array 确定数组是否在索引位置有一个元素。 这是一个有趣的问题：JavaScript 中的所有数组都是密集的吗？或者当 isDense(array) 返回 false 时可能有数组？ 稀疏数组 有些情况下 JavaScript 数组中可能存在漏洞。这样的数组被命名为稀疏数组。 例如，如果你使用数组字面量但省略指示项就会创建了一个稀疏数组： const names = ['Batman', , 'Bane']; console.log(names[0]); // logs 'Batman' console.log(names[1]); // logs undefined console.log(names[2]); // logs 'Bane' console.log(isDense(names)); // logs false ['Batman', , 'Bane'] 数组文字创建一个稀疏数组，在 1 索引处有一个缺失。如果你访问这个位置的值——names[1]——它的计算结果是 undefined。 要明确检查特定索引处是否有空缺，你可以这样写index in names中： const names = ['Batman', , 'Bane']; // No hole console.log(0 in names); // logs true // Hole console.log(1 in names); // logs false 当然，如果你在稀疏数组上运行 isDense() 它将返回 false： const names = ['Batman', , 'Bane']; console.log(isDense(names)); // logs false 现在你对稀疏数组有所了解。但是创建稀疏数组的常用方法是什么？ 创建稀疏数组的方法 数组字面量 在使用数组字面量时省略一个值会创建一个稀疏数组（注意记录器数组中的空词）： const names = ['Batman', , 'Bane']; console.log(names); // logs ['Batman', empty, 'Bane'] Array() 构造函数 调用 Array(length) 或 new Array(length)（带有一个数字参数）会创建一个完全稀疏的数组： const array = Array(3); console.log(isDense(array)); // logs false console.log(array); // logs [empty, empty, empty] 删除操作符 在数组上使用 delete array[index]运算符时： const names = ['Batman', 'Joker', 'Bane']; delete names[1]; console.log(isDense(names)); // logs false console.log(names); // logs ['Batman', empty, 'Bane'] 最初，names数组是密集的。 但是执行 delete names[1]会删除索引 1 处的元素并使 names 数组变得稀疏。 增加length属性 如果你增加数组的长度属性，那么你也会在数组中创建空缺： const names = ['Batman', 'Joker', 'Bane']; names.length = 5; console.log(isDense(names)); // logs false console.log(names); // logs ['Batman', 'Joker', 'Bane', empty, empty] 最初names数组有3个元素，是一个密集数组。 但是，将names.length 增加到 5 个元素会在 3 和 4 个索引处创建 2 个孔。 附带说明一下，减少 length 属性不会创建稀疏数组，而是从数组末尾删除元素。 数组方法和稀疏数组 稀疏数组的一个问题是许多数组内置方法只是跳过稀疏数组中的空缺。 例如， array.forEach(eachFunc) 不会在孔上调用 eachFunc ： const names = ['Batman', , 'Bane']; names.forEach(name =&gt; { console.log(name); }); // logs 'Batman' // logs 'Bane' 以同样的方式 array.map(mapperFunc)、array.filter(predicateFunc) 和更多函数跳过这些空缺位置。如果你不小心创建了一个稀疏数组，可能很难理解为什么数组方法不能按预期工作。 总结 在 JavaScript 中，数组可以是密集的或稀疏的。 如果每个索引处都有从 0 开始直到 array.length - 1 的元素，则数组是密集的。否则，如果任何索引处至少缺少一项，则数组是稀疏的。 虽然你不会过多地处理稀疏数组，但你应该了解可以创建一个数组的情况： 跳过数组 [1, , 3] 中的值时 使用 Array(length) 时 使用delete array[index] 当增加 array.length 属性时 稀疏数组的问题在于某些 JavaScript 函数（如 array.forEach()、array.map() 等）在迭代数组项时会跳过空缺值。 ","link":"https://umeimmense.github.io/post/javascript-zhong-de-xi-shu-shu-zu-yu-mi-ji-shu-zu-de-qu-bie"},{"title":"JavaScript 中的 Tree 使用父指针高效遍历","content":"前言 在本系列的第一部分中，我们研究了遍历二叉树的递归和迭代方法。 在实际应用中，树节点有一个父节点是很常见的：一个指向父节点的指针，因此也称为父指针。让我们以浏览器中的 DOM 为例。假设我们使用以下命令选择任何节点： const element = document.querySelector(&quot;#id&quot;) 在本文中，我们将研究如何使用这些父指针来提高遍历效率。我稍后会解释我所说的“更高效”是什么意思。在下一篇文章中，我们还将了解如何使用此处学到的经验教训从头开始创建 myQuery 库。 更新节点定义 首先，我们需要更新Node 函数 function Node(value){ this.value = value this.left = null this.right = null this.parent = null // added parent field } 现在让我们看看如何使用这个新的 Node 定义来创建一个类似的树，就像我们在上一篇文章中所做的那样。 const root = new Node(2) const left = new Node(1) root.left = left left.parent = root const right = new Node(3) root.right = right right.parent = root 我们只需要确保父字段指向父节点。这是我们使用上述代码获得的最终树的视觉参考： ##寻找后继节点 前序 假设每个节点都有一个parent指针，如何找出二叉树中任何节点的 preOrder 后继？ 让我们试着分析一下这个问题： 首先，我们在这里处理 preOrder，这意味着我们正在寻找以下顺序： root -&gt; left -&gt; right 这意味着如果我们已经在当前节点，我们想寻找左子节点作为后继节点。 如果根本没有左子节点怎么办？那么在这种情况下，我们会寻找合适的节点，如果在有左子节点，那就是后继节点。 如果没有左子节点或右子节点，那么我们需要回溯（继续向上走向父节点）。我们一直回溯，直到通过它的右子节点到达父级（因为这意味着 preOrder 对于父级下的整个子树是完整的，根据 #1 的定义）。 最终算法实现就是这样： function preOrderSuccessor(node){ if(!node) return if(node.left) return node.left if(node.right) return node.right let parent = node.parent while(parent &amp;&amp; parent.right === node) { node = node.parent parent = parent.parent } if(!parent) return null // we backtracked till root, so no successor return parent.right } ","link":"https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li"},{"title":"JavaScript 中的 Tree","content":"前言 Tree是一种有趣的数据结构。它在各个领域都有广泛的应用。例如： DOM 是一种Tree状数据结构 我们操作系统中的目录和文件可以表示为Tree 家庭层次结构可以表示为Tree。 Tree的许多变体（如堆、BST 等）可用于解决与调度、图像处理、数据库等相关的问题。许多复杂的问题乍一看似乎与Tree无关，但可以被表示为一个Tree的问题。我们也会（在本系列的后面部分）解决这些问题，从而了解Tree如何使看似复杂的问题更容易理解和解决。 简介 二叉树实现节点非常简单 function Node(value){ this.value = value this.left = null this.right = null } // usage const root = new Node(2) root.left = new Node(1) root.right = new Node(3) 所以这几行代码将为我们创建一个二叉树，如下所示： 2 / \\ / \\ 1 3 / \\ / \\ null null null null 遍历 让我们从尝试遍历这些连接的树节点（或一棵树）开始。正如我们可以遍历数组一样，如果我们也可以“遍历”树节点。然而，树不是像数组那样的线性数据结构，所以遍历这些的方法不止一种。我们可以将遍历方法大致分为以下几类： 广度优先遍历 深度优先遍历 广度优先遍历（BFS） 在这种方法中，我们逐层遍历树。我们将从根开始，然后覆盖它的所有子级，然后覆盖所有 2 级子级，依此类推。例如对于上面的树，遍历会导致这样的结果： 2 / \\ / \\ 1 3 / \\ / \\ null null null null 2，1，3 下面是一个稍微复杂的树的插图，使这更容易理解： 为了实现这种形式的遍历，我们可以使用队列（先进先出）数据结构。以下是整个算法的过程： 初始化一个包含 root 的队列 从队列中删除第一项 将弹出项的左右节点推入队列 重复步骤 2 和 3，直到队列为空 下面是这个算法在实现后的样子： function walkBFS(root){ if(root === null) return const queue = [root] while(queue.length){ const item = queue.shift() // do something console.log(item) if(item.left) queue.push(item.left) if(item.right) queue.push(item.right) } } 我们可以稍微修改上面的算法实现为： function walkBFS(root){ if(root === null) return const queue = [root], ans = [] while(queue.length){ const len = queue.length, level = [] for(let i = 0; i &lt; len; i++){ const item = queue.shift() level.push(item) if(item.left) queue.push(item.left) if(item.right) queue.push(item.right) } ans.push(level) } return ans } 深度优先遍历（DFS） 在 DFS 中，我们取一个节点并继续探索它的子节点，直到深度耗尽为止。它可以通过以下方式之一完成： root node -&gt; left node -&gt; right node // pre-order traversal left node -&gt; root node -&gt; right node // in-order traversal left node -&gt; right node -&gt; root node // post-order traversal 所有这些遍历技术都可以递归和迭代实现。让我们进入实现细节： 前序遍历(Pre-Order traversal) 分析 root node -&gt; left node -&gt; right node 技巧: 我们可以使用这个简单的技巧来手动找出任何树的前序遍历：从根节点开始遍历整棵树，保持自己在左边。 实现 递归 function walkPreOrder(root){ if(root === null) return // do something here console.log(root.val) // recurse through child nodes if(root.left) walkPreOrder(root.left) if(root.right) walkPreOrder(root.right) } 迭代 前序遍历的迭代方法与 BFS 非常相似，不同之处在于我们使用堆栈而不是队列，并且我们首先将右节点推入堆栈： function walkPreOrder(root){ if(root === null) return const stack = [root] while(stack.length){ const item = stack.pop() // do something console.log(item) // Left child is pushed after right one, since we want to print left child first hence it must be above right child in the stack if(item.right) stack.push(item.right) if(item.left) stack.push(item.left) } } 中序遍历(In-Order traversal) 分析 下面是一棵树的中序遍历的过程： left node -&gt; root node -&gt; right node 技巧 我们可以使用这个简单的技巧来手动找出任何树的中序遍历：在树的底部水平放置一个平面镜，并获取所有节点的投影 实现 递归function walkInOrder(root){ if(root === null) return if(root.left) walkInOrder(root.left) // do something here console.log(root.val) if(root.right) walkInOrder(root.right) } - 迭代 这个算法乍一看可能有点神秘。但它相当直观。让我们这样看：在中序遍历中，最左边的孩子节点首先被打印，然后是根，然后是孩子节点。所以首先想到的是想出这样的东西： ```javascript const curr = root while(curr){ while(curr.left){ curr = curr.left // get to leftmost child } console.log(curr) // print it curr = curr.right // now move to right child } 在上述方法中，我们无法回溯，即返回导致最左侧节点的父节点。所以我们需要一个堆栈来记录这些。因此，我们修订后的方法可能如下所示： const stack = [] const curr = root while(stack.length || curr){ while(curr){ stack.push(curr) // keep recording the trail, to backtrack curr = curr.left // get to leftmost child } const leftMost = stack.pop() console.log(leftMost) // print it curr = leftMost.right // now move to right child } 现在我们可以使用上面的方法来制定最终的迭代算法： function walkInOrder(root){ if(root === null) return const stack = [] let current = root while(stack.length || current){ while(current){ stack.push(current) current = current.left } const last = stack.pop() // do something console.log(last) current = last.right } } 后序遍历（Post-Order traversal） 分析 下面是一棵树的中序遍历的过程： left node -&gt; right node -&gt; root node 技巧 对于任何树的快速手动后序遍历：一个接一个地提取所有最左边的孩子节点。 实现 让我们深入研究这种遍历的实际实现。 递归 function walkPostOrder(root){ if(root === null) return if(root.left) walkPostOrder(root.left) if(root.right) walkPostOrder(root.right) // do something here console.log(root.val) } 迭代 我们已经有了用于前序遍历的迭代算法。我们可以用那个吗？因为后序遍历似乎只是前序遍历的反向。让我们来看看： // PreOrder: root -&gt; left -&gt; right // Reverse of PreOrder: right -&gt; left -&gt; root // But PostOrder is: left -&gt; right -&gt; root 从上面分析可见有细微的差别。我们可以通过稍微修改我们的 前序遍历算法然后反转它应该给出 后序遍历结果来适应这一点。总体算法将是： // record result using root -&gt; right -&gt; left // reverse result left -&gt; right -&gt; root 使用与上述迭代前序遍历算法类似的方法，使用临时堆栈。 唯一的区别是 root -&gt; right -&gt; left 而不是 root -&gt; left -&gt; right 结果将遍历序列记录在一个array 结果的反转就是后序遍历 function walkPostOrder(root){ if(root === null) return [] const tempStack = [root], result = [] while(tempStack.length){ const last = tempStack.pop() result.push(last) if(last.left) tempStack.push(last.left) if(last.right) tempStack.push(last.right) } return result.reverse() } ","link":"https://umeimmense.github.io/post/javascript-zhong-de-tree"},{"title":"初探 React Router 6 ","content":"前言 不久前，React Router 库更新到了第 6 版，随之而来的是一些有趣的变化，本文将讲述React Router 6的一些新特性及使用的案例。 接下来是一些准备工作： 首先需要创建一个新的 React 项目（例如 create-react-app）。然后，按照官方文档安装 React Router。 yarn add react-router-dom@latest 我们这里安装的是6.0.2版本。 2. 第一个实现细节将告诉我们的 React 应用程序我们想要使用 React Router。因此，在 React 项目的顶级文件（例如 index.js）中导入 Router 组件，其中 React 使用 ReactDOM API 挂载到 HTML： import React from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter } from 'react-router-dom'; import App from './App'; ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ); 从这里开始，我们将在 App.js 文件中继续我们的实现。 匹配路由 首先，我们将使用 React Router 的 Link 组件在我们的 App 组件中实现导航。我不建议使用内联样式，因此请根据你的 React 项目选择合适的样式策略和样式方法： import { Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; 当你在浏览器中启动 React 应用程序时，你应该能够单击两个 Link 组件，这些组件应该将你导航到各自的路由。单击这些链接时，可通过检查浏览器的当前 URL 来确认。接下来，我们需要使用 React Router 的 Route 组件将路由映射到实际渲染： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; 你可以通过检查它们各自的 to 和 path 属性来查看 Link 和 Route 组件之间的直接匹配。当路由匹配时，每个 Route 组件都会渲染一个 React 元素。由于我们在这里渲染一个 React 元素，我们也可以传递 React props。缺少的是相应功能组件的声明： const Home = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/main&gt; ); }; const Users = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/main&gt; ); }; 返回浏览器时，你应该能够在看到 Home 和 Users 组件的同时从一个页面导航到另一个页面（此处：从 /home 到 /users 路由）。基本上这就是 React Router 的本质：设置 Link 组件并将它们与 Route 组件匹配。链接与路由是多对一的关系，因此你的应用程序中可以有多个链接链接到同一个路由。 布局路由、索引路由、无匹配路由 接下来，你将看到新的 Home 和 Users 组件如何共享相同的布局。作为 React 开发人员，直觉上我们会从 Home 和 Users 组件中提取一个带有样式的新组件，以避免重复。在这个新组件中，我们将使用 React 的 children 属性将组件组合在一起。第一步，将样式提取到它自己的组件中： const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = ({ children }) =&gt; { return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;; }; 其次，在 App 组件中渲染它。通过使用 React 的子级，Layout 组件应该渲染匹配的封闭子路由： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Layout&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Layout&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = ({ children }) =&gt; { return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;; }; 但是你会看到这在 React Router 中是不允许的，你会得到一个异常说： 的所有组件子项必须是 或 &lt;React.Fragment&gt;。解决此问题的一种常见方法是在每个组件中单独使用 Layout 组件（类似于我们之前使用的）或在每个 Route 组件中（如下例所示）： const App = () =&gt; { return ( &lt;&gt; ... &lt;Routes&gt; &lt;Route path=&quot;home&quot; element={&lt;Layout&gt;&lt;Home /&gt;&lt;/Layout&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Layout&gt;&lt;Users /&gt;&lt;/Layout&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 然而，这给 React 应用程序增加了不必要的冗余。因此，我们将使用所谓的 Layout Route，而不是复制 Layout 组件，它不是实际的路由，而只是一种方法，可以让一组 Route 中的每个 Route 组件的元素具有相同的周围样式： const App = () =&gt; { return ( &lt;&gt; ... &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 如你所见，可以将 Route 组件嵌套在另一个 Route 组件中——而前者成为所谓的嵌套路由。现在不再在 Layout 组件中使用 React 的子组件，而是使用 React Router 的 Outlet 组件作为等效组件： import { Routes, Route, Outlet, Link } from 'react-router-dom'; ... const Layout = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;Outlet /&gt; &lt;/main&gt; ); }; 本质上，Layout 组件中的 Outlet 组件插入了父路由（这里：Layout 组件）的匹配子路由（这里：Home 或 Users 组件）。毕竟，使用 Layout Route 可以帮助你为集合中的每个 Route 组件提供相同的布局（例如，CSS 样式，HTML 结构）。 从这里开始，你可以更进一步，将 App 组件的所有实现细节（标题、导航）移动到这个新的 Layout 组件中。此外，我们可以与 NavLink 组件交换链接，以实现所谓的活动链接——向用户显示当前活动的路线。因此，当将新的 NavLink 组件与函数一起使用时，我们可以访问其style和 className props中的 isActive 标志： import { Routes, Route, Link, NavLink, Outlet } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = () =&gt; { const style = ({ isActive }) =&gt; ({ fontWeight: isActive ? 'bold' : 'normal', }); return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;NavLink to=&quot;/home&quot; style={style}&gt;Home&lt;/NavLink&gt; &lt;NavLink to=&quot;/users&quot; style={style}&gt;Users&lt;/NavLink&gt; &lt;/nav&gt; &lt;main style={{ padding: '1rem 0' }}&gt; &lt;Outlet /&gt; &lt;/main&gt; &lt;/&gt; ); }; 接下来你可能已经注意到这个 React 应用程序缺少一个基本路由。虽然我们有 /home 和 /users 路由，但没有 / 路由。你也会在浏览器的开发人员工具中看到此警告：没有路由匹配位置“/”。因此，每当用户访问 / 路由时，我们都会创建一个所谓的索引路由作为回退。此回退路由的元素可以是新组件或任何已匹配的路由（例如，Home 应为路由 / 和 /home 呈现，如下例所示）： const App = () =&gt; { return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 当父路由匹配但没有子路由匹配时，你可以将索引路由视为默认路由。接下来，如果用户导航到不匹配的路由（例如 /about），我们将添加一个所谓的 No Match Route（也称为 Not Found Route），它相当于网站的 404 页面： const App = () =&gt; { return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; const NoMatch = () =&gt; { return (&lt;p&gt;There's nothing here: 404!&lt;/p&gt;); }; 到目前为止，在使用 Routes 组件作为 Route 组件集合的容器时，通过使用 Layout Routes、Index Routes 和 No Match Routes 展示了 React Router 的其他最佳实践。如你所见，也可以将 Route 组件嵌套到 Route 组件中。\b下面我们接着了解有关嵌套路由的更多信息。 动态且嵌套的路由 接下来我们将用实现细节来装饰用户组件。首先，我们将在我们的 App 组件中初始化一个项目列表（这里是：用户）。该列表只是示例数据，但它也可以在 React 中从远程 API 获取。其次，我们将用户作为props传递给用户组件： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; Users 组件成为 React 中的列表组件，因为它遍历每个用户并为其返回 JSX。在这种情况下，它不仅仅是一个列表，因为我们将 React Router 的 Link 组件添加到组合中。 Link 组件中的相对路径提示相应的动态（此处：/user.id）尚未嵌套（此处：/{user.id}）尚未嵌套（此处：/user.id）尚未嵌套（此处：/{user.id} 嵌套在 /users 中）路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={`/users/${user.id}`}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 通过拥有这个新的动态嵌套路由，我们需要在 App 组件中为它创建一个匹配的嵌套路由组件。首先，由于它是 /users 路由的所谓嵌套路由（或子路由），我们可以将它嵌套在相应的父路由组件中。此外，由于它是所谓的动态路由，它使用定义为 :userId 的动态路由，而用户的标识符则动态匹配（例如，id 为 '1' 的用户将与 /users/1 匹配）： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 之前，当我们介绍将 /home 和 /users 路由作为其子路由的父布局路由时，我们已经了解了嵌套路由。当我们进行此更改时，我们必须使用父路由中的 Outlet 组件来渲染匹配的子路由。同样的情况在这里再次发生，因为用户组件也必须渲染它的嵌套路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt;...&lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 接下来，我们将声明缺少的 User 组件，只要用户的标识符在 URL 中匹配，该组件就会通过 Users 组件中的 Outlet 嵌套。因此，我们可以使用 React Router 的 useParams Hook 从 URL 中获取相应的 userId（等于 :userId）： import { ... useParams, } from 'react-router-dom'; ... const User = () =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 我们再次看到了如何通过将一个 Route 组件（或多个 Route 组件）嵌套在另一个 Route 组件中来创建嵌套路由。前者是嵌套的子路由，后者是渲染封闭组件的父路由，该组件必须使用 Outlet 组件来渲染实际匹配的子路由。 我们还看到了如何通过在路由的路径属性（例如：userId）中使用冒号来创建动态路由。本质上， :userId 充当任何标识符的星号。在我们的例子中，我们使用 Link 组件将用户导航到 /users/:userId 路由，其中​​ :userId 代表实际用户的标识符。最后，我们总是可以通过使用 React Router 的 useParams Hook 从 URL 中获取动态路径（称为参数或 params）。 React Router中的相关链接 最新版本的 React Router 带有所谓的相对链接。我们将通过查看用户组件及其用于链接组件的绝对 /users/${user.id} 路径来研究这个概念。在之前版本的 React Router 中，需要指定整个路径。但是，在此版本中，你可以仅使用嵌套路径作为相对路径： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 由于 Users 组件用于 /users 路由，因此 Users 组件中的 Link 知道其当前位置，不需要创建绝对路径的整个顶级部分。相反，它知道 /users 并且只是附加 :userId 作为它的相对路径。 声明式和程序式导航 到目前为止，我们只在使用 Link 或 NavLink 组件时使用了声明式导航。但是，在某些情况下，你希望能够通过 JavaScript 以编程方式导航用户。我们将通过实现一个可以在 User 组件中删除用户的功能来展示这个场景。在删除后，用户应该从 User 组件导航到 Users 组件（从 /users/:userId 到 /users）。 我们将通过使用 React 的 useState Hook 创建一个有状态的 users 值来开始这个实现，然后实现一个事件处理程序，该处理程序使用标识符从用户中删除用户： import * as React from 'react'; ... const App = () =&gt; { const [users, setUsers] = React.useState([ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]); const handleRemoveUser = (userId) =&gt; { setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId)); }; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User onRemoveUser={handleRemoveUser} /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 在我们将事件处理程序作为回调处理程序传递给 User 组件后，我们可以在那里使用它作为内联处理程序来通过标识符删除特定用户： const User = ({ onRemoveUser }) =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; onRemoveUser(userId)}&gt; Remove &lt;/button&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 一旦用户被删除，我们可以使用 React Router 的 useNavigate Hook，它允许我们以编程方式将用户导航到另一个路由（这里：/users）： import * as React from 'react'; import { ... useNavigate, } from 'react-router-dom'; const App = () =&gt; { const navigate = useNavigate(); const [users, setUsers] = React.useState([ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]); const handleRemoveUser = (userId) =&gt; { setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId)); navigate('/users'); }; return (...); }; 在这种情况下，删除操作是同步发生的，因为用户只是客户端的一个有状态值。但是，如果用户是数据库中的实体，则必须发出异步请求才能删除它。一旦这个操作成功（例如：promise是 resolved时），用户就会被导航到 /users 路由。你可以通过在 React 中设置一个虚假的 API 来自己尝试这个场景，而不使用实际的服务器。 搜索参数 浏览器中的 URL 不仅包含路径，还包含一个可选的查询字符串（在 React Router 中称为搜索参数），它以键/值对的形式出现在 ? URL 中的分隔符。例如，/users?name=robin 将是一个带有一对搜索参数的 URL，其中键是名称，值是 robin。以下示例将其显示为实现： import * as React from 'react'; import { ... useSearchParams, } from 'react-router-dom'; ... const Users = ({ users }) =&gt; { const [searchParams, setSearchParams] = useSearchParams(); const searchTerm = searchParams.get('name') || ''; const handleSearch = (event) =&gt; { const name = event.target.value; if (name) { setSearchParams({ name: event.target.value }); } else { setSearchParams({}); } }; return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;input type=&quot;text&quot; value={searchTerm} onChange={handleSearch} /&gt; &lt;ul&gt; {users .filter((user) =&gt; user.fullName .toLowerCase() .includes(searchTerm.toLocaleLowerCase()) ) .map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt;{user.fullName}&lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 首先，我们使用 React Router 的 useSearchParams Hook 从 URL 中读取当前搜索参数（请参阅 searchParams 上的 get() 方法），同时还将搜索参数写入 URL（请参阅 setSearchParams() 函数）。虽然我们使用前者按键获取搜索参数（此处：“name”）来控制输入字段，但我们使用后者在 URL 中按键设置搜索参数。在输入字段中键入。在其核心，React Router 的 useSearchParams Hook 与 React 的 useState Hook 相同，区别在于该状态是 URL 状态，而不是 React 中的本地状态。最后我们使用搜索参数来过滤用户的实际列表以完成此功能。 毕竟，在你的 URL 中包含搜索参数可以让你与他人共享更具体的 URL。如果你在一个搜索黑色鞋子的电子商务网站上，你可能希望共享整个 URL（例如 myecommerce.com/shoes?color=black）而不仅仅是路径（例如 myecommerce.com/shoes）。 总结 React Router 是 React 最常用的第三方库之一。它的核心功能是将 Link 组件映射到 Route 组件，这使开发人员无需向 Web 服务器发出请求即可实现客户端路由。然而，除了这个核心功能之外，它还是一个成熟的路由库，它支持声明式嵌套路由、动态路由、导航、活动链接，还可以通过 URL 进行编程导航和搜索。 参考 react-router CRA ","link":"https://umeimmense.github.io/post/chu-tan-react-router-6"},{"title":"JavaScript 引擎如何提升其运行时的性能？","content":"前言 JavaScript 是一项令人印象深刻的技术。不是因为它设计得特别好，也不是因为世界上几乎所有可以访问互联网的设备都执行 JavaScript 程序。相反，JavaScript 令人印象深刻，是因为它的几乎每一个特性都使它成为优化的噩梦，但是它速度很快。 javascript 为什么会执行速度很快呢？这就是我们需要去深入探究的问题。 在本文中，我们将仔细研究不同 JavaScript 引擎用于实现良好运行时性能的一些技术，在研究过程中省略了一些细节，并简化了事情。本文的目标不是让您了解事物的确切运作方式，而是让您了解并理解引擎如何提升其运行时的一些基本知识。 执行模型 当您的浏览器下载 JavaScript 时，其首要任务是让它尽快运行。它通过将代码转换为字节码、虚拟机指令，然后将其移交给理解如何执行它们的解释器或虚拟机来实现。 您可能会问为什么浏览器会将 JavaScript 转换为虚拟机指令而不是实际的机器指令？这是个好问题。事实上，直到最近，V8（Chrome 的 JavaScript 引擎）还一直在做直接转换为机器指令的工作。 特定编程语言的虚拟机通常是更容易编译的目标，因为它与源语言的关系更密切。实际的机器有一个更通用的指令集，因此需要更多的工作来翻译编程语言以很好地处理这些指令。这种困难意味着编译需要更长的时间，同时也意味着 JavaScript 开始执行需要更长的时间。 例如，理解 JavaScript 的虚拟机也可能理解 JavaScript 对象。因此，执行像 object.x 这样的语句所需的虚拟指令可能是一两条指令。一台不了解 JavaScript 对象如何工作的实际机器需要更多的指令来确定 .x 在内存中的位置以及如何获取它。 虚拟机的问题在于它是虚拟的, 它是不存在的。指令不能直接执行，必须在运行时解释。解释代码总是比直接执行代码慢。 这里有一个问题需要权衡。需要在更快的编译时间与更快的运行时间中做一个选择。在许多情况下，更快的编译是一个很好的权衡。用户不太可能关心单个按钮的点击是否需要 20 或 40 毫秒的执行时间，尤其是当按钮只被按下一次时。快速编译 JavaScript，即使生成的代码执行速度较慢，也会让用户更快地查看页面并与页面交互。 有些情况在计算上是昂贵的。诸如游戏、语法高亮之类的场景。在这种情况下，编译和执行机器指令的时间加起来可能会减少总执行时间。那么 JavaScript 是如何处理这些情况的呢？ 经常被执行的代码 每当 JavaScript 引擎检测到某个函数执行了很多次时，它就会将该函数交给优化编译器。该编译器将虚拟机指令翻译成实际的机器指令。更重要的是，由于该函数已经运行了多次，优化编译器可以根据之前的运行做出一些假设。换句话说，它可以执行推测优化以生成更快的代码。 如果这些推测后来被证明是错误的，会发生什么？ JavaScript引擎可以简单地删除错误的函数，并还原为使用未优化版本。一旦该函数再运行几次，它就可以尝试再次将其传递给优化编译器，这一次它会提供更多可用于推测优化的信息。 既然我们知道频繁运行的函数在优化过程中使用来自先前执行的信息，接下来要探索的是这是什么类型的信息。 翻译问题 JavaScript 中的几乎所有东西都是对象。不幸的是，JavaScript 对象很难让机器处理。让我们看看下面的代码： function addFive(obj) { return obj.method() + 5; } 将函数转换为机器指令非常简单，就像从函数返回一样。但是机器不知道对象是什么，比如访问obj的method属性需要怎么翻译呢？ 如果知道 obj 是什么样子会很有帮助，但在 JavaScript 中我们永远无法确定。任何对象都可以添加或删除方法属性。即使method确实存在，我们实际上也不能确定它是否是一个函数，更不用说调用它之后的返回值了。 让我们尝试将上述代码转换为没有对象的 JavaScript 子集，来了解转换为机器指令可能是什么样的。 首先，我们需要一种表示对象的方法。我们还需要一种从其中检索值的方法。在机器代码中支持数组是比较的，所以我们可能会使用这样的表示： // An object like { method: function() {} } // could be represented as: // [ [ &quot;method&quot; ], // property names // [ function() {} ] ] // property values function lookup(obj, name) { for (var i = 0; i &lt; obj[0].length; i++) { if (obj[0][i] === name) return i; } return -1; } 参考上述的表示，我们可以尝试对 addFive 进行一个简单的实现 function addFive(obj) { var propertyIndex = lookup(obj, &quot;method&quot;); var property = propertyIndex &lt; 0 ? undefined : obj[1][propertyIndex]; if (typeof(property) !== &quot;function&quot;) { throw NotAFunction(obj, &quot;method&quot;); } var callResult = property(/* this */ obj); return callResult + 5; } 当然，这在 obj.method() 返回的不是数字的情况下不能运行，所以我们需要稍微调整一下实现： function addFive(obj) { var propertyIndex = lookup(obj, &quot;method&quot;); var property = propertyIndex &lt; 0 ? undefined : obj[1][propertyIndex]; if (typeof(property) !== &quot;function&quot;) { throw NotAFunction(obj, &quot;method&quot;); } var callResult = property(/* this */ obj); if (typeof(callResult) === &quot;string&quot;) { return stringConcat(callResult, &quot;5&quot;); } else if (typeof(callResult !== &quot;number&quot;) { throw NotANumber(callResult); } return callResult + 5; } 这是能运行的，但我希望很明显，如果我们能提前知道 obj 的结构是什么，以及方法的类型是什么，那么这段代码可以跳过几个步骤。 隐藏类 主流的 JavaScript 引擎都以某种方式跟踪对象是什么样的呢？在 Chrome 中，这个概念被称为隐藏类。 让我们从以下代码片段开始： var obj = {}; // empty object obj.x = 1; // shape has now changed to include a `x` property obj.toString = function() { return &quot;TODO&quot;; }; // shape changes delete obj.x; // shape changes again 如果我们将其转换为机器指令，我们将如何在添加和删除新属性时跟踪对象的样子？如果我们使用上一个示例将对象表示为数组的想法，它可能看起来像这样： var emptyObj__Class = [ null, // No parent hidden class [], // Property names [] // Property types ]; var obj = [ emptyObj__Class, // Hidden class of `obj` [] // Property values ]; var obj_X__Class = [ emptyObj__Class, // Contains same properties as empty object [&quot;x&quot;], // As well as one property called `x` [&quot;number&quot;] // Where `x` is a number ]; obj[0] = obj_X__Class; // Shape changes obj[1].push(1); // value of `x` var obj_X_ToString__Class = [ obj_X__Class, // Contains same properties as previous shape [&quot;toString&quot;], // And one property called `toString` [&quot;function&quot;] // Where `toString` is a function ]; obj[0] = obj_X_ToString__Class; // shape change obj[1].push(function() { return &quot;TODO&quot;; }); // `toString` value var obj_ToString__Class = [ null, // Starting from scratch when deleting `x` [&quot;toString&quot;], [&quot;function&quot;] ]; obj[0] = obj_ToString__Class; obj[1] = [obj[1][1]]; 如果我们要生成这样的虚拟机指令，我们现在就有了一种方法来跟踪对象在任何给定时间的样子。然而，这本身并不能真正帮助我们。我们需要将这些信息存储在有价值的地方。 内联缓存 每当 JavaScript 代码对对象执行属性访问时，JavaScript 引擎都会将该对象的隐藏类以及查找结果（属性名称到索引的映射）存储在缓存中。这些缓存被称为内联缓存，它们有两个重要目的： 在执行字节码时，如果所涉及的对象具有缓存中的隐藏类，它们会加速属性访问。 在优化期间，它们包含有关访问对象属性时所涉及的对象类型的信息，这有助于优化编译器生成特别适合这些类型的代码。 内联缓存对它们存储信息的隐藏类的数量有限制。这可以保留内存，但也确保在缓存中执行查找速度很快。如果从内联缓存中检索索引比从隐藏类中检索索引花费的时间更长，则缓存没有任何用处。 据我所知， Chrome在中，内联缓存最多会跟踪 4 个隐藏类。在此之后，内联缓存将被禁用，信息将存储在全局缓存中。全局缓存的大小也有限制，一旦达到限制，新条目将覆盖旧条目。 为了最好地利用内联缓存并帮助优化编译器，应该尝试编写仅对单一类型的对象执行属性访问的函数。不仅如此，生成的代码的性能将是次优的 内联 一种单独且重要的优化是内联。简而言之，这种优化用被调用函数的实现代替了函数调用。举个例子： function map(fn, list) { var newList = []; for (var i = 0; i &lt; list.length; i++) { newList.push(fn(list[i])); } return newList; } function incrementNumbers(list) { return map(function(n) { return n + 1; }, list); } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 内联后，代码最终可能看起来像这样： function incrementNumbers(list) { var newList = []; var fn = function(n) { return n + 1; }; for (var i = 0; i &lt; list.length; i++) { newList.push(fn(list[i])); } return newList; } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 这样做的一个好处是删除了函数调用。更大的好处是 JavaScript 引擎现在可以更深入地了解函数的实际作用。基于这个新版本，JavaScript 引擎可能会决定再次执行内联： function incrementNumbers(list) { var newList = []; for (var i = 0; i &lt; list.length; i++) { newList.push(list[i] + 1); } return newList; } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 另一个函数调用已被删除。更重要的是，优化器现在可能会推测 incrementNumbers 只会以数字列表作为参数被调用。它还可能决定内联 incrementNumbers([1, 2, 3]) 调用本身，并发现 list.length 为 3，这又可能导致： var list = [1, 2, 3]; var newList = []; newList.push(list[0] + 1); newList.push(list[1] + 1); newList.push(list[2] + 1); list = newList; 简而言之，内联可以实现跨函数边界无法执行的优化。 但是，可以内联的内容是有限的。由于代码重复，内联会导致更大的函数，这需要额外的内存。 JavaScript 引擎对一个函数在完全跳过内联之前可以达到的大小有一个预算。 一些函数调用也很难内联。特别是当一个函数作为参数传入时。 此外，作为参数传递的函数很难内联，除非它总是同一个函数。虽然这可能会让您觉得这是一件奇怪的事情，但由于内联，最终可能会出现这种情况。 结论 JavaScript 引擎有许多提高运行时性能的技巧，比这里介绍的要多得多。但是，本文中描述的优化适用于大多数浏览器，并且很容易验证它们是否被应用。因此，当我们尝试提高 Elm 的运行时性能时，我们将主要关注这些优化。 参考 What’s up with monomorphism Shapes and inline caches Optimizing prototypes ","link":"https://umeimmense.github.io/post/javascript-yin-qing-ru-he-ti-sheng-qi-yun-xing-shi-de-xing-neng"},{"title":"7 个可能需要的自定义 React Hook","content":"前言 本文主要编制了一份清单，列出了在项目中可能会需要用到的的七个Hooks。 1. useToggle 这个hook很常见，它用于在 true 和 false 之间切换布尔值。当我们想要显示/隐藏模式或打开/关闭侧边菜单时，它很有用。这个hook的基本版本如下所示： 实现v1 // useToggle.jsx import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); return [state, toggle]; }; export default useToggle; 案例1 import useToggle from './useToggle'; const App = () =&gt; { const [show, toggleShow] = useToggle(); return ( &lt;Modal show={show} onClose={toggleShow}&gt; &lt;h1&gt;Hello there&lt;/h1&gt; &lt;/Modal&gt; ); } 当我们想要显示/隐藏表中一行的模式时，可以稍微修改此hook以用于用例。我添加了一个 customToggle 方法，该方法将值设置为给定值，而不是切换先前的状态值。 实现v2 // useToggle.jsx modified import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); const customToggle = useCallback((value) =&gt; { setState(value); }, []); return [state, toggle, customToggle]; }; export default useToggle; 案例2 假设我们在一个表格中有一堆行，我们想提供一个删除行的选项。单击删除按钮应打开一个确认模式。 对于这种类型的功能，我们需要状态中的两个变量。首先，保存一个布尔值来确定是否显示删除确认模式，其次保存必须显示删除模式的行 ID。 使用这个hook，我们可以用一个状态变量来完成。这是如何做到的： import useToggle from './useToggle'; // initial data const rows = [ { id: 1, name: 'John' }, { id: 2, name: 'Doe' } ]; const App = () =&gt; { // using hook const [delModal, toggleDelModal, setDelModalCustom] = useToggle(); return ( &lt;div&gt; &lt;table&gt; {rows.map(row =&gt; ( &lt;tr&gt; &lt;td&gt;{row.id}&lt;/td&gt; &lt;td&gt;{row.name}&lt;/td&gt; &lt;td onClick={() =&gt; setDelModalCustom(row.id)}&gt;Delete&lt;/td&gt; &lt;/tr&gt; ))} &lt;/table&gt; &lt;DeleteModal show={Boolean(delModal)} onClose={toggleDelModal} itemToDelete={delModal} // it will hold the current row id &gt; &lt;h1&gt; Are you sure you want to delete row with id {delModal} &lt;/h1&gt; &lt;/DeleteModal&gt; &lt;/div&gt; ); } 2. usePageBottom 使用此hook，您可以确定用户是否已滚动到页面底部。非常适合无限滚动的应用程序，当用户滚动到页面底部时，您需要获取更多数据。 // usePageBottom.jsx import { useState, useEffect } from 'react'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = () =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }; // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 案例 import usePageBottom from './usePageBottom'; const App = (props) =&gt; { // hook usage const scrolledBottom = usePageBottom(); return ( &lt;div className=&quot;App&quot; style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 节流版本（可选） 减少像窗口滚动事件这样多次触发的事件的通知是最佳实践，我们可以使用节流设置事件侦听器。我正在使用 lodash 的throttle；你也可以使用去debounce。 // usePageBottom with throttle import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 3. useElementBottom 就像页面底部一样，我们也可以确定用户是否已经滚动到元素的底部。在这个hook中，传递了对元素的引用，因此我们可以使用元素的高度和当前滚动位置来确定元素是否滚动到底部。 // useElementBottom.jsx import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const useElementBottom = (element) =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const { current } = element; // current holds the reference to element // if current scroll from bottom is less than equal to 10px const scrollBottom = current.scrollHeight - current.scrollTop - current.clientHeight; const reachingBottom = scrollBottom &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on element scroll useEffect(() =&gt; { const { current } = element; current.addEventListener('scroll', handleScroll); return () =&gt; current.removeEventListener('scroll', handleScroll); }, []); return reachedBottom; }; export default useElementBottom; 案例 import useElementBottom from './useElementBottom'; const App = (props) =&gt; { const element = useRef(); // hook usage const scrolledBottom = useElementBottom(element); return ( &lt;div ref={element} style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 4. usePrevious 我们可以制作一个自定义hook来获取 prop 或 state 的先前值。使用 React 类组件，可以使用 componentDidUpdate 生命周期来获取之前的 prop 和 state 值。对于功能组件，我们可以使用自定义hook来完成，如下所示： // usePrevious.jsx import { useEffect, useRef } from 'react'; const usePrevious = (value) =&gt; { const ref = useRef(); // store current value in ref useEffect(() =&gt; { ref.current = value; }, [value]); // return previous value (happens before update in useEffect above) return ref.current; }; export default usePrevious; 我们使用 useRef hook来存储先前的值。我们的hook在 useEffect 中更新引用对象之前返回先前的值。 import usePrevious from './usePrevious'; const App = () =&gt; { const [count, setCount] = useState(0); const prevCount = usePrevious(count); return ( &lt;div&gt; &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; ); } 5. useWindowSize 这个hook返回窗口的宽度和高度。我们在调整窗口大小时设置了一个受限制的 set 事件侦听器，以便我们每次都能获得正确的宽度和高度。 // useWindowSize import { useState, useEffect, useCallback } from 'react'; import { throttle } from 'throttle'; const useWindowSize = () =&gt; { const [size, setSize] = useState({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); // throttled set listener that runs on window resize const throttledSetResizeListner = useCallback( throttle(() =&gt; { // set size in state setSize({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); }, 1000), [] ); // effect for binding resize event on window useEffect(() =&gt; { // add throtelled set window resize event listener window.addEventListener('resize', throttledSetResizeListner); // remove throttled set window resize event listener return () =&gt; window.removeEventListener('resize', throttledSetResizeListner); }, [throttledSetResizeListner]); return size; }; export default useWindowSize; 案例 当你想根据窗口的宽度或高度在你的 JS 代码中做一些事情时，它很有用。 import useWindowSize from './useWindowSize'; const App = () =&gt; { const { innerWidth, innerHeight } = useWindowSize(); return ( &lt;div&gt; {innerWidth &lt;= 768 ? 'I am on small screen' : 'I am on large screen'} &lt;/div&gt; ); } 6. useEventListener 使用此hook可以轻松地将事件侦听器绑定到窗口或窗口元素。在hook的effect中，我们检查元素是否是来自 useRef 的引用。如果没有，我们将事件侦听器添加到全局窗口对象。 import { useEffect } from 'react'; const useEventListener = (event, handler, referencedElement) =&gt; { // effect for binding event handler to the element useEffect(() =&gt; { const element = referencedElement?.current || window; const isSupported = element &amp;&amp; element.addEventListener; if (!isSupported) return; // bind event to the element element.addEventListener(event, handler); return () =&gt; element.removeEventListener(event, handler); }, [referencedElement, event, handler]); return; }; export default useEventListener; import useEventListener from './useEventListener'; const App = (props) =&gt; { const element = useRef(); useEventListener('mouseover', handler, element); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div ref={element}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 我们还可以使用相同的hook将事件添加到窗口 import useEventListener from './useEventListener'; const App = (props) =&gt; { // adding event listener on window scroll useEventListener('scroll', handler); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 7. useLocalStorageState 有时，可能需要在本地存储和状态之间同步一个值。这个hook的作用完全一样。我们正在使用 useState 并检查指定的键是否在本地存储中具有某个值，以便我们可以将其用作初始值。这允许我们在页面刷新时保持值与状态同步。 // useLocalStorageState import { useState, useEffect } from 'react'; const useLocalStorageState = (key, defaultValue) =&gt; { const [value, setValue] = useState(() =&gt; { let val; try { // if there is a value in local storage for given key, set it as initial state val = JSON.parse(localStorage.getItem(key) || String(defaultValue)); } catch (error) { // otherwise, set default value as initial state val = defaultValue; } return val; }); // effect to update local storage when state changes useEffect(() =&gt; { localStorage.setItem(key, JSON.stringify(value)); }, [value]); return [value, setValue]; }; export default useLocalStorageState; 当值更新时，会运行一个effect ，更新本地存储中的值。 案例 假设你想在本地存储中存储用户主题首选项 import useLocalStorageState from './useLocalStorageState'; const App = (props) =&gt; { // setting default theme to light const [theme, setTheme] = useLocalStorageState('theme', 'light'); return ( &lt;div&gt; &lt;p&gt;Current theme is {theme}&lt;/p&gt; &lt;button onClick={() =&gt; setTheme('dark')}&gt; Change theme to dark &lt;/button&gt; &lt;/div&gt; ); } 当你点击更改主题按钮时，状态和本地存储中的值都会更新。页面刷新后，你将获得存储在本地存储中的最后一个值。 结语 感谢你阅读到最后。我希望这些自定义hook对你有用。 ","link":"https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook"},{"title":"10个常用的JavaScript使用技巧","content":"前言 编写简短、简洁和干净的 JavaScript 代码的技巧😎 JavaScript 有很多很酷的特性，大多数初学者和中级开发人员都不知道。我挑选了 10 个我在日常 JavaScript 项目中使用的技巧。 1. 有条件的向对象中添加属性 我们可以使用扩展运算符 ... 来有条件地向 JavaScript 对象快速添加属性。 const condition = true; const person = { id: 1, name: 'John Doe', ...(condition &amp;&amp; { age: 16 }), }; 如果每个操作数的计算结果都为true， &amp;&amp; 运算符将返回最后计算的表达式。因此返回一个对象 { age: 16 }，然后将其作为 person 对象的一部分。 如果条件为 false，则 JavaScript 将执行以下操作： const person = { id: 1, name: 'John Doe', ...(false), // evaluates to false }; // spreading false has no effect on the object console.log(person); // { id: 1, name: 'John Doe' } 2. 检查一个属性是否存在于一个对象中 我们可以使用in关键字来检查 JavaScript 对象中是否存在属性 const person = { name: 'John Doe', salary: 1000 }; console.log('salary' in person); // returns true console.log('age' in person); // returns false 3. 对象中的动态属性名称 使用动态键设置对象属性很简单。只需使用 ['key_name'] 符号添加属性 const dynamic = 'flavour'; var item = { name: 'Biscuit', [dynamic]: 'Chocolate' } console.log(item); // { name: 'Biscuit', flavour: 'Chocolate' } 同样的技巧也可用于使用动态键引用对象属性： const keyName = 'name'; console.log(item[keyName]); // returns 'Biscuit' 4. 使用动态键进行对象解构 你可能知道你可以解构一个变量并立即用 : 符号重命名它。但是你知道当你不知道键名或键名是动态的时，你也可以解构对象的属性吗？ 首先，让我们看看如何在解构（用别名解构）时重命名变量。 const person = { id: 1, name: 'John Doe' }; const { name: personName } = person; console.log(personName); // returns 'John Doe' 现在，让我们使用动态键来解构属性： const templates = { 'hello': 'Hello there', 'bye': 'Good bye' }; const templateName = 'bye'; const { [templateName]: template } = templates; console.log(template) // returns 'Good bye' 5. ?? 运算符 这 ??当你要检查变量是 null 还是 undefined 时，运算符很有用。当其左侧操作数为空或未定义时，它返回右侧操作数，否则返回其左侧操作数。 const foo = null ?? 'Hello'; console.log(foo); // returns 'Hello' const bar = 'Not null' ?? 'Hello'; console.log(bar); // returns 'Not null' const baz = 0 ?? 'Hello'; console.log(baz); // returns 0 在第三个示例中，返回 0 是因为即使 0 在 JavaScript 中被认为是假的，但它不是 null 或未定义的。你可能认为我们可以使用 ||运算符在这里，但这两者之间存在差异： const cannotBeZero = 0 || 5; console.log(cannotBeZero); // returns 5 const canBeZero = 0 ?? 5; console.log(canBeZero); // returns 0 6. ?. 可选链 我们都可能曾经遇到过TypeError：无法读取 null 的属性“foo”之类的错误。这对每个 JavaSript 开发人员来说都是头疼的问题。引入了可选链就是为了解决这个问题。让我们来看看： const book = { id:1, title: 'Title', author: null }; // normally, you would do this console.log(book.author.age) // throws error console.log(book.author &amp;&amp; book.author.age); // returns null (no error) // with optional chaining console.log(book.author?.age); // returns undefined // or deep optional chaining console.log(book.author?.address?.city); // returns undefined 你还可以使用具有以下功能的可选链： const person = { firstName: 'Haseeb', lastName: 'Anwar', printName: function () { return `${this.firstName} ${this.lastName}`; }, }; console.log(person.printName()); // returns 'Haseeb Anwar' console.log(persone.doesNotExist?.()); // returns undefined 7. 使用 !! 的布尔转换符 这 !!运算符可用于将表达式的结果快速转换为布尔值 true 或 false。就是这样： const greeting = 'Hello there!'; console.log(!!greeting) // returns true const noGreeting = ''; console.log(!!noGreeting); // returns false 8. 字符串和整数转换 使用 + 运算符快速将字符串转换为数字，如下所示： const stringNumer = '123'; console.log(+stringNumer); // returns integer 123 console.log(typeof +stringNumer); // returns 'number' 要将数字快速转换为字符串，请使用 + 运算符后跟空字符串 &quot;&quot;： const myString = 25 + ''; console.log(myString); // returns '25' console.log(typeof myString); // returns 'string' 这些类型转换非常方便，但它们的清晰度和代码可读性较差。因此，在生产中使用它们之前，你可能需要考虑一下。不过可以用才code golf中。 9. 检查数组中的假值 你熟悉 filter、some 和 every 数组方法。但你也应该知道，你可以仅使用布尔方法来测试真值： const myArray = [null, false, 'Hello', undefined, 0]; // filter falsy values const filtered = myArray.filter(Boolean); console.log(filtered); // returns ['Hello'] // check if at least one value is truthy const anyTruthy = myArray.some(Boolean); console.log(anyTruthy); // returns true // check if all values are truthy const allTruthy = myArray.every(Boolean); console.log(allTruthy); // returns false 这是它的工作原理。众所周知，这些数组方法采用回调函数，因此我们将布尔值作为回调函数传递。 Boolean 本身接受一个参数并根据参数的真实性返回true或 false。所以我们可以这样说： myArray.filter(val =&gt; Boolean(val)); 是不是和这个一样： myArray.filter(Boolean); 10.展平数组 原型 Array 上有一个方法 flat 可以让你从数组的数组中创建一个数组： const myArray = [{ id: 1 }, [{ id: 2 }], [{ id: 3 }]]; const flattedArray = myArray.flat(); // returns [ { id: 1 }, { id: 2 }, { id: 3 } 你还可以定义一个深度级别，指定嵌套数组结构应展平的深度。例如： const arr = [0, 1, 2, [[[3, 4]]]]; console.log(arr.flat(2)); // returns [0, 1, 2, [3,4]] 结语 感谢你阅读到最后。我希望这些技巧对你有用。 ","link":"https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao"}]}