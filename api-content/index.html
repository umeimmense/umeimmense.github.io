{"posts":[{"title":"7 个可能需要的自定义 React Hook","content":"前言 本文主要编制了一份清单，列出了在项目中可能会需要用到的的七个Hooks。 1. useToggle 这个hook很常见，它用于在 true 和 false 之间切换布尔值。当我们想要显示/隐藏模式或打开/关闭侧边菜单时，它很有用。这个hook的基本版本如下所示： 实现v1 // useToggle.jsx import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); return [state, toggle]; }; export default useToggle; 案例1 import useToggle from './useToggle'; const App = () =&gt; { const [show, toggleShow] = useToggle(); return ( &lt;Modal show={show} onClose={toggleShow}&gt; &lt;h1&gt;Hello there&lt;/h1&gt; &lt;/Modal&gt; ); } 当我们想要显示/隐藏表中一行的模式时，可以稍微修改此hook以用于用例。我添加了一个 customToggle 方法，该方法将值设置为给定值，而不是切换先前的状态值。 实现v2 // useToggle.jsx modified import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); const customToggle = useCallback((value) =&gt; { setState(value); }, []); return [state, toggle, customToggle]; }; export default useToggle; 案例2 假设我们在一个表格中有一堆行，我们想提供一个删除行的选项。单击删除按钮应打开一个确认模式。 对于这种类型的功能，我们需要状态中的两个变量。首先，保存一个布尔值来确定是否显示删除确认模式，其次保存必须显示删除模式的行 ID。 使用这个hook，我们可以用一个状态变量来完成。这是如何做到的： import useToggle from './useToggle'; // initial data const rows = [ { id: 1, name: 'John' }, { id: 2, name: 'Doe' } ]; const App = () =&gt; { // using hook const [delModal, toggleDelModal, setDelModalCustom] = useToggle(); return ( &lt;div&gt; &lt;table&gt; {rows.map(row =&gt; ( &lt;tr&gt; &lt;td&gt;{row.id}&lt;/td&gt; &lt;td&gt;{row.name}&lt;/td&gt; &lt;td onClick={() =&gt; setDelModalCustom(row.id)}&gt;Delete&lt;/td&gt; &lt;/tr&gt; ))} &lt;/table&gt; &lt;DeleteModal show={Boolean(delModal)} onClose={toggleDelModal} itemToDelete={delModal} // it will hold the current row id &gt; &lt;h1&gt; Are you sure you want to delete row with id {delModal} &lt;/h1&gt; &lt;/DeleteModal&gt; &lt;/div&gt; ); } 2. usePageBottom 使用此hook，您可以确定用户是否已滚动到页面底部。非常适合无限滚动的应用程序，当用户滚动到页面底部时，您需要获取更多数据。 // usePageBottom.jsx import { useState, useEffect } from 'react'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = () =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }; // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 案例 import usePageBottom from './usePageBottom'; const App = (props) =&gt; { // hook usage const scrolledBottom = usePageBottom(); return ( &lt;div className=&quot;App&quot; style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 节流版本（可选） 减少像窗口滚动事件这样多次触发的事件的通知是最佳实践，我们可以使用节流设置事件侦听器。我正在使用 lodash 的throttle；你也可以使用去debounce。 // usePageBottom with throttle import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 3. useElementBottom 就像页面底部一样，我们也可以确定用户是否已经滚动到元素的底部。在这个hook中，传递了对元素的引用，因此我们可以使用元素的高度和当前滚动位置来确定元素是否滚动到底部。 // useElementBottom.jsx import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const useElementBottom = (element) =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const { current } = element; // current holds the reference to element // if current scroll from bottom is less than equal to 10px const scrollBottom = current.scrollHeight - current.scrollTop - current.clientHeight; const reachingBottom = scrollBottom &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on element scroll useEffect(() =&gt; { const { current } = element; current.addEventListener('scroll', handleScroll); return () =&gt; current.removeEventListener('scroll', handleScroll); }, []); return reachedBottom; }; export default useElementBottom; 案例 import useElementBottom from './useElementBottom'; const App = (props) =&gt; { const element = useRef(); // hook usage const scrolledBottom = useElementBottom(element); return ( &lt;div ref={element} style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 4. usePrevious 我们可以制作一个自定义hook来获取 prop 或 state 的先前值。使用 React 类组件，可以使用 componentDidUpdate 生命周期来获取之前的 prop 和 state 值。对于功能组件，我们可以使用自定义hook来完成，如下所示： // usePrevious.jsx import { useEffect, useRef } from 'react'; const usePrevious = (value) =&gt; { const ref = useRef(); // store current value in ref useEffect(() =&gt; { ref.current = value; }, [value]); // return previous value (happens before update in useEffect above) return ref.current; }; export default usePrevious; 我们使用 useRef hook来存储先前的值。我们的hook在 useEffect 中更新引用对象之前返回先前的值。 import usePrevious from './usePrevious'; const App = () =&gt; { const [count, setCount] = useState(0); const prevCount = usePrevious(count); return ( &lt;div&gt; &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; ); } 5. useWindowSize 这个hook返回窗口的宽度和高度。我们在调整窗口大小时设置了一个受限制的 set 事件侦听器，以便我们每次都能获得正确的宽度和高度。 // useWindowSize import { useState, useEffect, useCallback } from 'react'; import { throttle } from 'throttle'; const useWindowSize = () =&gt; { const [size, setSize] = useState({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); // throttled set listener that runs on window resize const throttledSetResizeListner = useCallback( throttle(() =&gt; { // set size in state setSize({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); }, 1000), [] ); // effect for binding resize event on window useEffect(() =&gt; { // add throtelled set window resize event listener window.addEventListener('resize', throttledSetResizeListner); // remove throttled set window resize event listener return () =&gt; window.removeEventListener('resize', throttledSetResizeListner); }, [throttledSetResizeListner]); return size; }; export default useWindowSize; 案例 当你想根据窗口的宽度或高度在你的 JS 代码中做一些事情时，它很有用。 import useWindowSize from './useWindowSize'; const App = () =&gt; { const { innerWidth, innerHeight } = useWindowSize(); return ( &lt;div&gt; {innerWidth &lt;= 768 ? 'I am on small screen' : 'I am on large screen'} &lt;/div&gt; ); } 6. useEventListener 使用此hook可以轻松地将事件侦听器绑定到窗口或窗口元素。在hook的effect中，我们检查元素是否是来自 useRef 的引用。如果没有，我们将事件侦听器添加到全局窗口对象。 import { useEffect } from 'react'; const useEventListener = (event, handler, referencedElement) =&gt; { // effect for binding event handler to the element useEffect(() =&gt; { const element = referencedElement?.current || window; const isSupported = element &amp;&amp; element.addEventListener; if (!isSupported) return; // bind event to the element element.addEventListener(event, handler); return () =&gt; element.removeEventListener(event, handler); }, [referencedElement, event, handler]); return; }; export default useEventListener; import useEventListener from './useEventListener'; const App = (props) =&gt; { const element = useRef(); useEventListener('mouseover', handler, element); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div ref={element}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 我们还可以使用相同的hook将事件添加到窗口 import useEventListener from './useEventListener'; const App = (props) =&gt; { // adding event listener on window scroll useEventListener('scroll', handler); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 7. useLocalStorageState 有时，可能需要在本地存储和状态之间同步一个值。这个hook的作用完全一样。我们正在使用 useState 并检查指定的键是否在本地存储中具有某个值，以便我们可以将其用作初始值。这允许我们在页面刷新时保持值与状态同步。 // useLocalStorageState import { useState, useEffect } from 'react'; const useLocalStorageState = (key, defaultValue) =&gt; { const [value, setValue] = useState(() =&gt; { let val; try { // if there is a value in local storage for given key, set it as initial state val = JSON.parse(localStorage.getItem(key) || String(defaultValue)); } catch (error) { // otherwise, set default value as initial state val = defaultValue; } return val; }); // effect to update local storage when state changes useEffect(() =&gt; { localStorage.setItem(key, JSON.stringify(value)); }, [value]); return [value, setValue]; }; export default useLocalStorageState; 当值更新时，会运行一个effect ，更新本地存储中的值。 案例 假设你想在本地存储中存储用户主题首选项 import useLocalStorageState from './useLocalStorageState'; const App = (props) =&gt; { // setting default theme to light const [theme, setTheme] = useLocalStorageState('theme', 'light'); return ( &lt;div&gt; &lt;p&gt;Current theme is {theme}&lt;/p&gt; &lt;button onClick={() =&gt; setTheme('dark')}&gt; Change theme to dark &lt;/button&gt; &lt;/div&gt; ); } 当你点击更改主题按钮时，状态和本地存储中的值都会更新。页面刷新后，你将获得存储在本地存储中的最后一个值。 结语 感谢你阅读到最后。我希望这些自定义hook对你有用。 ","link":"https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook"},{"title":"10个常用的JavaScript使用技巧","content":"前言 编写简短、简洁和干净的 JavaScript 代码的技巧😎 JavaScript 有很多很酷的特性，大多数初学者和中级开发人员都不知道。我挑选了 10 个我在日常 JavaScript 项目中使用的技巧。 1. 有条件的向对象中添加属性 我们可以使用扩展运算符 ... 来有条件地向 JavaScript 对象快速添加属性。 const condition = true; const person = { id: 1, name: 'John Doe', ...(condition &amp;&amp; { age: 16 }), }; 如果每个操作数的计算结果都为true， &amp;&amp; 运算符将返回最后计算的表达式。因此返回一个对象 { age: 16 }，然后将其作为 person 对象的一部分。 如果条件为 false，则 JavaScript 将执行以下操作： const person = { id: 1, name: 'John Doe', ...(false), // evaluates to false }; // spreading false has no effect on the object console.log(person); // { id: 1, name: 'John Doe' } 2. 检查一个属性是否存在于一个对象中 我们可以使用in关键字来检查 JavaScript 对象中是否存在属性 const person = { name: 'John Doe', salary: 1000 }; console.log('salary' in person); // returns true console.log('age' in person); // returns false 3. 对象中的动态属性名称 使用动态键设置对象属性很简单。只需使用 ['key_name'] 符号添加属性 const dynamic = 'flavour'; var item = { name: 'Biscuit', [dynamic]: 'Chocolate' } console.log(item); // { name: 'Biscuit', flavour: 'Chocolate' } 同样的技巧也可用于使用动态键引用对象属性： const keyName = 'name'; console.log(item[keyName]); // returns 'Biscuit' 4. 使用动态键进行对象解构 你可能知道你可以解构一个变量并立即用 : 符号重命名它。但是你知道当你不知道键名或键名是动态的时，你也可以解构对象的属性吗？ 首先，让我们看看如何在解构（用别名解构）时重命名变量。 const person = { id: 1, name: 'John Doe' }; const { name: personName } = person; console.log(personName); // returns 'John Doe' 现在，让我们使用动态键来解构属性： const templates = { 'hello': 'Hello there', 'bye': 'Good bye' }; const templateName = 'bye'; const { [templateName]: template } = templates; console.log(template) // returns 'Good bye' 5. ?? 运算符 这 ??当你要检查变量是 null 还是 undefined 时，运算符很有用。当其左侧操作数为空或未定义时，它返回右侧操作数，否则返回其左侧操作数。 const foo = null ?? 'Hello'; console.log(foo); // returns 'Hello' const bar = 'Not null' ?? 'Hello'; console.log(bar); // returns 'Not null' const baz = 0 ?? 'Hello'; console.log(baz); // returns 0 在第三个示例中，返回 0 是因为即使 0 在 JavaScript 中被认为是假的，但它不是 null 或未定义的。你可能认为我们可以使用 ||运算符在这里，但这两者之间存在差异： const cannotBeZero = 0 || 5; console.log(cannotBeZero); // returns 5 const canBeZero = 0 ?? 5; console.log(canBeZero); // returns 0 6. ?. 可选链 我们都可能曾经遇到过TypeError：无法读取 null 的属性“foo”之类的错误。这对每个 JavaSript 开发人员来说都是头疼的问题。引入了可选链就是为了解决这个问题。让我们来看看： const book = { id:1, title: 'Title', author: null }; // normally, you would do this console.log(book.author.age) // throws error console.log(book.author &amp;&amp; book.author.age); // returns null (no error) // with optional chaining console.log(book.author?.age); // returns undefined // or deep optional chaining console.log(book.author?.address?.city); // returns undefined 你还可以使用具有以下功能的可选链： const person = { firstName: 'Haseeb', lastName: 'Anwar', printName: function () { return `${this.firstName} ${this.lastName}`; }, }; console.log(person.printName()); // returns 'Haseeb Anwar' console.log(persone.doesNotExist?.()); // returns undefined 7. 使用 !! 的布尔转换符 这 !!运算符可用于将表达式的结果快速转换为布尔值 true 或 false。就是这样： const greeting = 'Hello there!'; console.log(!!greeting) // returns true const noGreeting = ''; console.log(!!noGreeting); // returns false 8. 字符串和整数转换 使用 + 运算符快速将字符串转换为数字，如下所示： const stringNumer = '123'; console.log(+stringNumer); // returns integer 123 console.log(typeof +stringNumer); // returns 'number' 要将数字快速转换为字符串，请使用 + 运算符后跟空字符串 &quot;&quot;： const myString = 25 + ''; console.log(myString); // returns '25' console.log(typeof myString); // returns 'string' 这些类型转换非常方便，但它们的清晰度和代码可读性较差。因此，在生产中使用它们之前，你可能需要考虑一下。不过可以用才code golf中。 9. 检查数组中的假值 你熟悉 filter、some 和 every 数组方法。但你也应该知道，你可以仅使用布尔方法来测试真值： const myArray = [null, false, 'Hello', undefined, 0]; // filter falsy values const filtered = myArray.filter(Boolean); console.log(filtered); // returns ['Hello'] // check if at least one value is truthy const anyTruthy = myArray.some(Boolean); console.log(anyTruthy); // returns true // check if all values are truthy const allTruthy = myArray.every(Boolean); console.log(allTruthy); // returns false 这是它的工作原理。众所周知，这些数组方法采用回调函数，因此我们将布尔值作为回调函数传递。 Boolean 本身接受一个参数并根据参数的真实性返回true或 false。所以我们可以这样说： myArray.filter(val =&gt; Boolean(val)); 是不是和这个一样： myArray.filter(Boolean); 10.展平数组 原型 Array 上有一个方法 flat 可以让你从数组的数组中创建一个数组： const myArray = [{ id: 1 }, [{ id: 2 }], [{ id: 3 }]]; const flattedArray = myArray.flat(); // returns [ { id: 1 }, { id: 2 }, { id: 3 } 你还可以定义一个深度级别，指定嵌套数组结构应展平的深度。例如： const arr = [0, 1, 2, [[[3, 4]]]]; console.log(arr.flat(2)); // returns [0, 1, 2, [3,4]] 结语 感谢你阅读到最后。我希望这些技巧对你有用。 ","link":"https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao"}]}