{"posts":[{"title":"自定义React Hook：检测组件外部的点击","content":"前言 本章我们一起来聊聊如何创建自定义 React Hook来检测 React 组件外部的点击。例如，你可能希望为各种组件（如对话框或下拉菜单）提供此类自定义 React Hook，因为当用户单击它们外部时它们应该关闭。所以我们需要一种方法来找出这个外部点击。 在这里学到的大部分内容都可以追溯到 JavaScript 中事件冒泡和捕获的概念。因此，如果你需要对冒泡、目标和捕获阶段进行复习，我建议你阅读以下文章，之前该文章涉及 React 的这个主题。 实现 让我们从 React 中的一个函数组件开始，我们使用 React 的 useState Hook 和一个事件处理程序来增加一个计数器： import * as React from 'react'; const style = { padding: '10px', border: '1px solid black', display: 'flex', justifyContent: 'flex-end', }; function App() { const [count, setCount] = React.useState(0); const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div style={style}&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } export default App; 一切都按预期工作。接下来，我们要在用户单击按钮外部时重置状态（此处为：计数）。我们可以编写用于重置状态的事件处理程序，但是尚不清楚在哪里使用它： function App() { const [count, setCount] = React.useState(0); const handleClickOutside = () =&gt; { setCount(0); }; const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div style={style}&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } 一种原始的方法是在顶级组件的最外层 HTML 元素（这里：）上使用这个新的处理程序。但是，更好的方法是在文档级别使用此事件处理程序作为最佳实践，因为最外层的 HTML 元素可能会在开发过程中发生变化。 我们将直接在自定义Hook中实现这一点，以避免冗余重构： const useOutsideClick = (callback) =&gt; { const ref = React.useRef(); React.useEffect(() =&gt; { const handleClick = (event) =&gt; { callback(); }; document.addEventListener('click', handleClick); return () =&gt; { document.removeEventListener('click', handleClick); }; }, []); return ref; }; 自定义Hook会启动一个最终返回的 React ref。它还没有真正用在Hook的实现细节中。此外，自定义Hook使用 React 的 useEffect Hook在文档级别分配（和删除）一个事件监听器（这里：单击事件）。毕竟，每当单击文档时，处理程序以及传递的回调函数都会运行。 现在自定义Hook可以在我们的 React 组件中以下列方式使用：将事件处理程序作为回调函数传递给Hook——只要单击文档就会执行。此外，使用返回的引用（此处为：ref）并将其分配给按钮 HTML 元素： function App() { const [count, setCount] = React.useState(0); const handleClickOutside = () =&gt; { setCount(0); }; const ref = useOutsideClick(handleClickOutside); const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div style={style}&gt; &lt;button ref={ref} type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } 但是，你会注意到，处理程序将始终触发，即使在单击按钮本身时也是如此。如果你再次检查自定义Hook，你将看到该引用（ref）并没有真正在其中使用。我们想要完成的事情：仅在单击传递的 ref（此处表示按钮）之外的任何内容时执行回调函数，而不是在单击 ref 本身（或其内容）时执行回调函数： const useOutsideClick = (callback) =&gt; { const ref = React.useRef(); React.useEffect(() =&gt; { const handleClick = (event) =&gt; { if (ref.current &amp;&amp; !ref.current.contains(event.target)) { callback(); } }; document.addEventListener('click', handleClick); return () =&gt; { document.removeEventListener('click', handleClick); }; }, [ref]); return ref; }; 就是这样。分配给按钮的引用是触发按钮的事件处理程序和文档的事件处理程序之间的边界。在参考之外点击的所有内容都将被视为外部点击。 但是缺少一个小的改进：如果我们需要通过在事件处理程序上使用 stopPropagation() 方法来停止某些边缘情况下的事件冒泡怎么办。例如，在下面我们通过单击容器元素来扩展组件并在那里停止事件的传播： const style = { padding: '10px', border: '1px solid black', display: 'flex', justifyContent: 'space-between', }; ... function App() { const [count, setCount] = React.useState(0); const handleClickOutside = () =&gt; { setCount(0); }; const ref = useOutsideClick(handleClickOutside); const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; const handleHeaderClick = (event) =&gt; { // do something event.stopPropagation(); }; return ( &lt;div style={style} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button ref={ref} type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } 当我们尝试这个例子时，我们会看到容器上的点击不会作为“外部点击”，因为即使它是外部点击，由于事件停止冒泡，它永远不会到达文档的事件侦听器。 通过使用冒泡和捕获阶段，我们可以调整自定义Hook以在捕获阶段触发。因为捕获阶段发生在冒泡阶段之前，所以即使事件在冒泡阶段停止传播，对文档的点击也将始终运行： const useOutsideClick = (callback) =&gt; { const ref = React.useRef(); React.useEffect(() =&gt; { const handleClick = (event) =&gt; { if (ref.current &amp;&amp; !ref.current.contains(event.target)) { callback(); } }; document.addEventListener('click', handleClick, true); return () =&gt; { document.removeEventListener('click', handleClick, true); }; }, [ref]); return ref; }; 就是这样。你创建了一个自定义挂钩来检测引用的组件/元素之外的点击。建议你再次阅读事件冒泡和捕获文章，以更深入地解释这些阶段发生的事情。 ","link":"https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-ce-zu-jian-wai-bu-de-dian-ji"},{"title":"如何创建自定义 React Hook ","content":"前言 React 很久以前就引入了 Hooks。随着 Hooks 的发布，函数组件能够使用内置 Hooks 的状态和副作用，例如 React 的 useState Hook 和 React 的 useEffect Hook。 不过，React 只提供了少数内置 Hook（例如 useReducer、useCallback、useMemo、useContext）。但是，通过使用这些 Hooks 作为基础，React 开发人员可以创建自己的称为自定义 Hooks 的 Hooks。 在我们创建自定义Hook之前，你需要知道创建一个有两个规则： 自定义 Hooks 以“use”为前缀命名。例如，自定义Hook可以命名为 useLocalStorage 或 useAuthentication。在我们的例子中，自定义Hook将被命名为 useBoolean。 自定义 Hooks 由内置的 React Hooks 或其他自定义 Hooks 组成。因此，自定义 Hook 始终是一个或多个 Hook 的新组合。如果自定义 Hook 在内部不使用任何Hook，则它不是自定义 Hook，不应具有前缀“use”。 自定义Hook 我们将创建一个名为 useBoolean 的自定义 Hook，让我们看看它为我们解决了什么问题。让我们从一个小例子开始： import * as React from 'react'; function App() { const [isToggle, setToggle] = React.useState(false); const handleToggle = () =&gt; setToggle(!isToggle); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleToggle}&gt; Toggle &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } export default App; 该组件呈现一个用于切换布尔值的按钮。在React 应用程序中，要么切换它（如上一个示例），要么将其显式设置为 true 或 false（如下一个示例）： import * as React from 'react'; function App() { const [isToggle, setToggle] = React.useState(false); const handleToggle = () =&gt; setToggle(!isToggle); const handleTrue = () =&gt; setToggle(true); const handleFalse = () =&gt; setToggle(false); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleToggle}&gt; Toggle &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={handleTrue}&gt; To True &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={handleFalse}&gt; To False &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } export default App; 一些观点可能会争辩说，我们本可以使用内联处理程序，这样就不会有事件处理程序的重复声明。然而，我个人尽量避免使用内联处理程序，因为它们向 JSX 注入了太多逻辑，而应该在组件的函数签名和返回语句之间定义。但这只是个人喜好。 无论如何，每次使用有状态布尔值时，都会遇到相同的实现细节：要么切换布尔值，要么将其设置为两个可能值之一。为了在多个 React 组件中使用有状态布尔值时屏蔽这些重复代码，我开始为它创建一个自定义Hook： const useBoolean = () =&gt; { const [state, setState] = React.useState(); const handleTrue = () =&gt; setState(true); const handleFalse = () =&gt; setState(false); const handleToggle = () =&gt; setState(!state); return [ state, { setTrue: handleTrue, setFalse: handleFalse, setToggle: handleToggle, }, ]; }; 基本上所有实现细节，即状态和事件处理程序，都移到了这个名为 useBoolean 的自定义Hook中。此外，自定义Hook返回状态和更新数组中状态的函数。 从自定义Hook返回多个值时，返回一个数组是最佳实践，因为 React 的内置 Hooks（在返回多个值的情况下）利用了数组，因此也使用了数组解构。使用数组解构的好处是可以为解构的值赋予任何名称（在对象解构的情况下，代码比重命名值要少）。 const useBoolean = (initialState = false) =&gt; { const [state, setState] = React.useState(initialState); const handleTrue = () =&gt; setState(true); const handleFalse = () =&gt; setState(false); const handleToggle = () =&gt; setState(!state); return [ state, { setTrue: handleTrue, setFalse: handleFalse, setToggle: handleToggle, }, ]; }; 一个很好的补充是也添加一个初始状态（如最后一个代码片段所示）。回到我们的 App 组件，我们可以通过向它传递初始状态并使用它的返回值来显示状态并更新它来使用这个新的自定义Hook： function App() { const [isToggle, { setToggle }] = useBoolean(false); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={setToggle}&gt; Toggle &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } 由于自定义Hook不仅提供了切换有状态布尔值的功能，而且还可以将其显式设置为True或False，我们也可以使用这些功能： function App() { const [isToggle, { setToggle, setTrue, setFalse, }] = useBoolean(false); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={setToggle}&gt; Toggle &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={setTrue}&gt; To True &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={setFalse}&gt; To False &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } 本质上，我们将有状态的布尔值和所有在布尔值上运行的事件处理程序提取到一个自定义Hook中。通过每次我们需要一个有状态的布尔值时使用这个自定义钩子，我们可以节省定义事件处理程序，其中包括有关如何操作布尔值的实现细节，而不是使用从钩子返回的函数。 总之，我们已经学习了如何使用 React 的内置 Hook 之一（称为 useState）来创建自定义钩子。这个自定义钩子并不复杂，但是，它应该向你展示如何减少 React 项目中的复杂性和冗余。 ","link":"https://umeimmense.github.io/post/ru-he-chuang-jian-zi-ding-yi-react-hook"},{"title":"React中的事件处理","content":"前言 在本节中，我们将了解 React 中用于 HTML 元素（例如按钮和输入元素）的事件处理程序。你将学习如何使用带有 onClick 事件的按钮，以及如何定义和使用不同类型的事件处理程序。本质上，我们将介绍三种事件处理程序：事件处理程序、内联事件处理程序和回调事件处理程序。 React中的事件处理程序 首先，我们将从 React 中针对特定 onClick 事件处理程序的按钮示例开始。这是关于如何在 React 中使用事件处理程序（也称为事件处理程序函数或处理程序）处理事件的最基本示例。按钮具有接收函数的 onClick 属性。每次触发事件时都会调用此函数（此处：单击按钮时）： import React from 'react'; function App() { function handleClick() { console.log('Button click ...'); } return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Event Handler &lt;/button&gt; &lt;/div&gt; ); } 对于其他属性，如 onChange（onChange 事件处理程序）和 onSubmit（onSubmit 事件处理程序），它的工作方式类似。对于初学者来说，onClick 经常不起作用，因为他们没有传递函数，而是直接在 JSX 中调用函数。例如，在下一个版本中，事件处理程序仅在第一次渲染组件时被调用一次。其他每一次单击都不会调用事件处理函数，因为函数的返回值用于 onClick 属性而不是函数本身。所以没有什么可调用的；除非函数返回另一个函数： import React from 'react'; function App() { function handleClick() { console.log('Button click ...'); } // don't do this return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleClick()}&gt; Event Handler &lt;/button&gt; &lt;/div&gt; ); } 通过使用 JavaScript 箭头函数，可以使事件处理函数更加简洁。不过，这是一个可选步骤。就个人而言，我喜欢将事件处理程序作为箭头函数： import React from 'react'; function App() { const handleClick = () =&gt; { console.log('Button click ...'); }; return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Event Handler &lt;/button&gt; &lt;/div&gt; ); } 但是一旦更多的事件处理程序在 React 组件中添加，通过再次给它们函数语句来使它们与其他变量更容易区分是很好的： import React from 'react'; function App() { const user = { id: '123abc', username: 'Robin Wieruch', }; function handleUserSignIn() { // do something } function handleUserSignUp() { // do something } function handleUserSignOut() { // do something } ... } 毕竟，onClick 事件的事件处理程序应该实现一些业务逻辑。在本例中，React 的 useState Hook 用于通过 onClick 按钮事件更新某些状态： import React from 'react'; function App() { const [count, setCount] = React.useState(0); function handleClick() { setCount(count + 1); } return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Increase Count &lt;/button&gt; &lt;/div&gt; ); } 下一个示例向你展示了一个输入字段而不是一个按钮。在那里，我们使用的是始终作为第一个参数传递给事件处理函数的实际事件。该事件是来自 React 的合成事件，它本质上封装了原生 HTML 事件并在其之上添加了一些功能。每次有人使用事件的目标属性输入输入字段时，此事件都会为你提供输入字段的值： import React from 'react'; function App() { const [text, setText] = React.useState(''); function handleChange(event) { setText(event.target.value); } return ( &lt;div&gt; &lt;input type=&quot;text&quot; onChange={handleChange} /&gt; {text} &lt;/div&gt; ); } 以前我们没有使用过该事件，因为在我们的按钮示例中我们不需要它。在输入字段示例中，我们需要它。最后但同样重要的是，不要忘记将值传递给输入元素以使其成为受控组件： import React from 'react'; function App() { const [text, setText] = React.useState(''); function handleChange(event) { setText(event.target.value); } return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={text} onChange={handleChange} /&gt; {text} &lt;/div&gt; ); } 简而言之，这就是事件处理程序。让我们了解 React 中更高级的处理程序。 React 中的内联事件处理程序 内联事件处理程序，也称为内联处理程序，通过直接在 JSX 中使用事件处理程序为我们提供了许多新选项： import React from 'react'; function App() { const [count, setCount] = React.useState(0); return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={function() { setCount(count + 1); }} &gt; Increase Count &lt;/button&gt; &lt;/div&gt; ); } 在 JSX 中使用通用函数语句虽然很冗长。因此，JavaScript 箭头函数可以方便地定义更简洁的内联处理程序： import React from 'react'; function App() { const [count, setCount] = React.useState(0); return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={() =&gt; setCount(count + 1)} &gt; Increase Count &lt;/button&gt; &lt;/div&gt; ); } 一般来说，开发者都是懒惰的人，所以经常使用内联事件处理程序来避免在 JSX 之外进行额外的函数声明。然而，这会将大量业务逻辑转移到 JSX 中，这使得它的可读性、可维护性和易错性降低。就个人而言，我喜欢在没有内联事件处理程序的情况下保持 JSX 干净，并在 JSX 之外声明事件处理程序。 内联处理程序也用于将参数传递给在 JSX 之外定义的更通用的处理程序： import React from 'react'; function App() { const [count, setCount] = React.useState(0); function handleCount(delta) { setCount(count + delta); } return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={() =&gt; handleCount(1)}&gt; Increase Count &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; handleCount(-1)}&gt; Decrease Count &lt;/button&gt; &lt;/div&gt; ); } 这样，也可以并行传递事件和参数。即使在此示例中不需要它，但你肯定会在将来遇到需要该事件的一种或另一种情况（例如 React Forms 的 preventDefault ）： import React from 'react'; function App() { const [count, setCount] = React.useState(0); function handleCount(event, delta) { setCount(count + delta); } return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={event =&gt; handleCount(event, 1)}&gt; Increase Count &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={event =&gt; handleCount(event, -1)}&gt; Decrease Count &lt;/button&gt; &lt;/div&gt; ); } 因此，当你需要传递事件和参数时，例如当你需要为 onClick 事件提供额外参数时，内联事件处理程序可能会为你提供帮助。然后 JSX 之外的更通用的事件处理程序可以使用这个额外的参数。 React 中的回调事件处理程序 简而言之，有回调事件处理程序或回调处理程序。当子组件需要与父组件通信时使用它们。由于 React props 只在组件树中向下传递，因此使用回调处理程序（其核心是一个函数）进行向上通信： import React from 'react'; function App() { const [text, setText] = React.useState(''); // 1 function handleTextChange(event) { setText(event.target.value); // 3 } return ( &lt;div&gt; &lt;MyInput inputValue={text} onInputChange={handleTextChange} /&gt; {text} &lt;/div&gt; ); } // 2 function MyInput({ inputValue, onInputChange }) { return ( &lt;input type=&quot;text&quot; value={inputValue} onChange={onInputChange} /&gt; ); } 回调处理程序在某处定义 (1)，在其他地方使用 (2)，但回调到其定义的位置 (3)。这样，就可以从子组件到父组件进行通信。回调处理程序通过 React props 向下传递，并在调用函数时向上通信。 你已经了解了 React 的事件处理程序、内联事件处理程序和回调事件处理程序，以及如何在按钮中为它们的 onClick 事件和在输入字段中为它们的 onChange 事件使用它们。还有其他事件处理程序，例如表单元素的 onSubmit，实际上需要该事件来阻止本机浏览器行为。无论如何，所有这些事件处理程序都有其特定目的。你的目标应该是让你的代码保持可读性和可维护性， ","link":"https://umeimmense.github.io/post/react-de-shi-jian-chu-li"},{"title":"React中的事件冒泡和捕获","content":"前言 本文主题是React事件冒泡和捕获的 。大多数 JavaScript 开发人员可能已经熟悉这个主题，因为它起源于 JavaScript 及其 DOM API。但是，在本文中，我想为 React 中的事件冒泡和捕获整理一些信息。 React 中的事件处理程序可用于侦听特定事件（例如单击事件）。我们将从 React 中的一个函数组件开始，我们使用 React 的 useState Hook 来增加一个计数器： import * as React from 'react'; function App() { const [count, setCount] = React.useState(0); const handleClick = () =&gt; { setCount(count + 1); }; return ( &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; ); } export default App; 在原生 JavaScript 中，这相当于 element.addEventListener('click', handleClick);。 React 中有很多事件。下面显示了鼠标和触摸事件的事件列表： touchstart touchmove touchend mousemove mousedown mouseup click 此特定事件列表按其执行顺序显示。因此，如果在 HTML 元素中添加了 mouseup 和 click 事件侦听器，则 mouseup 事件将在 click 事件之前触发： import * as React from 'react'; function App() { const handleClick = () =&gt; { alert('click'); }; const handleMouseUp = () =&gt; { alert('mouseup'); }; return ( &lt;button type=&quot;button&quot; onClick={handleClick} onMouseUp={handleMouseUp} &gt; Which one fires first? &lt;/button&gt; ); } export default App; 在某些情况下，你可能希望在另一个事件触发时阻止其中一个事件。例如，当触摸事件发生并被处理时，你可能希望阻止所有点击事件。 无论如何，在前面的示例中，所有事件都发生在同一个 HTML 元素上。关于事件冒泡或捕获还没有什么可看的。接下来，让我们探索使用多个 HTML 元素的事件冒泡： import * as React from 'react'; function App() { const [count, setCount] = React.useState(0); const handleCount = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div onClick={handleCount}&gt; &lt;button type=&quot;button&quot; onClick={handleCount}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } export default App; 在这个例子中，按钮似乎被点击了两次，因为计数器增加了 2 而不是 1。然而，发生的事情是包装容器元素也调用了它的事件处理程序。进入在 React 中事件冒泡。 React 中的事件冒泡 下面的示例显示了两个具有相同样式的 HTML 元素。为了简单起见，我们在这里使用内联样式，但是，你可以随意使用更复杂的方式来设置你的 React 应用程序的样式。 无论如何，让我们进入事件冒泡的话题。如你所见，在下一个示例中，只有外部容器元素侦听单击事件，而不是内部容器元素。但无论你是单击外部元素还是内部元素，都会触发事件处理程序： import * as React from 'react'; const style = { padding: '10px 30px', border: '1px solid black', }; function App() { const handleClick = () =&gt; { alert('click'); }; return ( &lt;div style={style} onClick={handleClick}&gt; &lt;div style={style}&gt;Click Me&lt;/div&gt; &lt;/div&gt; ); } export default App; 在 JavaScript 中，这个原理称为事件冒泡。每当在 HTML 元素（例如内部 HTML 元素）上发生事件时，它就会开始运行通过该特定元素的处理程序，然后是其父 HTML 元素（例如外部 HTML 元素，它实际上在其中找到侦听处理程序）的处理程序，然后一直向上遍历每个祖先 HTML 元素，直到它到达文档的根。 在下一个示例中尝试一下，当单击内部 HTML 元素时，两个事件处理程序都会被触发。如果单击外部 HTML 元素，则仅触发外部元素的事件处理程序： import * as React from 'react'; const style = { padding: '10px 30px', border: '1px solid black', }; function App() { const handleOuterClick = () =&gt; { alert('outer click'); }; const handleInnerClick = () =&gt; { alert('inner click'); }; return ( &lt;div style={style} onClick={handleOuterClick}&gt; &lt;div style={style} onClick={handleInnerClick}&gt; Click Me &lt;/div&gt; &lt;/div&gt; ); } export default App; 换句话说，事件从它们的起源开始冒泡整个文档。通过 React 的 useEffect Hook 在文档上添加一个事件监听器，自己验证这种行为： import * as React from 'react'; const style = { padding: '10px 30px', border: '1px solid black', }; function App() { const handleOuterClick = () =&gt; { alert('outer click'); }; const handleInnerClick = () =&gt; { alert('inner click'); }; React.useEffect(() =&gt; { const handleDocumentClick = () =&gt; { alert('document click'); }; document.addEventListener('click', handleDocumentClick); return () =&gt; { document.removeEventListener('click', handleDocumentClick); }; }, []); return ( &lt;div style={style} onClick={handleOuterClick}&gt; &lt;div style={style} onClick={handleInnerClick}&gt; Click Me &lt;/div&gt; &lt;/div&gt; ); } export default App; 因此，如果一个事件从其交互元素中冒出整个文档，那么在某些情况下如何停止冒泡呢？在 React 中输入 stopPropagation React stopPropagation stopPropagation() 方法是 DOM API 的原生方法。由于 React 将事件包装到称为合成事件的 React 版本中，因此该 API 仍然可用于 React 事件，它还可以用于停止事件的传播： import * as React from 'react'; function App() { const [count, setCount] = React.useState(0); const handleCount = (event) =&gt; { setCount((state) =&gt; state + 1); event.stopPropagation(); }; return ( &lt;div onClick={handleCount}&gt; &lt;button type=&quot;button&quot; onClick={handleCount}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } export default App; 我们通过对事件使用 stopPropagation() 方法扩展了前面的示例之一。这样，当按钮被点击时，事件不会冒泡，也不会触发周围容器元素的事件处理程序。 反之，当容器元素被显式点击时（在这种情况下不太可能没有任何进一步的样式），只有容器的事件处理程序会触发。这里容器元素上的 stopPropagation() 有点多余，因为它上面没有事件处理程序。 最佳时机：默认情况下不要停止事件传播。例如，如果你将在项目中的每个按钮上使用 stopPropagation()，但稍后你想在文档级别跟踪用户点击，你将不会再收到这些事件。默认情况下使用 stopPropagation() 往往会导致错误，因此仅在必要时使用它。 当停止事件传播有意义时，让我们看看更复杂的场景。例如，可能有一个可点击的标题，可以将用户从任何页面导航到主页，但是，在标题内有一个按钮可以让用户从应用程序中注销。两个元素都应该是可点击的，不会相互干扰： import * as React from 'react'; const styleHeader = { padding: '10px', border: '1px solid black', boxSizing: 'border-box', width: '100%', display: 'flex', justifyContent: 'space-between', }; function App() { const [isActive, setActive] = React.useState(false); const handleHeaderClick = () =&gt; { alert('header click (e.g. navigate to home page)'); }; const handleButtonClick = (event) =&gt; { alert('button click (e.g. log out user)'); if (isActive) { event.stopPropagation(); } }; return ( &lt;&gt; &lt;div style={styleHeader} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt; Log Out &lt;/button&gt; &lt;/div&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; setActive(!isActive)}&gt; Stop Propagation: {isActive.toString()} &lt;/button&gt; &lt;/&gt; ); } export default App; 在不停止传播的情况下，注销按钮将触发它自己的事件处理程序，但也会触发标题上的事件处理程序，因为事件会冒泡到它上面。当 stopPropagation() 被激活时，单击注销按钮不会导致标题上的冒泡事件，因为该事件被阻止冒泡。 总之，只要有一个带有处理程序的元素嵌套在另一个带有处理程序的元素中，两者都在侦听相同的事件（这里：单击事件），使用 stopPropagation() 将有助于将事件委托给正确的处理程序（通过防止他们从冒泡）。 target &amp;&amp; currentTarget 当单击带有监听器（事件处理程序）的 HTML 元素时，你可以访问它的事件（在 React 中它是合成事件）。在其他属性中，事件可以访问表示导致事件的元素的目标属性。因此，如果按钮具有事件处理程序并且用户单击此按钮，则该事件将以按钮元素作为目标。 即使这个事件冒泡到另一个事件处理程序，如果一个嵌套元素导致了这个事件，那么目标仍然由这个嵌套元素表示。因此，在所有处理程序中，事件的目标都不会改变。 从事件处理程序到事件处理程序的变化是事件的 currentTarget，因为它表示实际事件处理程序正在运行的元素： import * as React from 'react'; const style = { display: 'block', padding: '10px 30px', border: '1px solid black', }; function App() { const handleDivClick = (event) =&gt; { alert(` &lt;div /&gt; \\n event.target: ${event.target} \\n event.currentTarget: ${event.currentTarget} `); }; const handleSpanClick = (event) =&gt; { alert(` &lt;span /&gt; \\n event.target: ${event.target} \\n event.currentTarget: ${event.currentTarget} `); }; return ( &lt;div style={style} onClick={handleDivClick}&gt; &lt;span style={style} onClick={handleSpanClick}&gt; Click Me &lt;/span&gt; &lt;/div&gt; ); } export default App; 通常你将与事件的目标进行交互，例如停止事件的传播或阻止默认行为。但是，有时你希望从正在运行的事件处理程序访问元素，因此你可以改用 currentTarget。 React 中的事件捕获 当谈到 JavaScript 中的事件冒泡时，不得不提的是存在事件捕获的概念。实际上两者都是依次发生的：当用户与元素交互时，DOM API 会向下遍历文档（捕获阶段）到目标元素（目标阶段），然后 DOM API 才会再次向上遍历（冒泡阶段）。 在某些情况下，你可能希望在捕获阶段中的事件到达冒泡阶段之前对其进行拦截。然后，你可以使用 onClickCapture 而不是 onClick 来处理 JSX 中的单击事件，或者使用 addEventListener() 方法的第三个参数来激活在捕获阶段而不是冒泡阶段的监听： function App() { const handleOuterClick = () =&gt; { alert('outer click'); }; const handleInnerClick = () =&gt; { alert('inner click'); }; React.useEffect(() =&gt; { const handleDocumentClick = () =&gt; { alert('document click'); }; document.addEventListener( 'click', handleDocumentClick, true ); return () =&gt; { document.removeEventListener( 'click', handleDocumentClick, true ); }; }, []); return ( &lt;div style={style} onClickCapture={handleOuterClick}&gt; &lt;div style={style} onClickCapture={handleInnerClick}&gt; Click Me &lt;/div&gt; &lt;/div&gt; ); } 谈到“某些情况”有点含糊。因此，让我们回到前面的示例，其中我们将注销按钮嵌套在标题元素中。如果单击该按钮以不触发标头的事件处理程序，则该按钮将停止事件的传播。现在，如果你想通过在顶级文档级别引入分析跟踪来扩展此示例，你可以验证自己对于单击按钮，你不会收到分析跟踪，而只会收到标题，因为按钮阻止了从冒泡到文档的事件： function App() { const handleHeaderClick = () =&gt; { alert('header click (e.g. navigate to home page)'); }; const handleButtonClick = (event) =&gt; { alert('button click (e.g. log out user)'); // important: stops event from appearing // in the document's event handler event.stopPropagation(); }; React.useEffect(() =&gt; { const handleDocumentClick = (event) =&gt; { alert(` document clicked - \\n run analytics for clicked element: ${event.target} `); }; document.addEventListener('click', handleDocumentClick); return () =&gt; { document.removeEventListener('click', handleDocumentClick); }; }, []); return ( &lt;&gt; &lt;div style={styleHeader} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt; Log Out &lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); } 凭借我们对捕获阶段的了解，我们可以在实际用户交互冒泡之前对事件进行分析跟踪。在这种情况下，我们通过将第三个参数设置为 true（使用捕获阶段而不是冒泡阶段）在文档上添加事件侦听器： function App() { const handleHeaderClick = () =&gt; { alert('header click (e.g. navigate to home page)'); }; const handleButtonClick = (event) =&gt; { alert('button click (e.g. log out user)'); // important: stops event from appearing // in the document's event handler event.stopPropagation(); }; React.useEffect(() =&gt; { const handleDocumentClick = (event) =&gt; { alert(` document clicked - \\n run analytics for clicked element: ${event.target} `); }; document.addEventListener( 'click', handleDocumentClick, true ); return () =&gt; { document.removeEventListener( 'click', handleDocumentClick, true ); }; }, []); return ( &lt;&gt; &lt;div style={styleHeader} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt; Log Out &lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); } 当点击注销按钮时，捕获阶段从上到下遍历所有处理程序，从而触发文档级别的处理程序进行分析跟踪。然后它向下遍历元素到目标（此处：按钮），因为没有其他事件处理程序正在侦听捕获阶段（例如，通过使用 onClickCapture 代替）。从那里，事件冒泡并触发按钮的事件处理程序，阻止事件传播到标题的事件处理程序。 在日常工作中，大多数开发人员使用冒泡阶段通过使用事件处理程序来拦截事件，并使用 stopPropagation() 方法阻止事件传播。因此，在开发人员的脑海中，总是有事件模型在 HTML 树中冒泡。然而，正如某些边缘情况所示，了解捕获阶段也是有意义的。 理解 JavaScript 中的事件冒泡对于在 React 中使用它至关重要。每当你有一个复杂的页面，其中带有事件处理程序的伪按钮被包装到其他伪按钮中时，就无法绕过本机 stopPropagation 方法。但是，请谨慎使用它，而不是默认使用它，否则从长远来看，你可能会遇到错误。 ","link":"https://umeimmense.github.io/post/react-shi-jian-mou-pao-he-bu-huo"},{"title":"React 中的浅比较是如何工作的？","content":"前言 浅比较在 React 开发中无处不在。它在不同的流程中起着关键作用，也可以在 React 组件生命周期的多个地方找到。类组件是否应该更新的机制，React hooks 的依赖数组，通过 React.memo 进行记忆等等。 如果你曾经阅读过 React 的官方文档，你很可能已经经常看到浅比较这个术语。因此，本文将研究浅比较的概念，它到底是什么，它是如何工作的。 什么是浅比较？ 理解浅层比较最直接的方法是深入研究它的实现。相应的代码可以在共享子包的 React Github 项目中找到。例如下面的实现： import is from './objectIs'; import hasOwnProperty from './hasOwnProperty'; /** * Performs equality by iterating through keys on an object and returning false * when any key has values which are not strictly equal between the arguments. * Returns true when the values of all keys are strictly equal. */ function shallowEqual(objA: mixed, objB: mixed): boolean { if (is(objA, objB)) { return true; } if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) { return false; } const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) { return false; } // Test for A's keys different from B. for (let i = 0; i &lt; keysA.length; i++) { const currentKey = keysA[i]; if ( !hasOwnProperty.call(objB, currentKey) || !is(objA[currentKey], objB[currentKey]) ) { return false; } } return true; } 这过程中发生了很多事情，所以让我们将其拆分并逐步执行该功能。 function shallowEqual(objA: mixed, objB: mixed): boolean { // ... } 从函数定义开始，函数接受两个将相互比较的实体。与 TypeScript 不同，此代码使用 Flow 作为类型检查系统。两个函数参数都是使用特殊的混合 Flow 类型键入的，类似于 TypeScript 的未知数。它表明参数可以是任何类型的值，该函数将找出其余的并使其工作。 import is from './objectIs'; function shallowEqual(objA: mixed, objB: mixed): boolean { if (is(objA, objB)) { return true; } // ... } 其次，首先使用来自 React 内部对象的 is 函数将函数参数相互比较。导入的函数只不过是 JavaScript 的 Object.is 函数的 polyfill 版本。这个比较函数基本上等同于常见的 === 运算符，但有两个例外： Object.is 认为相反的有符号零（+0 和 -0）不相等，而 === 认为它们相等。 Object.is 认为 Number.NaN 和 NaN 相等，而 === 认为它们不相等。 基本上，第一个条件语句处理所有简单的情况：如果两个函数参数具有相同的值，对于原始类型，或引用相同的对象，对于数组和对象，那么它们被认为是浅比较相等的。 function shallowEqual(objA: mixed, objB: mixed): boolean { // ... if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) { return false; } // ... } 在处理了两个函数参数值相等或引用同一个对象的所有简单情况之后，我们想要进入更复杂的结构（对象和数组）。但是，如果任何一个参数是原始值，前面的条件语句仍然可以给我们留下原始值。 因此，为了确保我们从现在开始处理两个复杂的结构，代码会检查任一参数是否不是对象类型或等于 null。前一个检查确保我们正在处理对象或数组，而后一个检查是过滤掉空值，因为它们的类型也是对象。如果任一条件成立，我们肯定是在处理不相等的参数（否则前面的条件语句会将它们过滤掉），因此浅比较返回 false。 function shallowEqual(objA: mixed, objB: mixed): boolean { // ... const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) { return false; } // ... } 现在可以确定我们只处理数组和对象，我们可以专注于浅比较这些数据结构。为此，我们必须深入研究复杂数据结构的值，并在两个函数参数之间进行比较。 但在我们这样做之前，我们可以通过一个简单的检查来确保两个参数具有相同数量的值。如果不是，则通过浅层比较可以保证它们不相等，这可以节省我们一些精力。为此，我们使用参数的键。对于对象，键数组将由实际键组成，而对于数组，键数组将由字符串中原始数组中占用的索引组成。 import hasOwnProperty from './hasOwnProperty'; function shallowEqual(objA: mixed, objB: mixed): boolean { // ... // Test for A's keys different from B. for (let i = 0; i &lt; keysA.length; i++) { const currentKey = keysA[i]; if ( !hasOwnProperty.call(objB, currentKey) || !is(objA[currentKey], objB[currentKey]) ) { return false; } } return true; } 作为最后一步，我们按键迭代两个函数参数的值，并逐个验证它们以确定它们是否等效。为此，代码使用在上一步中生成的键数组，使用 hasOwnProperty 检查键是否实际上是参数的属性，并使用与比较值之前相同的 Object.is 函数。 如果事实证明任何键在两个参数之间没有等效值，那么通过浅比较可以肯定它们不相等。因此，我们缩短了 for 循环，并从 shallowEqual 函数中返回 false。如果所有值都相等，那么我们可以通过浅比较调用函数参数相等并从函数返回 true。 一些有趣的点 现在我们了解了浅层比较及其背后的实现，我们可以从这些知识中学到一些有趣的东西： 浅比较不使用严格相等、=== 运算符，而是使用 Object.is 函数。 通过浅比较，空对象和数组是等价的。 通过浅比较，以索引为键的对象等效于在各个索引处具有相同值的数组。例如。 { 0: 2, 1: 3 } 等价于 [2, 3]。 由于 Object.is 优于 === 的使用，通过浅比较，+0 和 -0 不等价，NaN 和 Number.NaN 也不等价。- 如果它们在复杂结构内进行比较，这也适用。 虽然两个内联创建的对象（或数组）通过浅比较相等（{} 和 [] 浅相等），但具有嵌套内联对象的内联对象不相等（{ someKey: {} } 和 { someKey: [] } 不浅平等的）。 ","link":"https://umeimmense.github.io/post/react-zhong-de-qian-bi-jiao-shi-ru-he-gong-zuo-de"},{"title":"React Suspense 基本指南","content":"前言 在 React 18 中发布的另一个重要特性是 Suspense。如果你在之前使用过 React ，那么你就会知道 Suspense 功能并不是特别新。早在 2018 年，Suspense 作为 React 16.6 版的一部分作为实验性功能发布。然后，它主要针对与React.lazy。 但是现在，有了 React 18，Suspense 的正式发布就在我们面前。伴随着并发渲染的发布，Suspense 的真正威力终于解锁了。Suspense 和并发渲染之间的交互为改善用户体验开辟了广阔的世界。 但就像所有功能一样，就像并发渲染一样，从基础开始很重要。Suspense 到底是什么？为什么我们首先需要Suspense ？Suspense 如何解决这个问题？有什么好处？为了帮助你理解这些基础知识，本文将详细介绍这些问题，并为你提供有关 Suspense 的知识基础。 什么是Suspense？ 本质上，Suspense 是 React 开发人员向 React 指示组件正在等待数据准备好的一种机制。然后 React 知道它应该等待该数据被获取。同时，将向用户显示一个反馈，并且 React 将继续渲染应用程序的其余部分。数据准备好后，React 会返回到那个特定的 UI 并相应地更新它。 从根本上说，这听起来与 React 开发人员必须实现数据获取流程的当前方式没有太大区别：使用某种状态来指示组件是否仍在等待数据，useEffect开始获取数据，显示加载状态基于数据的状态，并在数据准备好后更新 UI。 但在实践中，Suspense 使这在技术上完全不同。与上面提到的数据获取流程相反，Suspense 与 React 深度集成，允许开发人员更直观地编排加载状态，并避免竞争条件。为了更好地理解这些细节，了解我们为什么需要 Suspense 很重要。 为什么我们需要Suspense？ 在没有 Suspense 的情况下，实现数据获取流程的主要方法有两种：渲染时获取和渲染后获取。但是，这些传统的数据获取流程存在一些问题。要了解 Suspense，我们必须深入研究这些流程的问题和局限性。 渲染时获取 useEffect大多数人将使用和状态变量来实现前面提到的数据获取流程。这意味着只有在组件呈现时才开始获取数据。所有数据获取都发生在组件的副作用和生命周期方法中。 这种方法的主要问题是:组件仅在渲染时触发数据获取，异步特性迫使组件必须等待其他组件的数据请求。 假设我们有一个ComponentA获取一些数据并具有加载状态的组件。在内部，ComponentA还呈现另一个组件ComponentB，该组件也自己执行一些数据获取。但是由于数据获取的实现方式，ComponentB只有在渲染时才开始获取数据。这意味着它必须等到ComponentA完成获取数据然后渲染ComponentB。 这导致了瀑布式方法，其中组件之间的数据获取顺序发生，这实质上意味着它们相互阻塞。 function ComponentA() { const [data, setData] = useState(null); useEffect(() =&gt; { fetchAwesomeData().then(data =&gt; setData(data)); }, []); if (user === null) { return &lt;p&gt;Loading data...&lt;/p&gt;; } return ( &lt;&gt; &lt;h1&gt;{data.title}&lt;/h1&gt; &lt;ComponentB /&gt; &lt;/&gt; ); } function ComponentB() { const [data, setData] = useState(null); useEffect(() =&gt; { fetchGreatData().then(data =&gt; setData(data)); }, []); return data === null ? &lt;h2&gt;Loading data...&lt;/h2&gt; : &lt;SomeComponent data={data} /&gt;; } 渲染后获取 为了防止组件之间数据获取的顺序阻塞，一种替代方法是尽早开始所有数据获取。因此，与其让组件负责处理渲染时的数据获取，而且数据请求都单独发生，而是在树开始渲染之前启动所有请求。 这种方法的优点是所有数据请求都是一起发起的，因此ComponentB不必等待ComponentA完成。这解决了组件顺序阻塞彼此数据流的问题。但是，它引入了另一个问题，我们必须等待所有数据请求完成，然后才能为用户呈现任何内容。可以想象，这不是最佳体验。 // Start fetching before rendering the entire tree function fetchAllData() { return Promise.all([ fetchAwesomeData(), fetchGreatData() ]).then(([awesomeData, greatData]) =&gt; ({ awesomeData, greatData })) } const promise = fetchAllData(); function ComponentA() { const [awesomeData, setAwesomeData] = useState(null); const [greatData, setGreatData] = useState(null); useEffect(() =&gt; { promise.then(({ awesomeData, greatData }) =&gt; { setAwesomeData(awesomeData); setGreatData(greatData); }); }, []); if (user === null) { return &lt;p&gt;Loading data...&lt;/p&gt;; } return ( &lt;&gt; &lt;h1&gt;{data.title}&lt;/h1&gt; &lt;ComponentB /&gt; &lt;/&gt; ); } function ComponentB({data}) { return data === null ? &lt;h2&gt;Loading data...&lt;/h2&gt; : &lt;SomeComponent data={data} /&gt;; } Suspense 如何解决数据获取问题？ 从本质上讲，**fetch-on-render **和 fetch-then-render 的主要问题归结为我们试图强制同步两个不同的流程，即数据获取流程和 React 生命周期。借助 Suspense，我们获得了一种不同类型的数据获取方法，即所谓的 render-as-you-fetch 方法。 const specialSuspenseResource = fetchAllDataSuspense(); function App() { return ( &lt;Suspense fallback={&lt;h1&gt;Loading data...&lt;/h1&gt;}&gt; &lt;ComponentA /&gt; &lt;Suspense fallback={&lt;h2&gt;Loading data...&lt;/h2&gt;}&gt; &lt;ComponentB /&gt; &lt;/Suspense&gt; &lt;/Suspense&gt; ); } function ComponentA() { const data = specialSuspenseResource.awesomeData.read(); return &lt;h1&gt;{data.title}&lt;/h1&gt;; } function ComponentB() { const data = specialSuspenseResource.greatData.read(); return &lt;SomeComponent data={data} /&gt;; } 与之前实现的不同之处在于它允许组件在 React 到达它的那一刻启动数据获取。这甚至发生在组件渲染之前，并且 React 并没有就此停止。然后它继续评估组件的子树，并在等待数据获取完成时继续尝试渲染它。 这意味着 Suspense 不会阻塞渲染，这意味着子组件不必等待父组件完成后再发起其数据获取请求。React 尝试尽可能多地渲染，同时启动适当的数据获取请求。请求完成后，React 将重新访问相应的组件并使用新接收的数据相应地更新 UI。 Suspense有什么好处？ 尽早开始获取数据。Suspense 引入的 render-as-you-fetch 方法最大和最直接的好处是数据获取尽早启动。这意味着用户必须等待的时间更少，应用程序更快，这对任何前端应用程序都是普遍有益的。 更直观的加载状态。使用 Suspense，组件不必再包含大量的 if 语句或单独跟踪状态来实现加载状态。相反，加载状态被集成到它所属的组件本身中。这使得组件更直观，通过保持加载代码接近相关代码，并且更可重用，因为加载状态包含在组件中。 避免竞争条件。我没有在本文中深入讨论的现有数据获取实现的问题之一是竞争条件。在某些情况下，传统的 fetch-on-render 和 fetch-then-render 实现可能会导致竞争条件，具体取决于时间、用户输入和参数化数据请求等不同因素。主要的潜在问题是我们试图强制同步两个不同的进程，React 和数据获取。但是使用 Suspense，这可以更优雅、更集成地完成，从而避免了上述问题。 更集成的错误处理。使用 Suspense，我们基本上已经为数据请求流创建了边界。最重要的是，由于 Suspense 使其与组件代码的集成更加直观，它允许 React 开发人员还为 React 代码和数据请求实现更集成的错误处理。 总结 React Suspense 已经被关注了 3 年多。但是随着 React 18 的发布，官方发布的时间越来越近了。除了并发渲染，它将是作为 React 版本的一部分发布的最大功能之一。就其本身而言，它可以将数据获取和加载状态实现提升到一个新的直观和优雅水平。 为了帮助你了解 Suspense 的基础知识，本文介绍了几个对其很重要的问题和方面。这涉及到 Suspense 是什么，为什么我们首先需要像 Suspense 这样的东西，它如何解决某些数据获取问题以及 Suspense 带来的所有好处。 ","link":"https://umeimmense.github.io/post/react-suspense-ji-ben-zhi-nan"},{"title":"React 18 中的自动批处理","content":"前言 React 18 支持对状态更新的自动批处理支持。 这有助于避免在 Promise、setTimeout、setInterval、原生事件处理程序以及react事件处理程序中多次渲染状态更新。 因此，由于自动批处理，我们在React 应用程序中获得了开箱即用的性能改进。 什么是（自动）批处理？ 批处理是将多个状态更新分组为单个更新的过程。 如果我们有多个调用来设置组件的状态，React 会将这些更新组合在一个更新调用（称为批处理）中，从而导致组件的一次重新渲染。 当 React 自动计算出这一点并批量更新状态时，它被称为自动批处理，下面让我们通过探究更新状态的各种方式来看看它是如何工作的？ React 17 及之前的事件处理程序的状态更新 让我们举个例子来了解在 React 17 中事件处理程序上的状态更新时渲染是如何发生的？ const Counter = () =&gt; { const [count, setCount] = useState(0); const [showModal, setShowModal] = useState(false); const handleClick = () =&gt; { setCount(count + 1); setShowModal((prev) =&gt; !prev); // React renders once at the end (that's batching) }; console.log('rendered component'); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;p&gt;{`Show modal? ${showModal}`}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt; ); } 现在，我们可以看到有两个状态更新调用。 一个用于 setCount，另一个用于 setShowModal。 但是，react 确保最后只调用一个渲染。 如果更新不是批处理的，它会以不成熟方式渲染组件，导致 UI 闪烁。 即我们希望我们的组件仅在更新计数和更新 showModal 标志后才呈现。 React 17 及之前的 Promise 和原生事件处理程序的状态更新 自动批处理不适用于promise/非react处理程序（如 setTimeout、setInterval 等）中的状态更新。 const Counter = () =&gt; { const [count, setCount] = useState(0); const [showModal, setShowModal] = useState(false); const handleClick = () =&gt; { console.log('fetch called'); fetch('https://jsonplaceholder.typicode.com/todos/1') .then(() =&gt; { setCount(count + 1); // Re-render is called setShowModal((prev) =&gt; !prev); // Re-render is called }) }; console.log('rendered component'); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;p&gt;{`Show modal? ${showModal}`}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click me now&lt;/button&gt; &lt;/div&gt; ); } 通常，我们调用 API 请求来获取某些内容并根据 API 请求的响应在回调中执行状态更新。 正如我们在上面的示例中看到的，有 2 次调用来设置回调中的状态，导致 2 次重新渲染。 这是一个性能瓶颈。 这可能会导致 UI 闪烁，从而呈现部分状态更新的结果。 React 18+ 中 Promise 和原生事件处理程序的状态更新 React 通过为 Promise、setTimeout 和 setInterval、原生事件处理程序以及默认的 react 事件处理程序中的状态更新提供自动批处理支持来解决此问题。 注意：对于这个例子，我们已经更新了如下所示的 react 和 react-dom 库版本。 https://unpkg.com/react@18.0.0-beta-24dd07bd2-20211208/umd/react.development.js https://unpkg.com/react-dom@18.0.0-beta-24dd07bd2-20211208/umd/react-dom.development.js 如果我们采用与上面给出的相同示例，我们可以在下面看到渲染的数量。 const Counter = () =&gt; { const [count, setCount] = useState(0); const [showModal, setShowModal] = useState(false); const handleClick = () =&gt; { console.log('fetch called'); fetch('https://jsonplaceholder.typicode.com/todos/1') .then(() =&gt; { setCount(count + 1); setShowModal((prev) =&gt; !prev); // React 18 renders once at the end (that's automatic batching) }) }; console.log('rendered component'); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;p&gt;{`Show modal? ${showModal}`}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt; ); } 注意：我们需要将渲染升级为createRoot。 对于上面给出的示例，我们渲染了 Counter 组件，如下所示。 我们使用 ReactDOM.createRoot 创建了根，然后在其上渲染了 Counter 组件。 ","link":"https://umeimmense.github.io/post/react-18-zhong-de-zi-dong-pi-chu-li"},{"title":"探索 React 18 的三个新 API","content":"前言 目前 React 生态系统中最大的话题是 React 18 及其备受期待的并发渲染功能的完整发布。 2021 年 6 月，React 团队宣布了 React 18 的计划以及即将发生的事情。 2021年 12 月，React Conf 2021 的主题是所有新发布的并发渲染功能。 与 React 18 一起发布的几个新 API 允许用户充分利用 React 的并发渲染功能。 这些hook是： useSyncExternalStore useId useInsertionEffect 本文将介绍这三个新 API、它们的用例、它们解决的问题、添加它们的原因以及它们如何集成到并发渲染领域。 the-usesyncexternalstore-hook 在 React v16.14.0 中引入的用于适应并发渲染的 API 之一是 useMutableSource，它旨在允许 React 组件在并发渲染期间安全有效地与外部可变源集成。 Hook 将附加到数据源，等待更改，并相应地安排更新。 所有这一切都会以一种防止撕裂的方式发生，即当出现视觉不一致时，因为同一状态有多个值。 这对于新的并发渲染特性来说是一个特别突出的问题，因为状态流可以很快地交织在一起。 然而，采用 useMutableSource 被证明是困难的，原因如下： Hook 是异步的 Hook 不知道如果选择器函数的结果值发生变化，它是否可以重用它。 唯一的解决方案是重新订阅提供的数据源并再次检索快照，这可能会导致性能问题，因为它发生在每次渲染上。 对于用户和库（如 Redux），这意味着他们必须记住项目中的每个选择器，并且无法内联定义选择器函数，因为它们的引用不稳定。 它必须处理外部状态 最初的实现也有缺陷，因为它必须处理 React 之外的状态。 这意味着由于其可变性，状态可能随时更改。 因为 React 试图以异步方式解决这个问题，这有时会导致 UI 的可见部分被替换为备用，从而导致次优的用户体验。 所有这一切都使得库维护者的迁移变得痛苦，并且对开发人员和用户来说都是次优的体验。 使用 useSyncExternalStore 解决这些问题 为了解决这些问题，React 团队更改了底层实现并将 Hook 重命名为 useSyncExternalStore 以正确反映其行为。 这些变化包括： 每次选择器（用于快照）更改时都不会重新订阅外部源——相反，React 将比较选择器的结果值，而不是选择器函数，以决定是否再次检索快照，以便用户可以定义 选择器内联而不会对性能产生负面影响 每当外部存储发生更改时，生成的更新现在始终是同步的，这可以防止 UI 被替换为回退 唯一的要求是 getSnapshot Hook 参数的结果值需要是引用稳定的。 React 在内部使用它来确定是否需要检索新快照，因此它需要是不可变值或记忆/缓存对象。 为了方便起见，React 将提供一个附加版本的 Hook，它自动支持对 getSnapshot 的结果值的记忆。 如何使用 useSyncExternalStore // Code illustrating the usage of `useSyncExternalStore`. // Source: &lt;https://github.com/reactwg/react-18/discussions/86&gt; import {useSyncExternalStore} from 'react'; // React will also publish a backwards-compatible shim // It will prefer the native API, when available import {useSyncExternalStore} from 'use-sync-external-store/shim'; // Basic usage. getSnapshot must return a cached/memoized result const state = useSyncExternalStore(store.subscribe, store.getSnapshot); // Selecting a specific field using an inline getSnapshot const selectedField = useSyncExternalStore(store.subscribe, () =&gt; store.getSnapshot().selectedField); // Code illustrating the usage of the memoized version. // Source: &lt;https://github.com/reactwg/react-18/discussions/86&gt; // Name of API is not final import {useSyncExternalStoreWithSelector} from 'use-sync-external-store/with-selector'; const selection = useSyncExternalStoreWithSelector( store.subscribe, store.getSnapshot, getServerSnapshot, selector, isEqual ); The useId Hook 在服务器端运行 React 长期以来，一个 React 项目只在客户端运行。简而言之，这意味着所有代码都被发送到用户的浏览器（客户端），然后浏览器负责向用户呈现和显示应用程序。 React 作为一个整体一直在向服务器端渲染（SSR）领域扩展。在 SSR 中，服务器负责根据 React 代码生成 HTML 结构。而不是所有的 React 代码，只有 HTML 被发送到浏览器。 然后，浏览器只负责采用该结构并通过渲染组件、在其上添加 CSS 并将 JavaScript 附加到它来使其具有交互性。这个过程称为水合作用。 hydration 最重要的要求是服务器和客户端生成的 HTML 结构必须匹配。如果他们不这样做，浏览器就无法确定它应该对结构的特定部分做什么，这会导致不正确地呈现或非交互式 UI。 这在依赖于标识符的特性中尤为突出，因为它们必须在两边都匹配，例如在生成唯一样式类名称和可访问性标识符时。 useID Hook 的演进 为了解决这个问题，React 最初引入了 useOpaqueIdentifier Hook，但不幸的是，它也存在一些问题： 在不同的环境中，Hooks 会产生不同的输出（不透明）： 服务器端：它会产生一个字符串 客户端：它会产生一个特殊的对象，必须直接传递给 DOM 属性 这意味着 Hook 只能生成一个标识符，并且不可能动态生成新的 ID，因为它必须遵守 Hook 的规则。 因此，如果您的组件需要 X 个不同的标识符，它必须在不同的时间调用 Hook X，这在实践中显然不能很好地扩展。 // Code illustrating the way `useOpaqueIdentifier` handles the need for N identifiers in a single component, namely calling the hook N times. // Source: &lt;https://github.com/facebook/react/pull/17322#issuecomment-613104823&gt; function App() { const tabIdOne = React.unstable_useOpaqueIdentifier(); const panelIdOne = React.unstable_useOpaqueIdentifier(); const tabIdTwo = React.unstable_useOpaqueIdentifier(); const panelIdTwo = React.unstable_useOpaqueIdentifier(); return ( &lt;React.Fragment&gt; &lt;Tabs defaultValue=&quot;one&quot;&gt; &lt;div role=&quot;tablist&quot;&gt; &lt;Tab id={tabIdOne} panelId={panelIdOne} value=&quot;one&quot;&gt; One &lt;/Tab&gt; &lt;Tab id={tabIdTwo} panelId={panelIdTwo} value=&quot;one&quot;&gt; One &lt;/Tab&gt; &lt;/div&gt; &lt;TabPanel id={panelIdOne} tabId={tabIdOne} value=&quot;one&quot;&gt; Content One &lt;/TabPanel&gt; &lt;TabPanel id={panelIdTwo} tabId={tabIdTwo} value=&quot;two&quot;&gt; Content Two &lt;/TabPanel&gt; &lt;/Tabs&gt; &lt;/React.Fragment&gt; ); } 某些可访问性 API（如 aria-labelledby）可以通过空格分隔的列表接受多个标识符，但由于 Hook 的输出被格式化为不透明的数据类型，它总是必须直接附加到 DOM 属性。这意味着无法正确使用上述可访问性 API。 为了解决这个问题，实现已更改并重命名为 useId。这个新的 Hook API 在 SSR 和 hydration 期间生成稳定的标识符以避免不匹配。在服务器渲染的内容之外，它回退到一个全局计数器。 与使用 useOpaqueIdentifier 创建不透明数据类型（服务器中的特殊对象和客户端中的字符串）不同，useId Hook 会在两侧生成非透明字符串。 这意味着如果我们需要 X 个不同的 ID，就没有必要再调用 Hook X 次了。相反，组件可以调用 useId 一次并将其用作整个组件所需的标识符的基础（例如，使用后缀），因为它只是一个字符串。这解决了 useOpaqueIdentifier 中存在的两个问题。 如何使用 useID 下面的代码示例说明了如何根据我们上面讨论的内容使用 useId。 因为 React 生成的 ID 是全局唯一的，并且后缀是本地唯一的，所以动态创建的 ID 也是全局唯一的——因此不会导致任何水合不匹配。 // Code illustrating the improved way in which `useId` handles the need for N identifiers in a single component, namely calling the hook once and creating them dynamically. // Source: &lt;https://github.com/reactwg/react-18/discussions/111&gt; function NameFields() { const id = useId(); return ( &lt;div&gt; &lt;label htmlFor={id + '-firstName'}&gt;First Name&lt;/label&gt; &lt;div&gt; &lt;input id={id + '-firstName'} type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;label htmlFor={id + '-lastName'}&gt;Last Name&lt;/label&gt; &lt;div&gt; &lt;input id={id + '-lastName'} type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;/div&gt; ); } The useInsertionEffect Hook . CSS-in-JS 库的问题 最后一个将在 React 18 中添加的 Hook——我们将在这里讨论——是 useInsertionEffect。这个与其他的略有不同，因为它的唯一目的对于动态生成新规则并在文档中插入带有 &lt;style&gt; 标记的 CSS-in-JS 库很重要。 在某些场景下，&lt;style&gt;标签需要在客户端生成或编辑，如果不仔细处理，可能会导致并发渲染的性能问题。这是因为在添加或删除 CSS 规则时，浏览器必须检查这些规则是否适用于现有树。它必须重新计算所有样式规则并重新应用它们——而不仅仅是改变的规则。如果 React 发现另一个组件也生成了新规则，那么同样的过程将再次发生。 这实际上意味着在 React 渲染时，必须针对每一帧的所有 DOM 节点重新计算 CSS 规则。虽然你很有可能不会遇到这个问题，但它的规模并不大。 从理论上讲，有一些方法主要与时间有关。这个时间问题的最佳解决方案是在对 DOM 进行所有其他更改的同时生成这些标签，就像 React 库那样。最重要的是，它应该发生在任何尝试访问布局之前以及所有内容呈现给浏览器进行绘制之前。 这听起来像是 useLayoutEffect 可以解决的问题，但问题是同一个 Hook 将用于读取布局和插入样式规则。这可能会导致不希望的行为，例如在一次通过中多次计算布局或读取不正确的布局。 useInsertionEffect 如何解决并发渲染问题 为了解决这个问题，React 团队引入了 useInsertionEffect Hook。 它与 useLayoutEffect Hook 非常相似，但它无法访问 DOM 节点的 refs。 这意味着只能插入样式规则。 它的主要用例是插入全局 DOM 节点，如 &lt;style&gt; 或 SVGs &lt;defs&gt;。 由于这仅与在客户端生成标签有关，因此 Hook 不会在服务器上运行。 // Code illustrating the way `useInsertionEffect` is used. // Source: &lt;https://github.com/reactwg/react-18/discussions/110&gt; function useCSS(rule) { useInsertionEffect(() =&gt; { if (!isInserted.has(rule)) { isInserted.add(rule); document.head.appendChild(getStyleForRule(rule)); } }); return rule; } function Component() { let className = useCSS(rule); return &lt;div className={className} /&gt;; } React 18 最令人期待的特性是它的并发渲染特性。 随着团队的宣布，我们收到了新的 API，允许用户根据他们的用例采用并发渲染功能。 虽然有些是全新的，但有些是基于社区反馈的先前 API 的改进版本。 在本文中，我们介绍了三个最新的 API，即 useSyncExternalStore、useId 和 useInsertionEffect Hooks。 我们查看了它们的用例、它们解决的问题、与以前的版本相比为什么需要进行某些更改，以及它们用于并发渲染的目的。 React 18 充满了新功能，绝对值得期待！ ","link":"https://umeimmense.github.io/post/tan-suo-react-18-de-san-ge-xin-api"},{"title":"React 18 并发（Concurrent）渲染的入门指南","content":"前言 目前 React 领域最热门的话题是 React 18 版本。 特别是，该版本将引入一组所谓的并发渲染功能。 这些特性允许开发者选择 React 的并发渲染机制。 这种机制为 React 开发人员提供了一个全新的机会来控制和优化最终用户的体验。 这绝对是自 hooks 以来，我们在 React 世界中将收到的最令人兴奋的事情之一。 因此，你很可能以前听说过并发渲染。 可能是关于它的文章、围绕它的 API，或者 React 18 将为它带来什么。 但是，你可能会对并发渲染的基础知识感到疑惑。 究竟什么是并发渲染，为什么我们真的需要它？ 为了帮助你理解，本文将讨论这些问题。 通过研究它的目的、它试图解决什么问题以及它是如何解决它的，你将获得有关并发渲染主题的基础知识。 为什么我们需要并发渲染？ React 当前形式的问题之一是所有状态更新都是同步的。 这意味着 React 只能一一处理它们。 在许多用例和现实生活场景中，这非常好，不会对用户体验施加任何限制。 但是在 React 想要获取与其当前正在处理的状态更新不同的状态更新的情况下，现在这显然是不可能的。 React 在启动后无法中断、暂停或放弃渲染更新——这是一个阻塞的进程。 从本质上讲，这对优化用户体验的过程设置了上限。 虽然很高，但还是有上限的。 每个状态更新都被视为同等重要，即使这不适用于用户体验。 某些更新可能比其他更新具有更高的优先级或紧迫性。 与可能的情况相比，不能这样做实际上会对用户体验产生巨大的负面影响，这是次优的。 什么是并发渲染？ 并发渲染是一组功能，允许你的 React 项目选择所谓的可中断渲染。 与之前 React 被阻塞的渲染过程相反，这使得渲染过程可以从 React 端中断，这正是并发渲染的用武之地。这为 React 开发人员进一步提升 React 应用程序的用户体验开辟了许多新的可能性。 它允许 React 一次处理多个状态更新。 然而，这并不意味着 React 会突然同时执行所有排队状态更新。 相反，选择并发渲染允许 React 考虑其最佳行动方案。 幸运的是，这也是我们作为开发人员可以控制的事情。 假设 React 当前正在处理状态更新并且有一个不同的更新进来，那么 React 可以根据变量的因素做出不同的决定。 如果新的传入状态更新被标记为同等或不那么紧急，那么与之前的渲染过程相比没有任何变化。 React 将像往常一样继续当前状态更新。 完成后，它将获取新的状态更新。 但是如果新传入的状态更新被标记为更紧急，那么 React 可以决定暂停当前状态更新并首先处理传入的更新。 在完成新的更紧急的状态更新后，React 会回到原来的状态更新。 如果它确定有必要恢复它，它会这样做。 如果事实证明状态更新现在无关紧要，它可以决定完全放弃它。 下一步是什么？ 本文简要介绍了 React 18 将为 React 开发领域带来的最激动人心的功能之一，即并发渲染，并让你快速了解整个主题。 使用本文中的知识，你应该知道什么是并发渲染，了解它试图解决的问题，并大致了解它的工作原理。 幸运的是，并发渲染并不止于此。 虽然并发渲染还有很多方面需要理解或深入研究，但本文作为介绍以进入整个主题，并允许你从这里开始进一步探索 React 18。 下面准备了一些资料 这里介绍了 React 18 中引入的三个新 API。所有这些 API 都是允许某些开发人员在某些场景中选择并发渲染的hook。 官方的 React 18 公告是了解更多关于 React 18、不同特性、如何采用它以及关于即将发布的 React 版本的所有信息的好地方。 React 工作组是了解更多技术方面、获得更多指导、了解不同 API 和特性背后的思维过程以及总体上更深入地了解 React 18 中所有内容的好地方。 这就是全部！ 现在你已经牢牢掌握了并发渲染的主题，在 React 18 中为你打开了一个全新的世界供你探索。走出去，探索并享受这个新的冒险！ ","link":"https://umeimmense.github.io/post/concurrent-rendering"},{"title":"React Router 6：搜索参数","content":"前言 本文我们讨论如何在 React Router 6 中使用搜索参数。搜索参数是一项强大的功能，它使你能够捕获 URL 中的状态。通过在 URL 中包含状态，你可以与其他人实现共享。例如，如果应用程序显示产品目录，开发人员将使用户能够搜索它。在 React 中，这将转换为项目列表（此处为：产品）和用于过滤它们的 HTML 输入字段。 现在，React 开发人员很有可能会使用 React 的 useState Hook 来管理这种搜索状态。这对这个用户来说很好，但不适合与其他用户共享。 因此，一个不错的方式是在 URL 中管理搜索状态，因为这样搜索状态就可以与其他用户共享。如果一个用户按标题（例如“Rust”）搜索项目列表，则搜索参数将作为键值对附加到 URL，例如 /bookshelf?title=Rust，因为可以与另一个用户共享。所以获得链接的其他用户将在其页面上看到相同的过滤项目列表。 React Router 从状态到 URL 首先，我们将实现上一个所设想的那样，其中有一个项目列表，并通过 HTML 输入字段进行搜索。我们不会使用 React 的 useState Hook 来捕获搜索状态，而是使用 React Router 来获取可共享的 URL。 App 组件如下所示，类似于前面提到的 React Router 教程中的 App 组件： const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/bookshelf&quot;&gt;Bookshelf&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;bookshelf&quot; element={&lt;Bookshelf /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 虽然 Home 和 NoMatch 组件只是具有任何实现的占位符组件，但我们将关注 Bookshelf 组件，它将Books显示为列表组件。这些Books示例数据可以从远程 API（或模拟 API）获取： const Bookshelf = () =&gt; { const books = [ { title: 'The Road to Rust', isCompleted: false, }, { title: 'The Road to React', isCompleted: true, }, ]; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;ul&gt; {books.map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 为了使用户能够通过不区分大小写的标题匹配来过滤此列表，我们使用 React 的 useState Hook 和 HTML 输入字段。最后，事件处理程序将从输入字段中读取值并将其写入状态： const byTitle = (title) =&gt; (book) =&gt; book.title.toLowerCase().includes((title || '').toLowerCase()); const Bookshelf = () =&gt; { const books = [...]; const [title, setTitle] = React.useState(''); const handleTitle = (event) =&gt; { setTitle(event.target.value); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={title} onChange={handleTitle} /&gt; &lt;ul&gt; {books.filter(byTitle(title)).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 这就是就是“在 React 中使用状态”的版本。接下来，我们要使用 React Router 来在 URL 中捕获此状态。React Router 为我们提供了 useSearchParams hook，它几乎可以用来替代 React 的 useState hook： import * as React from 'react'; import { Routes, Route, Link, useSearchParams, } from 'react-router-dom'; ... const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useSearchParams(); const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={search.get('title')} onChange={handleTitle} /&gt; &lt;ul&gt; {books.filter(byTitle(search.get('title'))).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 由于以下两点，它不能直接替代 React 的 useState Hook。首先，它对一个对象而不是字符串进行操作，因为一个 URL 可以有多个搜索参数（例如 /bookshelf?title=Rust&amp;rating=4），因此每个搜索参数都成为该对象中的一个属性（例如{ title: 'Rust', rating: 4 })。 如果我们将 React 的 useState Hook 与对象而不是字符串一起使用，它本质上与我们之前的实现类似： const [search, setSearch] = React.useState({ title: '' }); 然而，即使 useSearchParams 返回的有状态值是对象类型（typeof search === 'object'），它仍然不能像单纯的 JavaScript 对象数据结构那样访问，因为它是 URLSearchParams 的一个实例。因此我们需要调用它的 getter 方法（例如 search.get('title')）。 其次，React Router 的 useSearchParams Hook 不接受初始状态，因为初始状态来自 URL。因此，当用户与搜索参数（例如 /bookshelf?title=Rust）共享 URL 时，另一个用户将从 React Router 的 Hook 获得 { title: 'Rust' } 作为初始状态。当应用程序将用户导航到带有搜索参数且设置了可选搜索参数的路线时，也会发生同样的情况。 这就是使用状态的 URL 而不是使用 React 的状态管理 Hook 之一。它极大地改善了用户体验，因为 URL 变得更加特定于用户在页面上看到的内容。因此，这个特定的 URL 可以与其他用户共享，他们将看到具有相同 UI 的页面。 URLSEARCHPARAMS 转换为对象 如果你在处理 React Router 的 useSearchParams Hook 时不想使用 URLSearchParams，你可以编写一个自定义hook，它返回一个 JavaScript 对象而不是 URLSearchParams 的实例： const useCustomSearchParams = () =&gt; { const [search, setSearch] = useSearchParams(); const searchAsObject = Object.fromEntries( new URLSearchParams(search) ); return [searchAsObject, setSearch]; }; const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useCustomSearchParams(); const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={search.title} onChange={handleTitle} /&gt; &lt;ul&gt; {books.filter(byTitle(search.title)).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 然而，这个自定义hook应该有一点不足，因为它不适用于重复键（例如带有 ?editions=1&amp;editions=3 的数组搜索参数）和使用复杂 URL 时的其他边界情况。 一般来说，仅使用 React Router 的 useSearchParams Hook（或这个自定义的 useCustomSearchParams hook）并不能为你提供 URL 状态管理的完整体验，因为它仅可用于字符串而不能用于其他数据类型。我们将在接下来的部分中探讨这一点以及如何解决这个问题。 搜索参数与保留数据类型 并非所有状态都只包含字符串。在前面使用 React Router 的搜索参数的例子中，我们使用了一个字符串（这里是：title），它被编码到 URL 中。当从 URL 解码这个字符串时，我们将默认得到一个字符串——这在我们的例子中有效，因为我们需要一个字符串。但是其他原始数据类型如数字或布尔值呢？更不用说复杂的数据类型，例如数组。 为了探索解决这个，我们将通过实现一个复选框来继续之前的示例。我们将使用这个复选框组件并将其连接到 React Router 的搜索参数： const bySearch = (search) =&gt; (book) =&gt; book.title .toLowerCase() .includes((search.title || '').toLowerCase()) &amp;&amp; book.isCompleted === search.isCompleted; const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useCustomSearchParams(); const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }); }; const handleIsCompleted = (event) =&gt; { setSearch({ isCompleted: event.target.checked }); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={search.title} onChange={handleTitle} /&gt; &lt;Checkbox label=&quot;Is Completed?&quot; value={search.isCompleted} onChange={handleIsCompleted} /&gt; &lt;ul&gt; {books.filter(bySearch(search)).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 在浏览器中实验以下。你将看到对 isCompleted 布尔值的搜索不起作用，因为来自我们的搜索对象的 isCompleted 被表示为一个字符串，如“true”或“false”。我们可以通过增强我们的自定义hook来规避这一点： const useCustomSearchParams = (param = {}) =&gt; { const [search, setSearch] = useSearchParams(); const searchAsObject = Object.fromEntries( new URLSearchParams(search) ); const transformedSearch = Object.keys(param).reduce( (acc, key) =&gt; ({ ...acc, [key]: param[key](acc[key]), }), searchAsObject ); return [transformedSearch, setSearch]; }; const PARAMS = { BooleanParam: (string = '') =&gt; string === 'true', }; const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useCustomSearchParams({ isCompleted: PARAMS.BooleanParam, }); ... return (...); }; 本质上，新版本的自定义hook采用具有可选转换功能的对象。它遍历每个转换函数，如果找到转换函数和搜索参数之间的匹配项，则将该函数应用于搜索参数。在这种情况下，我们将字符串布尔值（“true”或“false”）转换为实际的布尔值。如果没有找到匹配项，它只返回原始搜索参数。因此我们不需要标题的转换函数，因为它是一个字符串并且可以继续为字符串。 通过拥有自定义hook的实现细节，我们还可以创建其他转换器函数（例如 NumberParam），从而填补缺失数据类型转换（例如数字）的空白： const PARAMS = { BooleanParam: (string = '') =&gt; string === 'true', NumberParam: (string = '') =&gt; (string ? Number(string) : null), // other transformation functions to map all data types }; 开源组件中use-query-params这个库完美的解决这个问题。 React Router 使用搜索参数 use-query-params 库非常适合将复杂的 URL 用作超越字符串的状态的用例。在本节中，我们将探索 use-query-params 库，从而摆脱我们自定义的 useSearchParams hook。 自己按照库的安装说明进行操作。你需要在命令行上安装该库并在 React 项目的根级别实例化它： import React from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter, Route } from 'react-router-dom'; import { QueryParamProvider } from 'use-query-params'; import App from './App'; ReactDOM.render( &lt;BrowserRouter&gt; &lt;QueryParamProvider ReactRouterRoute={Route}&gt; &lt;App /&gt; &lt;/QueryParamProvider&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ); 然而， use-query-params 还没有正确适应 React Router 6。因此，你可能会看到以下错误弹出：“ 仅用作 元素的子元素，永远不会直接呈现。请将你的 包装在 中。”。因此，在根级别调整你的代码： import React from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter, useNavigate, useLocation, } from 'react-router-dom'; import { QueryParamProvider } from 'use-query-params'; import App from './App'; const RouteAdapter = ({ children }) =&gt; { const navigate = useNavigate(); const location = useLocation(); const adaptedHistory = React.useMemo( () =&gt; ({ replace(location) { navigate(location, { replace: true, state: location.state }); }, push(location) { navigate(location, { replace: false, state: location.state }); }, }), [navigate] ); return children({ history: adaptedHistory, location }); }; ReactDOM.render( &lt;BrowserRouter&gt; &lt;QueryParamProvider ReactRouterRoute={RouteAdapter}&gt; &lt;App /&gt; &lt;/QueryParamProvider&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ); 现在你可以使用 use-query-params 在 React 中进行强大的 URL 状态管理。你所要做的就是使用新的 useQueryParams 钩子。另请注意，与我们的自定义钩子相比，你还需要“转换”字符串搜索参数： import * as React from 'react'; import { Routes, Route, Link } from 'react-router-dom'; import { useQueryParams, StringParam, BooleanParam, } from 'use-query-params'; ... const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useQueryParams({ title: StringParam, isCompleted: BooleanParam, }); ... return (...); }; 你还可以提供合理的默认值。例如，此时在没有搜索参数的情况下导航到 /bookshelf 时，title 和 isComplete 将是未定义的。但是，如果你希望它们至少是标题的空字符串和 isComplete 的 false，你可以提供这些默认值，例如： import * as React from 'react'; import { Routes, Route, Link } from 'react-router-dom'; import { useQueryParams, StringParam, BooleanParam, withDefault } from 'use-query-params'; ... const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useQueryParams({ title: withDefault(StringParam, ''), isCompleted: withDefault(BooleanParam, false), }); ... return (...); }; 还有一件值得注意的事情要提到：目前，use-query-params 使用默认的“push in”模式，这意味着每次附加搜索参数时，它不会覆盖其他搜索参数。因此，你在更改其中之一的同时保留所有搜索参数。但是，如果这不是你想要的行为，你还可以更改模式（例如，更改为“push”），这样将不再保留以前的搜索参数（尽管这在我们的场景中没有意义）： const Bookshelf = () =&gt; { ... const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }, 'push'); }; const handleIsCompleted = (event) =&gt; { setSearch({ isCompleted: event.target.checked }, 'push'); }; ... return (...); }; 除了我们在这里使用的两种数据类型转换之外，还有对数字、数组、对象等的转换。例如，如果你希望在 React 中有一个可选择的表，你可能希望将表中的每个选定行表示为数组中的标识符（在 use-query-params 中，它是 ArrayParam 转换）映射到实际 URL .然后你可以与另一个用户共享此 URL，该用户将从所选行开始。 使用 URL 作为状态是改善用户体验的方式。在处理单个或多个字符串状态时，React Router 的搜索参数为你提供了一个很好的体验。但是，一旦你想保留映射到 URL 的数据类型，你可能希望使用诸如 use-query-params 之类的库在 React 中进行复杂的 URL 状态管理。 参考 use-query-params ","link":"https://umeimmense.github.io/post/react-router-6sou-suo-can-shu"},{"title":"React Router 6：嵌套路由","content":"前言 本文教你如何在 React Router 6 中使用嵌套路由。嵌套路由是一个强大的功能。虽然大多数人认为 React Router 只会在页面之间路由使用，但它也允许用户根据当前路由交换视图的特定片段。例如，在用户页面上，会显示多个选项卡（例如个人资料、帐户）以浏览用户信息。通过单击这些选项卡，浏览器中的 URL 会发生变化，但不会替换整个页面，只会替换选项卡的内容。 下面我们将使用 React Router 重新创建这个场景。为了说明这是如何工作的，以及如何自己在 React 中逐步实现嵌套路由，我们将从以下示例开始： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;user&quot; element={&lt;User /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 在这个函数组件中，我们使用了 React Router 中的 Link 和 Route 组件，用于 home/ 和 user/ 路由。此外，我们有一个加载了 Home 组件的所谓的索引路由和一个加载了 NoMatch 组件的所谓的 No Match 路由。两者都作为备选路线。从这里开始，我们将了解嵌套路由的概念。 React Router 中的嵌套路由 我们将继续处理 User 组件，这是我们希望通过选项卡进行嵌套路由的地方。因此，我们将实例化一组新的 Link 组件（将是我们的无样式选项卡），用于将用户导航到他们的个人资料和他们的帐户。 const User = () =&gt; { return ( &lt;&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/user/profile&quot;&gt;Profile&lt;/Link&gt; &lt;Link to=&quot;/user/account&quot;&gt;Account&lt;/Link&gt; &lt;/nav&gt; &lt;/&gt; ); }; 我们在这里使用绝对路径将用户从他们的个人资料导航到他们的帐户，反之亦然，但是，我们也可以使用相对路径作为最佳实践。因为 User 组件位于 /user 路由中，所以 Link 组件可以预测它们的父路由（这里是：/user），并且只需将相对路径（这里：profile 和 account）附加到它（例如 /user/profile）： const User = () =&gt; { return ( &lt;&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;profile&quot;&gt;Profile&lt;/Link&gt; &lt;Link to=&quot;account&quot;&gt;Account&lt;/Link&gt; &lt;/nav&gt; &lt;/&gt; ); }; 此时，当我们尝试在 React 应用程序中单击这些链接之一时，我们将被困在我们的 No Match Route 中。这告诉我们，我们还没有将这些路由（此处：/user/profile 和 /user/account）映射到任何实际的路由组件。因此，我们将这两个新路由作为所谓的嵌套路由添加到我们的 /user 路由中： const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;user&quot; element={&lt;User /&gt;}&gt; &lt;Route path=&quot;profile&quot; element={&lt;Profile /&gt;} /&gt; &lt;Route path=&quot;account&quot; element={&lt;Account /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; Route 组件现在以一对一的关系映射到 Link 组件。但是，可以有多个 Link 组件链接到同一个路由，因此它实际上是一对多的关系。 在浏览器中对此进行测试时，我们将看到仅显示 User 组件，而不会显示其嵌套的 Profile 组件，也不会显示其嵌套的 Account 组件。我们缺少 React Router 的关键 Outlet 组件： import { Routes, Route, Link, Outlet } from 'react-router-dom'; ... const User = () =&gt; { return ( &lt;&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;profile&quot;&gt;Profile&lt;/Link&gt; &lt;Link to=&quot;account&quot;&gt;Account&lt;/Link&gt; &lt;/nav&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; Outlet 组件从父 Routes 的 Route 组件集合中使用其各自的组件（此处为 Profile 或 Account 组件）呈现匹配的子路由。 如果没有 /profile 和 /account 路由匹配（例如 /user/settings），你将只看到 User 组件出现。为避免这种情况，你可以添加索引和无匹配路由的组合。之后，默认路由将是 /profile 路由： const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;user&quot; element={&lt;User /&gt;}&gt; &lt;Route index element={&lt;Profile /&gt;} /&gt; &lt;Route path=&quot;profile&quot; element={&lt;Profile /&gt;} /&gt; &lt;Route path=&quot;account&quot; element={&lt;Account /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 虽然 User 组件总是将选项卡呈现为导航，但其内容（Outlet）被匹配的嵌套路由（基于 /user/profile 或 /user/account 路由的 Profile 或 Account 组件）替换。如果在访问 /user 路由时这些路由都不匹配，应用程序将显示 Profile 组件（如果路由与 /user 完全匹配）或 NoMatch 组件（如果路由不匹配，例如 /user/setting）出现。 React router 中的 动态嵌套路由 在嵌套路由的下一个示例中，我们将从 App 组件中开始。这次我们不想像之前那样渲染静态嵌套路由（例如 /user/profile），而是基于标识符的动态嵌套路由（例如 /users/1 用于显示具有标识符 1 并因此匹配此路由的用户）。因此，我们将示例从单用户路由 (/user) 调整为多用户路由 (/user)。 const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; Users 组件成为 React 中的列表组件，因为它遍历每个用户并为其返回 JSX。在这种情况下，它不仅仅是一个列表，因为我们将 React Router 的 Link 组件添加到组合中。 Link 组件中的相对路径提示相应的嵌套（此处：/user.id嵌套在/users中）但动态（此处：/{user.id} 嵌套在 /users 中）但动态（此处：/user.id嵌套在/users中）但动态（此处：/{user.id}）路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 通过拥有这个新的动态嵌套路由，我们需要在 App 组件中为它创建一个匹配的嵌套路由组件。首先，由于它是 /users 路由的所谓嵌套路由（或子路由），我们可以将它嵌套在相应的父路由组件中。此外，由于它是所谓的动态路由，它使用定义为 :userId 的动态路由，而用户的标识符则动态匹配（例如，id 为 '1' 的用户将与 /users/1 匹配）： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt;...&lt;/nav&gt; &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 这样，User 组件就变成了 Users 组件的嵌套路由。因此，再次在 Outlet 组件的帮助下渲染其嵌套路由是用户组件的责任——再次渲染匹配的子路由： import { Routes, Route, Link, Outlet } from 'react-router-dom'; ... const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt;...&lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 接下来，我们将声明缺少的 User 组件，只要用户的标识符在 URL 中匹配，该组件就会通过 Users 组件中的 Outlet 嵌套。在这个新组件中，我们可以使用 React Router 的 useParams Hook 从 URL 中获取相应的 userId（等于 :userId）： import { ... useParams, } from 'react-router-dom'; ... const User = () =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 我们已经看到了如何通过将一个 Route 组件（或多个 Route 组件）嵌套在另一个 Route 组件中来创建嵌套路由。前者是嵌套的子路由，后者是渲染封闭组件的父路由，该组件必须使用 Outlet 组件来渲染实际匹配的子路由。 此外，我们还看到了如何通过在路由的路径属性中使用冒号（例如：userId）来创建动态路由。本质上， :userId 充当任何标识符的星号。在我们的例子中，我们使用 Link 组件将用户导航到 /users/:userId 路由，其中​​ :userId 代表实际用户的标识符。最后，我们总是可以通过使用 React Router 的 useParams Hook 从 URL 中获取动态路径（称为参数或 params）。 如果你碰巧将 React Router 用于你的 React 应用程序，嵌套路由可以通过让你的用户访问你的应用程序非常特定的部分，同时将这些部分作为 URL 共享，从而极大地提升你的用户体验。 ","link":"https://umeimmense.github.io/post/react-router-6qian-tao-lu-you"},{"title":"初探 React Router 6 ","content":"前言 不久前，React Router 库更新到了第 6 版，随之而来的是一些有趣的变化，本文将讲述React Router 6的一些新特性及使用的案例。 接下来是一些准备工作： 首先需要创建一个新的 React 项目（例如 create-react-app）。然后，按照官方文档安装 React Router。 yarn add react-router-dom@latest 我们这里安装的是6.0.2版本。 2. 第一个实现细节将告诉我们的 React 应用程序我们想要使用 React Router。因此，在 React 项目的顶级文件（例如 index.js）中导入 Router 组件，其中 React 使用 ReactDOM API 挂载到 HTML： import React from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter } from 'react-router-dom'; import App from './App'; ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ); 从这里开始，我们将在 App.js 文件中继续我们的实现。 匹配路由 首先，我们将使用 React Router 的 Link 组件在我们的 App 组件中实现导航。我不建议使用内联样式，因此请根据你的 React 项目选择合适的样式策略和样式方法： import { Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; 当你在浏览器中启动 React 应用程序时，你应该能够单击两个 Link 组件，这些组件应该将你导航到各自的路由。单击这些链接时，可通过检查浏览器的当前 URL 来确认。接下来，我们需要使用 React Router 的 Route 组件将路由映射到实际渲染： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; 你可以通过检查它们各自的 to 和 path 属性来查看 Link 和 Route 组件之间的直接匹配。当路由匹配时，每个 Route 组件都会渲染一个 React 元素。由于我们在这里渲染一个 React 元素，我们也可以传递 React props。缺少的是相应功能组件的声明： const Home = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/main&gt; ); }; const Users = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/main&gt; ); }; 返回浏览器时，你应该能够在看到 Home 和 Users 组件的同时从一个页面导航到另一个页面（此处：从 /home 到 /users 路由）。基本上这就是 React Router 的本质：设置 Link 组件并将它们与 Route 组件匹配。链接与路由是多对一的关系，因此你的应用程序中可以有多个链接链接到同一个路由。 布局路由、索引路由、无匹配路由 接下来，你将看到新的 Home 和 Users 组件如何共享相同的布局。作为 React 开发人员，直觉上我们会从 Home 和 Users 组件中提取一个带有样式的新组件，以避免重复。在这个新组件中，我们将使用 React 的 children 属性将组件组合在一起。第一步，将样式提取到它自己的组件中： const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = ({ children }) =&gt; { return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;; }; 其次，在 App 组件中渲染它。通过使用 React 的子级，Layout 组件应该渲染匹配的封闭子路由： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Layout&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Layout&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = ({ children }) =&gt; { return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;; }; 但是你会看到这在 React Router 中是不允许的，你会得到一个异常说： 的所有组件子项必须是 或 &lt;React.Fragment&gt;。解决此问题的一种常见方法是在每个组件中单独使用 Layout 组件（类似于我们之前使用的）或在每个 Route 组件中（如下例所示）： const App = () =&gt; { return ( &lt;&gt; ... &lt;Routes&gt; &lt;Route path=&quot;home&quot; element={&lt;Layout&gt;&lt;Home /&gt;&lt;/Layout&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Layout&gt;&lt;Users /&gt;&lt;/Layout&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 然而，这给 React 应用程序增加了不必要的冗余。因此，我们将使用所谓的 Layout Route，而不是复制 Layout 组件，它不是实际的路由，而只是一种方法，可以让一组 Route 中的每个 Route 组件的元素具有相同的周围样式： const App = () =&gt; { return ( &lt;&gt; ... &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 如你所见，可以将 Route 组件嵌套在另一个 Route 组件中——而前者成为所谓的嵌套路由。现在不再在 Layout 组件中使用 React 的子组件，而是使用 React Router 的 Outlet 组件作为等效组件： import { Routes, Route, Outlet, Link } from 'react-router-dom'; ... const Layout = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;Outlet /&gt; &lt;/main&gt; ); }; 本质上，Layout 组件中的 Outlet 组件插入了父路由（这里：Layout 组件）的匹配子路由（这里：Home 或 Users 组件）。毕竟，使用 Layout Route 可以帮助你为集合中的每个 Route 组件提供相同的布局（例如，CSS 样式，HTML 结构）。 从这里开始，你可以更进一步，将 App 组件的所有实现细节（标题、导航）移动到这个新的 Layout 组件中。此外，我们可以与 NavLink 组件交换链接，以实现所谓的活动链接——向用户显示当前活动的路线。因此，当将新的 NavLink 组件与函数一起使用时，我们可以访问其style和 className props中的 isActive 标志： import { Routes, Route, Link, NavLink, Outlet } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = () =&gt; { const style = ({ isActive }) =&gt; ({ fontWeight: isActive ? 'bold' : 'normal', }); return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;NavLink to=&quot;/home&quot; style={style}&gt;Home&lt;/NavLink&gt; &lt;NavLink to=&quot;/users&quot; style={style}&gt;Users&lt;/NavLink&gt; &lt;/nav&gt; &lt;main style={{ padding: '1rem 0' }}&gt; &lt;Outlet /&gt; &lt;/main&gt; &lt;/&gt; ); }; 接下来你可能已经注意到这个 React 应用程序缺少一个基本路由。虽然我们有 /home 和 /users 路由，但没有 / 路由。你也会在浏览器的开发人员工具中看到此警告：没有路由匹配位置“/”。因此，每当用户访问 / 路由时，我们都会创建一个所谓的索引路由作为回退。此回退路由的元素可以是新组件或任何已匹配的路由（例如，Home 应为路由 / 和 /home 呈现，如下例所示）： const App = () =&gt; { return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 当父路由匹配但没有子路由匹配时，你可以将索引路由视为默认路由。接下来，如果用户导航到不匹配的路由（例如 /about），我们将添加一个所谓的 No Match Route（也称为 Not Found Route），它相当于网站的 404 页面： const App = () =&gt; { return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; const NoMatch = () =&gt; { return (&lt;p&gt;There's nothing here: 404!&lt;/p&gt;); }; 到目前为止，在使用 Routes 组件作为 Route 组件集合的容器时，通过使用 Layout Routes、Index Routes 和 No Match Routes 展示了 React Router 的其他最佳实践。如你所见，也可以将 Route 组件嵌套到 Route 组件中。\b下面我们接着了解有关嵌套路由的更多信息。 动态且嵌套的路由 接下来我们将用实现细节来装饰用户组件。首先，我们将在我们的 App 组件中初始化一个项目列表（这里是：用户）。该列表只是示例数据，但它也可以在 React 中从远程 API 获取。其次，我们将用户作为props传递给用户组件： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; Users 组件成为 React 中的列表组件，因为它遍历每个用户并为其返回 JSX。在这种情况下，它不仅仅是一个列表，因为我们将 React Router 的 Link 组件添加到组合中。 Link 组件中的相对路径提示相应的动态（此处：/user.id）尚未嵌套（此处：/{user.id}）尚未嵌套（此处：/user.id）尚未嵌套（此处：/{user.id} 嵌套在 /users 中）路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={`/users/${user.id}`}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 通过拥有这个新的动态嵌套路由，我们需要在 App 组件中为它创建一个匹配的嵌套路由组件。首先，由于它是 /users 路由的所谓嵌套路由（或子路由），我们可以将它嵌套在相应的父路由组件中。此外，由于它是所谓的动态路由，它使用定义为 :userId 的动态路由，而用户的标识符则动态匹配（例如，id 为 '1' 的用户将与 /users/1 匹配）： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 之前，当我们介绍将 /home 和 /users 路由作为其子路由的父布局路由时，我们已经了解了嵌套路由。当我们进行此更改时，我们必须使用父路由中的 Outlet 组件来渲染匹配的子路由。同样的情况在这里再次发生，因为用户组件也必须渲染它的嵌套路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt;...&lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 接下来，我们将声明缺少的 User 组件，只要用户的标识符在 URL 中匹配，该组件就会通过 Users 组件中的 Outlet 嵌套。因此，我们可以使用 React Router 的 useParams Hook 从 URL 中获取相应的 userId（等于 :userId）： import { ... useParams, } from 'react-router-dom'; ... const User = () =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 我们再次看到了如何通过将一个 Route 组件（或多个 Route 组件）嵌套在另一个 Route 组件中来创建嵌套路由。前者是嵌套的子路由，后者是渲染封闭组件的父路由，该组件必须使用 Outlet 组件来渲染实际匹配的子路由。 我们还看到了如何通过在路由的路径属性（例如：userId）中使用冒号来创建动态路由。本质上， :userId 充当任何标识符的星号。在我们的例子中，我们使用 Link 组件将用户导航到 /users/:userId 路由，其中​​ :userId 代表实际用户的标识符。最后，我们总是可以通过使用 React Router 的 useParams Hook 从 URL 中获取动态路径（称为参数或 params）。 React Router中的相关链接 最新版本的 React Router 带有所谓的相对链接。我们将通过查看用户组件及其用于链接组件的绝对 /users/${user.id} 路径来研究这个概念。在之前版本的 React Router 中，需要指定整个路径。但是，在此版本中，你可以仅使用嵌套路径作为相对路径： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 由于 Users 组件用于 /users 路由，因此 Users 组件中的 Link 知道其当前位置，不需要创建绝对路径的整个顶级部分。相反，它知道 /users 并且只是附加 :userId 作为它的相对路径。 声明式和程序式导航 到目前为止，我们只在使用 Link 或 NavLink 组件时使用了声明式导航。但是，在某些情况下，你希望能够通过 JavaScript 以编程方式导航用户。我们将通过实现一个可以在 User 组件中删除用户的功能来展示这个场景。在删除后，用户应该从 User 组件导航到 Users 组件（从 /users/:userId 到 /users）。 我们将通过使用 React 的 useState Hook 创建一个有状态的 users 值来开始这个实现，然后实现一个事件处理程序，该处理程序使用标识符从用户中删除用户： import * as React from 'react'; ... const App = () =&gt; { const [users, setUsers] = React.useState([ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]); const handleRemoveUser = (userId) =&gt; { setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId)); }; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User onRemoveUser={handleRemoveUser} /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 在我们将事件处理程序作为回调处理程序传递给 User 组件后，我们可以在那里使用它作为内联处理程序来通过标识符删除特定用户： const User = ({ onRemoveUser }) =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; onRemoveUser(userId)}&gt; Remove &lt;/button&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 一旦用户被删除，我们可以使用 React Router 的 useNavigate Hook，它允许我们以编程方式将用户导航到另一个路由（这里：/users）： import * as React from 'react'; import { ... useNavigate, } from 'react-router-dom'; const App = () =&gt; { const navigate = useNavigate(); const [users, setUsers] = React.useState([ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]); const handleRemoveUser = (userId) =&gt; { setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId)); navigate('/users'); }; return (...); }; 在这种情况下，删除操作是同步发生的，因为用户只是客户端的一个有状态值。但是，如果用户是数据库中的实体，则必须发出异步请求才能删除它。一旦这个操作成功（例如：promise是 resolved时），用户就会被导航到 /users 路由。你可以通过在 React 中设置一个虚假的 API 来自己尝试这个场景，而不使用实际的服务器。 搜索参数 浏览器中的 URL 不仅包含路径，还包含一个可选的查询字符串（在 React Router 中称为搜索参数），它以键/值对的形式出现在 ? URL 中的分隔符。例如，/users?name=robin 将是一个带有一对搜索参数的 URL，其中键是名称，值是 robin。以下示例将其显示为实现： import * as React from 'react'; import { ... useSearchParams, } from 'react-router-dom'; ... const Users = ({ users }) =&gt; { const [searchParams, setSearchParams] = useSearchParams(); const searchTerm = searchParams.get('name') || ''; const handleSearch = (event) =&gt; { const name = event.target.value; if (name) { setSearchParams({ name: event.target.value }); } else { setSearchParams({}); } }; return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;input type=&quot;text&quot; value={searchTerm} onChange={handleSearch} /&gt; &lt;ul&gt; {users .filter((user) =&gt; user.fullName .toLowerCase() .includes(searchTerm.toLocaleLowerCase()) ) .map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt;{user.fullName}&lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 首先，我们使用 React Router 的 useSearchParams Hook 从 URL 中读取当前搜索参数（请参阅 searchParams 上的 get() 方法），同时还将搜索参数写入 URL（请参阅 setSearchParams() 函数）。虽然我们使用前者按键获取搜索参数（此处：“name”）来控制输入字段，但我们使用后者在 URL 中按键设置搜索参数。在输入字段中键入。在其核心，React Router 的 useSearchParams Hook 与 React 的 useState Hook 相同，区别在于该状态是 URL 状态，而不是 React 中的本地状态。最后我们使用搜索参数来过滤用户的实际列表以完成此功能。 毕竟，在你的 URL 中包含搜索参数可以让你与他人共享更具体的 URL。如果你在一个搜索黑色鞋子的电子商务网站上，你可能希望共享整个 URL（例如 myecommerce.com/shoes?color=black）而不仅仅是路径（例如 myecommerce.com/shoes）。 总结 React Router 是 React 最常用的第三方库之一。它的核心功能是将 Link 组件映射到 Route 组件，这使开发人员无需向 Web 服务器发出请求即可实现客户端路由。然而，除了这个核心功能之外，它还是一个成熟的路由库，它支持声明式嵌套路由、动态路由、导航、活动链接，还可以通过 URL 进行编程导航和搜索。 参考 react-router CRA ","link":"https://umeimmense.github.io/post/chu-tan-react-router-6"},{"title":" JavaScript 中的 Heap","content":"前言 之前我们已经研究了树数据结构的实现以及它的一些变体，例如 trie。在这篇文章中，我们将深入研究堆。它也称为优先级队列。 什么是堆？ 堆是树数据结构的一种变体，具有两个附加属性： 1.它是一棵完全二叉树：一棵完全二叉树的每一层都包含最大数量的节点，可能最后一层除外，它必须从左到右填充。完整的二叉树总是通过它的定义来平衡的。作为参考下图显示了什么时候可以将树称为完全二叉树： 2.每个节点都满足“堆属性”：堆属性本质上意味着对于任何给定的节点 C，如果 P 是 C 的父节点，则： 对于最大堆：P 的键应该大于或等于 C 的键。 对于最小堆：P 的键应该小于或等于 C 的键。 如何表示堆？ 我们通常从节点的类表示开始实现，然后将其与实际数据结构本身的类表示联系起来。我们也可以对堆做同样的事情。但是，有一种更简单的方法可以解决此问题，这是因为所有堆都必须遵守以下两个属性之一： 所有堆必须是完全二叉树 由于所有堆都必须是完全二叉树，并且我们知道完全二叉树中除最后一层外的所有级别都必须完全填充。此外，对于最后一层，所有子项必须从左到右方向填充，没有任何间隙。这个定义确保了一个由 n 个节点组成的完全二叉树只能有 1 种可能的形状。反过来，它允许我们使用数组来表示完整的二叉树。这意味着，堆也可以使用数组来表示。例如，我们可以将一个简单的堆表示为一个数组，如下图所示： 这里要注意的关键是父节点和子节点之间的关系。如果仔细观察上图，我们可以推断出以下内容： 如果节点位于数组中的索引 i 处，则假设结果索引位于数组的长度内： 它的左孩子将在第 (2i+1) 个位置 左孩子将在 (2i+2) 位置 如果一个节点被放置在数组中的索引 i 处，它的父节点将位于第 ((i-1)/2) 个索引处。 下图可以更轻松地使用上述信息： 具体实现 注意：在整个实现过程中，我们只会讨论最小堆。稍后我们将看到如何将相同的想法轻松扩展到最大堆。 在我们已经涵盖了表示的细节，让我们想出一个使用数据结构的接口。在堆数据结构的帮助下，我们希望能够实现三个关键点： 向堆中添加一个新键 从堆中删除最大或最小键（取决于它是最小堆还是最大堆） 从堆中获取最小键的最大值（取决于是最小堆还是最大堆） 第三个操作很简单。我们知道对于最小堆，数组中的第一项将是最小键，同样对于最大堆，数组中的第一项将是最大键。所以我们剩下两个操作的实现： // adds the provided newKey into the min-heap named &quot;heap&quot; function heappush(heap, newKey){} // removes the smallest key from the min-heap named &quot;heap&quot; function heappop(heap){} 实现heappush() 我们如何向堆中添加一个新键？假设我们首先将新键推送到数组中。推送新键仍然让我们遵守堆的第一个要求，即它必须是一个完整的二叉树。但是，我们需要确保它也遵守“堆属性”。 我们可以通过将push的项与其父项进行比较来做到这一点。如果父项大于的push的项，那么我们知道堆属性被违反，因此我们可以交换。我们可以继续进行这种交换，直到找到一个合法的父节点或者我们已经到达堆的顶部。 代码如下 function heappush(heap, newKey){ // push the new key heap.push(newKey); // get the current index of pushed key let curr = heap.length-1; // keep comparing till root is reached or we terminate in middle while(curr &gt; 0){ let parent = Math.floor((curr-1)/2) if( heap[curr] &lt; heap[parent] ){ // quick swap [ heap[curr], heap[parent] ] = [ heap[parent], heap[curr] ] // update the index of newKey curr = parent } else{ // if no swap, break, since we heap is stable now break } } } 实现 heappop() 使用 heappop() 我们需要删除堆的最顶层元素。意思是，对于最小堆，最小键将被删除，而对于最大堆，最大键将被删除。从数组的角度来看，它只是意味着我们应该删除数组的第一项。但是哪个节点应该成为根？如果我们随机选择被移除节点的左孩子或右孩子作为新的根节点，则不能保证遵循堆属性。我们可以按照以下步骤（对于最小堆）： 将根节点与最后一个节点交换（数组中的第一个元素与最后一个元素） 通过从数组中弹出最后一项来删除根节点 将新根节点的键与其子节点进行比较： 如果键小于它的两个子键，则堆是稳定的 否则，将Key与较小的子Key交换 重复步骤 3，直到到达最后一个子节点或建立堆属性。 本质上，我们遵循与 heappush() 类似的过程，除了我们试图以从上到下的方式建立堆属性，即从根开始并一直持续到最后一个孩子。在 heappush() 中，我们遵循相反的顺序，即从最后一个孩子开始，一直到根。 代码实现： function heappop(heap){ // swap root with last node const n = heap.length; [heap[0], heap[n-1]] = [ heap[n-1], heap[0]] // remove the root i.e. the last item (because of swap) const removedKey = heap.pop(); let curr = 0; // keep going till atleast left child is possible for current node while(2*curr + 1 &lt; heap.length){ const leftIndex = 2*curr+1; const rightIndex = 2*curr+2; const minChildIndex = (rightIndex &lt; heap.length &amp;&amp; heap[rightIndex] &lt; heap[leftIndex] ) ? rightIndex :leftIndex; if(heap[minChildIndex] &lt; heap[curr]){ // quick swap, if smaller of two children is smaller than the parent (min-heap) [heap[minChildIndex], heap[curr]] = [heap[curr], heap[minChildIndex]] curr = minChildIndex } else { break } } // finally return the removed key return removedKey; } 使用现有数组创建堆 从现有数组创建堆看起来非常简单。只需创建一个空堆，然后遍历数组的所有项并执行 heappush(): function heapify(arr){ const heap = [] for(let item of arr){ heappush(heap, item) } return heap; } 但是我们可以在这里做得更好吗？是的。首先，我们可以完全避免为新堆使用额外的空间。为什么不重新排列数组本身的元素，使其满足堆属性？为此，我们可以遵循与堆弹出类似的逻辑。我们可以查看第一个节点并与它的子节点进行比较，看看它是否是最小的节点，如果不是与较小的子节点交换。下面我们来实现一下： // follows pretty much the same logic as heappush, except minor modifications function percolateDown(heap, index){ let curr = index; // keep going down till heap property is established while(2*curr + 1 &lt; heap.length){ const leftIndex = 2*curr+1; const rightIndex = 2*curr+2; const minChildIndex = (rightIndex &lt; heap.length &amp;&amp; heap[rightIndex] &lt; heap[leftIndex] ) ? rightIndex :leftIndex; if(heap[minChildIndex] &lt; heap[curr]){ // quick swap, if smaller of two children is smaller than the parent (min-heap) [heap[minChildIndex], heap[curr]] = [heap[curr], heap[minChildIndex]] curr = minChildIndex } else { break } } 我们可以对数组中的所有元素使用 percolateDown() 函数，按照堆属性将所有元素按正确顺序排列： function heapify(heap){ for(let i in heap){ percolateDown(heap, i) } return heap } 这样就为我们节省了一个额外的数组。但是我们能做些什么来改善所花费的时间吗？是的。如果你仔细观察，我们实际上是在做一些重复的工作。假设堆中有 n 个节点，其中 x 是叶节点，那么这意味着我们只需要对 n-x 个节点执行 percolateDown()，因为到那时最后 x 个节点将在正确的位置。 那么在堆的数组表示中，我们应该执行 percolateDown() 操作到哪个索引？ 直到最后一个节点的父节点所在的索引。因为一旦最后一个节点的父节点被过滤掉，它也会处理最后一个节点。所以： 如果数组长度为 n 最后一个节点的索引是：n-1 它的父节点的索引是：Math.floor((n-1) - 1 / 2) = Math.floor(n/2 - 1) function heapify(heap){ const last = Math.floor(heap.length/2 - 1); for(let i = 0; i &lt;= last; i++){ percolateDown(heap, i) } return heap } 时间和空间复杂度 查看 heappush() 和 heapop() 操作，很明显我们在尝试添加或删除键时正在遍历树的高度。由于堆是一棵平衡树，因此高度是 log(n)，其中 n 是节点总数。因此，对于堆的推送和弹出操作，时间复杂度为 O(log(n))。 heapify() 操作的时间复杂度可能看起来像 Onlog(n)，因为每次调用都需要 O(log(n))。这个观察结果对于推导 heapify() 的时间复杂度的上限是正确的，但是，渐近（平均）时间复杂度为 O(n)。更多细节在这里。就空间复杂度而言，它是恒定的，因为额外的空间仅被诸如 curr、leftIndex 等大小恒定的变量占用。 最大堆 如果我们有 minHeap 的实现，我们也可以轻松地将它用作最大堆。我们只需要确保在向堆添加值时我们插入键的负数。它将确保堆充当所有键的负数的最小堆，这相当于所有实际键的最大堆。例如： 假设我们有一个数组 const x = [23, 454, 54, 29]; 可以使用以下方法创建最小堆： const heap = []; for(let el of x) heappush(heap, el); // min value const min = heappop(heap) 最大堆可以使用 const heap = []; for(let el of x) heappush(heap, -el); // max value const max = -heappop(heap) ","link":"https://umeimmense.github.io/post/javascript-zhong-de-dui"},{"title":"JavaScript 中的稀疏数组与密集数组的区别？","content":"前言 JavaScript 中的数组非常易于使用。但是，你应该注意一个细微差别：某些数组中可能存在漏洞。 在这篇文章中，我将描述 JavaScript 中稀疏数组和密集数组之间的区别。此外，你将找到创建稀疏数组的常用方法。 密集数组 JavaScript 中的数组是一个对象，表示元素的有序集合。数组中的元素有一个确切的顺序。你可以使用索引访问数组的第 n 项。 const names = ['Batman', 'Joker', 'Bane']; console.log(names[0]); // logs 'Batman' console.log(names[1]); // logs 'Joker' console.log(names[2]); // logs 'Bane' console.log(names.length); // logs 3 names[0] 访问索引 0（第一个元素）处的数组项。 数组还有一个属性长度，它表示数组中的项数。在前面的示例中，names.length 为 3，因为数组中的元素个数为 3。 上面创建的名称数组是一个密集数组：这意味着它包含每个索引处的元素，从 0 开始，直到 names.length - 1。 我们定义这是一个函数 isDense(array) ，用于确定数组是否在每个索引处都有元素： function isDense(array) { for (let index = 0; index &lt; array.length; index++) { if (!(index in array)) { return false; } } return true; } const names = ['Batman', 'Joker', 'Bane']; console.log(isDense(names)); // logs true 其中 index in array 确定数组是否在索引位置有一个元素。 这是一个有趣的问题：JavaScript 中的所有数组都是密集的吗？或者当 isDense(array) 返回 false 时可能有数组？ 稀疏数组 有些情况下 JavaScript 数组中可能存在漏洞。这样的数组被命名为稀疏数组。 例如，如果你使用数组字面量但省略指示项就会创建了一个稀疏数组： const names = ['Batman', , 'Bane']; console.log(names[0]); // logs 'Batman' console.log(names[1]); // logs undefined console.log(names[2]); // logs 'Bane' console.log(isDense(names)); // logs false ['Batman', , 'Bane'] 数组文字创建一个稀疏数组，在 1 索引处有一个缺失。如果你访问这个位置的值——names[1]——它的计算结果是 undefined。 要明确检查特定索引处是否有空缺，你可以这样写index in names中： const names = ['Batman', , 'Bane']; // No hole console.log(0 in names); // logs true // Hole console.log(1 in names); // logs false 当然，如果你在稀疏数组上运行 isDense() 它将返回 false： const names = ['Batman', , 'Bane']; console.log(isDense(names)); // logs false 现在你对稀疏数组有所了解。但是创建稀疏数组的常用方法是什么？ 创建稀疏数组的方法 数组字面量 在使用数组字面量时省略一个值会创建一个稀疏数组（注意记录器数组中的空词）： const names = ['Batman', , 'Bane']; console.log(names); // logs ['Batman', empty, 'Bane'] Array() 构造函数 调用 Array(length) 或 new Array(length)（带有一个数字参数）会创建一个完全稀疏的数组： const array = Array(3); console.log(isDense(array)); // logs false console.log(array); // logs [empty, empty, empty] 删除操作符 在数组上使用 delete array[index]运算符时： const names = ['Batman', 'Joker', 'Bane']; delete names[1]; console.log(isDense(names)); // logs false console.log(names); // logs ['Batman', empty, 'Bane'] 最初，names数组是密集的。 但是执行 delete names[1]会删除索引 1 处的元素并使 names 数组变得稀疏。 增加length属性 如果你增加数组的长度属性，那么你也会在数组中创建空缺： const names = ['Batman', 'Joker', 'Bane']; names.length = 5; console.log(isDense(names)); // logs false console.log(names); // logs ['Batman', 'Joker', 'Bane', empty, empty] 最初names数组有3个元素，是一个密集数组。 但是，将names.length 增加到 5 个元素会在 3 和 4 个索引处创建 2 个孔。 附带说明一下，减少 length 属性不会创建稀疏数组，而是从数组末尾删除元素。 数组方法和稀疏数组 稀疏数组的一个问题是许多数组内置方法只是跳过稀疏数组中的空缺。 例如， array.forEach(eachFunc) 不会在孔上调用 eachFunc ： const names = ['Batman', , 'Bane']; names.forEach(name =&gt; { console.log(name); }); // logs 'Batman' // logs 'Bane' 以同样的方式 array.map(mapperFunc)、array.filter(predicateFunc) 和更多函数跳过这些空缺位置。如果你不小心创建了一个稀疏数组，可能很难理解为什么数组方法不能按预期工作。 总结 在 JavaScript 中，数组可以是密集的或稀疏的。 如果每个索引处都有从 0 开始直到 array.length - 1 的元素，则数组是密集的。否则，如果任何索引处至少缺少一项，则数组是稀疏的。 虽然你不会过多地处理稀疏数组，但你应该了解可以创建一个数组的情况： 跳过数组 [1, , 3] 中的值时 使用 Array(length) 时 使用delete array[index] 当增加 array.length 属性时 稀疏数组的问题在于某些 JavaScript 函数（如 array.forEach()、array.map() 等）在迭代数组项时会跳过空缺值。 拓展 稀疏数组在访问元素的速度上比密集数组慢 const arr = new Array(200000) arr[19999] = 88 console.time('using[]') arr[19999] console.timeEnd('using[]') // using[]: 0.031982421875ms const ddd = [...new Array(200000)] ddd[19999] = 88 console.time('using[]') ddd[19999] console.timeEnd('using[]') // using[]: 0.010009765625ms 具体原因是，对于稀疏数组 V8 引擎访问对象是使用 散列表模式的，该种模式在访问时需要计算一遍哈希值，所以会比较慢，但散列表对于空间利用来说，效率更高。而密集数组，它是申请一段连续的内存空间，访问时可以直接通过「索引」来访问，所以速度比较快。 ","link":"https://umeimmense.github.io/post/javascript-zhong-de-xi-shu-shu-zu-yu-mi-ji-shu-zu-de-qu-bie"},{"title":"JavaScript 中的 Trie：什么是前缀树？","content":"前言 我们已经在三篇文章中介绍了树数据结构的基础知识。如果你还没有读过这些，我强烈建议先阅读前三篇文章： 使用递归和迭代算法遍历二叉树 使用父指针遍历二叉树 将树遍历算法应用于 DOM 介绍 Trie 是树数据结构的一种变体。它也被称为前缀树或搜索树的变体。就像 n 叉树数据结构一样，trie 可以有 n 个来自单亲的孩子。通常，trie 中的所有节点都会存储一些字符。假设我们只处理英语单词，下面是一个简单的 trie 可能看起来像： 需要注意的事项： 我们正在尝试使用树来尽可能高效地表示英语单词。 在上图中，从根节点到任何绿色节点的路径表示一个英文单词。例如： NULL-&gt;C-&gt;A-&gt;T: CAT NULL-&gt;D-&gt;O: DO NULL-&gt;D-&gt;O-&gt;G: DOG NULL-&gt;D-&gt;A-&gt;R-&gt;K: DARK NULL-&gt;A: A NULL-&gt;A-&gt;N: AN 每个节点最多可以有 26 个子节点（如果我们只处理英文字母）。我们有一个 NULL 节点作为根节点，因为一个单词可以以 26 个字母中的任何一个开头，因此我们需要一个虚拟节点，它可以将任何潜在的第一个字母作为子节点。 绿色节点，本质上代表“词尾”，同时从根遍历到该节点。 实现节点 现在，让我们尝试提出 Trie 节点的表示。回到树节点，这就是我们呈现它的方式： function Node(value){ this.value = value this.left = null this.right = null } 因此，我们可以对 Trie 遵循类似的想法，同时确保它满足我们在介绍部分讨论的要求。要了解 Trie 节点的要求，让我们放大任何节点： 所以现在更有意义了。这是最终的代码： function Node(value){ this.value = value this.isEndOfWord = false // false by default, a green node means this flag is true this.children = {} // children are stored as Map, where key is the letter and value is a TrieNode for that letter } 实现 Trie 数据结构 我们可以使用一个简单的 ES6 类来表示： class Trie{ constructor(){ this.root = new Node(null) } insert(word){ // TODO } search(word){ // TODO } } 所以我们已经准备好了大概。作为初始化的一部分，每个trie 都会创建它自己的根节点（NULL）。那么我们可以实现这两个方法如下： insert(word)：我们可以将单词拆分为字母，并为每个字母创建一个 Node()。然后我们可以开始将这些 Trie 节点中的每一个链接到根节点，以插入单词。最后，我们将最后插入的节点的 isEndOfWord 属性标记为 true。 search(word)：我们可以将单词拆分为字母。然后我们可以从根开始一个一个地寻找这些字母中的每一个。如果我们能够按顺序找到所有字母，那么我们可以返回 true 否则 false。 让我们直观地理解这两个操作以获得更好的上下文： 首先insert(CAR)然后insert(CAN): 首先search(CAR)然后search(CAN): 实现如下： class Trie{ constructor(){ this.root = new Node(null) } insert(word){ let current = this.root // iterate through all the characters of word for(let character of word){ // if node doesn't have the current character as child, insert it if(current.children[character] === undefined){ current.children[character] = new Node(character) } // move down, to insert next character current = current.children[character] } // mark the last inserted character as end of the word current.isEndOfWord = true } search(word){ let current = this.root // iterate through all the characters of word for(let character of word){ if(current.children[character] === undefined){ // could not find this character in sequence, return false return false } // move down, to match next character current = current.children[character] } // found all characters, return true if last character is end of a word return current.isEndOfWord } } 使用 Trie const trie = new Trie(); // insert few words trie.insert(&quot;CAT&quot;); trie.insert(&quot;DOG&quot;); // search something trie.search(&quot;MAT&quot;) // false trie.search(&quot;DOG&quot;) // true 空间复杂度 在最坏的情况下，所有插入单词的每个字符都可以占用 Trie 中的单个节点。所以这意味着最坏的空间复杂度可以是 (W*n)，其中 W 是每个单词的平均字符数，n 是 Trie 中的单词总数。 时间复杂度 插入：插入一个有n个字符的单词，只需要遍历n个字符，所以时间复杂度为O(n) 搜索：与插入类似，我们只需要遍历单词的所有字符即可进行搜索。所以时间复杂度是 O(n)，其中 n 是单词中的字符数。 现在，想一想，你还能如何在庞大的单词列表中搜索某个单词？ -可能使用数组？时间复杂度为 O(m)，其中 m 是单词总数，这很糟糕。 如何使用Map（或 JavaScript 中的对象）？这会将时间复杂度降低到 O(1)，但是找到具有特定前缀的单词列表有多快？它将是 O(m)。 Trie 不仅将时间复杂度降低到 O(n)（n = 单词中的字符数），而且您还可以有效地搜索具有前缀的单词列表，这对于任何以上两种方法。 应用 自动完成和预先输入：如果您在文本框中键入内容，并且看到具有相同前缀的潜在搜索列表，即自动完成小部件，那么这可能是由后台的 Trie 处理的。同样，Typeahead 也可以使用 Trie 来实现。 拼写检查器：我们可以使用 trie 创建拼写检查器，即给定一个单词列表，我们可以检查给定单词的拼写是否正确。 IP 路由（最长前缀匹配）：Internet 由多个路由器节点组成，它们决定应该发送的目标数据包。 Internet 上的每个路由器都需要将数据包发送到由给定 IP 目的地决定的适当目标节点。但是每个路由器如何使用给定的 IP 地址决定下一个目标路由器呢？这个问题可以使用IP路由来解决。这是一篇深入探讨这个主题的好文章。 ","link":"https://umeimmense.github.io/post/javascript-zhong-de-trieshi-me-shi-qian-zhui-shu"},{"title":"JavaScript 将树遍历算法应用于 DOM","content":"前言 到目前为止，我们已经了解了一些二叉树遍历的方法： 使用递归和迭代算法遍历二叉树 使用父指针遍历二叉树 在本文中，我们将把这些知识用于 n 叉树，即 DOM。我们将看到如何使用各种 CSS 选择器定位 DOM 元素，而无需使用内置 API，如 getElementById、getElementsByClassname 或 querySelector/querySelectorAll。因此，本文将阐明这些 API 可能如何在幕后工作。 DOM 遍历 借用 使用递归和迭代算法遍历二叉树的思路，我们来得出DOM的前序遍历算法： function walkPreOrder(node){ if(!node) return // do something here console.log(node) for(let child of node.children){ walkPreOrder(child) } } 我们可以修改这个算法使之来返回一个迭代器： function* walkPreOrder(node){ if(!node) return // do something here yield node for(let child of node.children){ yield* walkPreOrder(child) } } // USAGE for(let node of walkPreOrder(root)){ console.log(node) } 我们可以使用任何广度优先或深度优先算法（在之前的文章中讨论过）来遍历 DOM。 我们还假设正在处理具有以下 HTML 的文档： &lt;html&gt; &lt;head&gt; &lt;title&gt;DOM selection algorithm&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img id=&quot;profile&quot; src=&quot;xyz.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 通过 ID 定位节点 function locateById(nodeId){ // iterate through all nodes in depth first (preOrder) fashion // return the node as soon as it's found for(let node of walkPreOrder(document.body)){ if(node.id === nodeId){ return node } } return null } 我们可以使用 locateById() 函数如下： const img = locateById('profile') // returns the image node 通过\bClassName 定位节点 浏览器提供 document.getElementsByClassName() API 来实现此结果。我们如何实现类似的东西： function locateAllByClassName(className){ const result = [] for(let node of walkPreOrder(document.body)){ if(node.classList.contains(className)){ result.push(node) } } return result } // USAGE const elements = locateAllByClassName('row') 浏览器如何优化选择查询 选择 DOM 节点是 Web 应用程序相当常见的操作。为同一个选择器多次遍历树似乎不是最佳选择。浏览器通过使用记忆优化选择。 查看 mozilla 解析器的源代码，即函数 startTag 的摘录： // ID uniqueness @IdType String id = attributes.getId(); if (id != null) { LocatorImpl oldLoc = idLocations.get(id); if (oldLoc != null) { err(&quot;Duplicate ID \\u201C&quot; + id + &quot;\\u201D.&quot;); errorHandler.warning(new SAXParseException( &quot;The first occurrence of ID \\u201C&quot; + id + &quot;\\u201D was here.&quot;, oldLoc)); } else { idLocations.put(id, new LocatorImpl(tokenizer)); } } 我们可以看到这些节点 ID 保存在一个简单的哈希映射中。我们可以使用类似的方法来确保对同一 ID 的重复查询不需要完全遍历，相反，我们可以从 hashMap 中查找并返回它。 以下是我们的解决方案： function getSelectors(){ const idLocations = {} const classLocations = {} // updated selector functions function locateById(nodeId){ if(idLocations.hasOwnProperty(nodeId)) return idLocations[nodeId] for(let node of walkPreOrder(document.body)){ if(node.id === nodeId){ idLocations[nodeId]= node //memoize return node } } idLocations[nodeId]= null // memoize return null } function locateAllByClassName(className){ if(classLocations.hasOwnProperty(className)) return classLocations[className] const result = [] for(let node of walkPreOrder(document.body)){ if(node.classList.contains(className)){ result.push(node) } } classLocations[nodeId]= result return result } return { locateById, locateAllByClassName } } // USAGE const {locateById, locateAllByClassName} = getSelectors(); const result = locateAllByClassName('row') // returns array of elements const img = locateById('profile') // returns an element, if found 处理更复杂的选择器 让我们尝试实现类似 element.querySelector 的方法。以下是 MDN 的描述： The querySelector() method of the Element interface returns the first element that is a descendant of the element on which it is invoked that matches the specified group of selectors. 样例 const firstRow = document.querySelector('.container .row:first-child') 在这种情况下，我们可以将任何 CSS 选择器传递给函数，它应该能够遍历 DOM 为我们找到该元素。让我们看看它是如何实现的： // given a selector and root node, find that selector within the root node function select(selector, root){ for(let node of walkPreOrder(root)){ if(node.matches(selector)){ return node } } return null; } function myQuerySelector(path, node){ // if path is empty, nothing to find if(path.length === 0) return null; // if node is not provided, let's assume user wants to search within document.body let root = node || document.body; const selector = path[0]; // if there's only one selector in the path, just traverse using select function above if(path.length === 1) return select(selector, root); // else, either the current node matches the first selector in path or not // if first selector matches with current node, look through it's children for subsequent selectors only // else, look through it's children for the whole path const newPath = root.matches(selector) ? path.slice(1): path; for(let child of root.children){ const ans = myQuerySelector(newPath, child); if(ans) return ans } // nothing found return null; } // USAGE: const firstRow = myQuerySelector([&quot;.container&quot;, &quot;.row&quot;]) myQuerySelectorAll 的实现（类似于 element.querySelectorAll）也遵循相同的方法，稍作修改： function selectAll(selector, root){ let result = [] for(let node of walkPreOrder(root)){ if(node.matches(selector)){ result.push(node) } } return result; } function myQuerySelectorAll(path, node){ let result = []; if(path.length === 0) return result; let root = node || document.body; const selector = path[0]; if(path.length === 1) return selectAll(selector, root); const newPath = root.matches(selector) ? path.slice(1): path; for(let child of root.children){ result = [...result, ...myQuerySelectorAll(newPath, child)] } return result; } 进阶 我们可以使用本文开头描述的递归前序遍历方法来克隆任何树。让我们看看我们如何使用它来克隆任何 DOM 树，类似于 element.cloneNode(true) 所做的： 通过创建具有相同 tagName 的新节点然后复制属性来创建源节点的克隆。 对源节点的所有子节点递归调用 cloneTree 方法，并将返回的节点作为子节点附加到克隆节点。 function cloneTree(node){ if(!node) return const clonedNode = document.createElement(node.tagName.toLowerCase()) const attributes = node.getAttributeNames() attributes.forEach(attribute =&gt; { clonedNode.setAttribute(attribute, node.getAttribute(attribute)) }) for(const child of node.children){ clonedNode.append(cloneTree(child)) } return clonedNode } ","link":"https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom"},{"title":"JavaScript 中的 Tree 使用父指针高效遍历","content":"前言 在本系列的第一部分中，我们研究了遍历二叉树的递归和迭代方法。 在实际应用中，树节点有一个父节点是很常见的：一个指向父节点的指针，因此也称为父指针。让我们以浏览器中的 DOM 为例。假设我们使用以下命令选择任何节点： const element = document.querySelector(&quot;#id&quot;) 在本文中，我们将研究如何使用这些父指针来提高遍历效率。我稍后会解释我所说的“更高效”是什么意思。在下一篇文章中，我们还将了解如何使用此处学到的经验教训从头开始创建 myQuery 库。 更新节点定义 首先，我们需要更新Node 函数 function Node(value){ this.value = value this.left = null this.right = null this.parent = null // added parent field } 现在让我们看看如何使用这个新的 Node 定义来创建一个类似的树，就像我们在上一篇文章中所做的那样。 const root = new Node(2) const left = new Node(1) root.left = left left.parent = root const right = new Node(3) root.right = right right.parent = root 我们只需要确保父指针指向父节点。这是我们使用上述代码获得的最终树的视觉参考： ##寻找后继节点 前序后继 假设每个节点都有一个parent指针，如何找出二叉树中任何节点的 前序 后继？ 让我们试着分析一下这个问题： 首先，我们在这里处理前序，这意味着我们正在寻找以下顺序： root -&gt; left -&gt; right 这意味着如果我们已经在当前节点，我们想寻找左子节点作为后继节点。 如果根本没有左子节点怎么办？那么在这种情况下，我们会寻找合适的节点，如果在有左子节点，那就是后继节点。 如果没有左子节点或右子节点，那么我们需要回溯（继续向上走向父节点）。我们一直回溯，直到通过它的右子节点到达父级（因为这意味着 前序 对于父级下的整个子树是完整的，根据 #1 的定义）。 最终算法实现就是这样： function preOrderSuccessor(node){ if(!node) return if(node.left) return node.left if(node.right) return node.right let parent = node.parent while(parent &amp;&amp; parent.right === node) { node = node.parent parent = parent.parent } if(!parent) return null // we backtracked till root, so no successor return parent.right } 可以根据下图更好的理解 中序后继 首先，我们在这里处理中序遍历，这意味着我们正在寻找以下顺序： root -&gt; left -&gt; right 如果我们在当前节点，并且它右边有右子节点，那么我们可以通过在右子树上找到最左边的节点来获得后继节点。 如果没有右子节点，那么我们需要回溯（向上移动）。我们一直向上移动，直到通过它的右子节点到达父节点，因为这意味着已经遍历了整个子树（根据 #1 中的定义）。 一旦我们找到最近的父节点，它是通过它的左子节点找到的，它就会作为后继节点返回。为什么？因为这意味着它是一个已经探索了左树的节点，所以根据 #1 中的定义，节点本身现在是后继节点。 实现如下： function inOrderSuccessor(node){ if(!node) return if(node.right){ let current = node.right while(current &amp;&amp; current.left) current = current.left return current } let parent = node.parent while(parent &amp;&amp; parent.right === node) { root = node.parent parent = parent.parent } if(!parent) return null return parent } 后序后继 首先，我们在这里处理后序遍历，这意味着我们正在寻找以下顺序： left -&gt; right -&gt; root 所以，如果我们在任何节点上，就意味着它的左右子树已经被访问过了。这意味着我们需要查看父级的继任者。 如果我们从它的右子节点到达父母，这意味着父母本身就是继任者，根据#1 中的定义 如果我们从它的左子节点到达父母，这意味着接下来要探索父母的右子节点（根据#1 中的定义）。所以现在我们需要简单地返回父节点右子节点中最左边的节点作为后继节点。 实现如下： function postOrderSuccessor(node){ if(!node) return let parent = node.parent if(!parent) return null if(parent.right === node). return parent let current = parent.right while(current &amp;&amp; (current.left || current.right)){ current = (current.left || current.right) } return current } 使用后继算法更好地遍历 为什么我们需要使用父指针来提出遍历算法呢？这是一个值得思考的问题，因为我们已经提出了遍历树的递归和迭代方法，而且不需要父指针。 我们这样做的原因是因为我们之前的方法增加了空间复杂性。如果你还记得上一篇文章中我们需要使用一个或两个堆栈（取决于遍历方法）来使任何遍历算法工作。即使在递归方法中，虽然我们不直接使用堆栈，但递归本身基于调用堆栈，因此那里也使用了隐藏的内存中堆栈。问题是这个堆栈的大小会随着我们树的深度而增加，因此这不是最好的解决方案，因为我们有办法在花费更少空间的情况下完成相同的任务。通过使用父指针，我们可以完全摆脱这些堆栈，为我们节省大量空间，即从 O(logN) 的空间复杂度（其中 N 表示平衡树的大小）到 O(1)。让我们看看如何实现。 前序遍历 对于 前序遍历，我们从树的根部开始。之后，我们可以使用上面的算法继续获取前序后继以遍历整棵树： function preOrder(root){ // first node console.log(root.value); let current = root while(true){ const next = preOrderSuccessor(current) if(!next) break // do something console.log(next.value) current = next } } 中序遍历 对于 中序遍历，起始节点将是树的最左侧节点。此后，我们可以使用上述算法继续获取后继以遍历整棵树： function inOrder(root){ // start at the left most node while(root &amp;&amp; root.left){ root = root.left } // first node console.log(root.value); let current = node while(true){ const next = inOrderSuccessor(current) if(!next) break // do something console.log(current.value) current = next } } 后序遍历 非常类似于上面的中序遍历的方法： function postOrder(root){ // start at the left most node while(root &amp;&amp; root.left){ root = root.left } // first node console.log(root.value); let current = node while(true){ const next = postOrderSuccessor(current) if(!next) break // do something console.log(current.value) current = next } } 进阶 如果每个节点都有一个父指针，你能想出算法来寻找前任（inOrder、preOrder 和 postOrder）吗？ ","link":"https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li"},{"title":"JavaScript 中的 Tree","content":"前言 Tree是一种有趣的数据结构。它在各个领域都有广泛的应用。例如： DOM 是一种Tree状数据结构 我们操作系统中的目录和文件可以表示为Tree 家庭层次结构可以表示为Tree。 Tree的许多变体（如堆、BST 等）可用于解决与调度、图像处理、数据库等相关的问题。许多复杂的问题乍一看似乎与Tree无关，但可以被表示为一个Tree的问题。我们也会（在本系列的后面部分）解决这些问题，从而了解Tree如何使看似复杂的问题更容易理解和解决。 简介 二叉树实现节点非常简单 function Node(value){ this.value = value this.left = null this.right = null } // usage const root = new Node(2) root.left = new Node(1) root.right = new Node(3) 所以这几行代码将为我们创建一个二叉树，如下所示： 2 / \\ / \\ 1 3 / \\ / \\ null null null null 遍历 让我们从尝试遍历这些连接的树节点（或一棵树）开始。正如我们可以遍历数组一样，如果我们也可以“遍历”树节点。然而，树不是像数组那样的线性数据结构，所以遍历这些的方法不止一种。我们可以将遍历方法大致分为以下几类： 广度优先遍历 深度优先遍历 广度优先遍历（BFS） 在这种方法中，我们逐层遍历树。我们将从根开始，然后覆盖它的所有子级，然后覆盖所有 2 级子级，依此类推。例如对于上面的树，遍历会导致这样的结果： 2 / \\ / \\ 1 3 / \\ / \\ null null null null 2，1，3 下面是一个稍微复杂的树的插图，使这更容易理解： 为了实现这种形式的遍历，我们可以使用队列（先进先出）数据结构。以下是整个算法的过程： 初始化一个包含 root 的队列 从队列中删除第一项 将弹出项的左右节点推入队列 重复步骤 2 和 3，直到队列为空 下面是这个算法在实现后的样子： function walkBFS(root){ if(root === null) return const queue = [root] while(queue.length){ const item = queue.shift() // do something console.log(item) if(item.left) queue.push(item.left) if(item.right) queue.push(item.right) } } 我们可以稍微修改上面的算法实现为： function walkBFS(root){ if(root === null) return const queue = [root], ans = [] while(queue.length){ const len = queue.length, level = [] for(let i = 0; i &lt; len; i++){ const item = queue.shift() level.push(item) if(item.left) queue.push(item.left) if(item.right) queue.push(item.right) } ans.push(level) } return ans } 深度优先遍历（DFS） 在 DFS 中，我们取一个节点并继续探索它的子节点，直到深度耗尽为止。它可以通过以下方式之一完成： root node -&gt; left node -&gt; right node // pre-order traversal left node -&gt; root node -&gt; right node // in-order traversal left node -&gt; right node -&gt; root node // post-order traversal 所有这些遍历技术都可以递归和迭代实现。让我们进入实现细节： 前序遍历(Pre-Order traversal) 分析 root node -&gt; left node -&gt; right node 技巧: 我们可以使用这个简单的技巧来手动找出任何树的前序遍历：从根节点开始遍历整棵树，保持自己在左边。 实现 递归 function walkPreOrder(root){ if(root === null) return // do something here console.log(root.val) // recurse through child nodes if(root.left) walkPreOrder(root.left) if(root.right) walkPreOrder(root.right) } 迭代 前序遍历的迭代方法与 BFS 非常相似，不同之处在于我们使用堆栈而不是队列，并且我们首先将右节点推入堆栈： function walkPreOrder(root){ if(root === null) return const stack = [root] while(stack.length){ const item = stack.pop() // do something console.log(item) // Left child is pushed after right one, since we want to print left child first hence it must be above right child in the stack if(item.right) stack.push(item.right) if(item.left) stack.push(item.left) } } 中序遍历(In-Order traversal) 分析 下面是一棵树的中序遍历的过程： left node -&gt; root node -&gt; right node 技巧 我们可以使用这个简单的技巧来手动找出任何树的中序遍历：在树的底部水平放置一个平面镜，并获取所有节点的投影 实现 递归function walkInOrder(root){ if(root === null) return if(root.left) walkInOrder(root.left) // do something here console.log(root.val) if(root.right) walkInOrder(root.right) } - 迭代 这个算法乍一看可能有点神秘。但它相当直观。让我们这样看：在中序遍历中，最左边的孩子节点首先被打印，然后是根，然后是孩子节点。所以首先想到的是想出这样的东西： ```javascript const curr = root while(curr){ while(curr.left){ curr = curr.left // get to leftmost child } console.log(curr) // print it curr = curr.right // now move to right child } 在上述方法中，我们无法回溯，即返回导致最左侧节点的父节点。所以我们需要一个堆栈来记录这些。因此，我们修订后的方法可能如下所示： const stack = [] const curr = root while(stack.length || curr){ while(curr){ stack.push(curr) // keep recording the trail, to backtrack curr = curr.left // get to leftmost child } const leftMost = stack.pop() console.log(leftMost) // print it curr = leftMost.right // now move to right child } 现在我们可以使用上面的方法来制定最终的迭代算法： function walkInOrder(root){ if(root === null) return const stack = [] let current = root while(stack.length || current){ while(current){ stack.push(current) current = current.left } const last = stack.pop() // do something console.log(last) current = last.right } } 后序遍历（Post-Order traversal） 分析 下面是一棵树的中序遍历的过程： left node -&gt; right node -&gt; root node 技巧 对于任何树的快速手动后序遍历：一个接一个地提取所有最左边的孩子节点。 实现 让我们深入研究这种遍历的实际实现。 递归 function walkPostOrder(root){ if(root === null) return if(root.left) walkPostOrder(root.left) if(root.right) walkPostOrder(root.right) // do something here console.log(root.val) } 迭代 我们已经有了用于前序遍历的迭代算法。我们可以用那个吗？因为后序遍历似乎只是前序遍历的反向。让我们来看看： // PreOrder: root -&gt; left -&gt; right // Reverse of PreOrder: right -&gt; left -&gt; root // But PostOrder is: left -&gt; right -&gt; root 从上面分析可见有细微的差别。我们可以通过稍微修改我们的 前序遍历算法然后反转它应该给出 后序遍历结果来适应这一点。总体算法将是： // record result using root -&gt; right -&gt; left // reverse result left -&gt; right -&gt; root 使用与上述迭代前序遍历算法类似的方法，使用临时堆栈。 唯一的区别是 root -&gt; right -&gt; left 而不是 root -&gt; left -&gt; right 结果将遍历序列记录在一个array 结果的反转就是后序遍历 function walkPostOrder(root){ if(root === null) return [] const tempStack = [root], result = [] while(tempStack.length){ const last = tempStack.pop() result.push(last) if(last.left) tempStack.push(last.left) if(last.right) tempStack.push(last.right) } return result.reverse() } ","link":"https://umeimmense.github.io/post/javascript-zhong-de-tree"},{"title":"JavaScript 引擎如何提升其运行时的性能？","content":"前言 JavaScript 是一项令人印象深刻的技术。不是因为它设计得特别好，也不是因为世界上几乎所有可以访问互联网的设备都执行 JavaScript 程序。相反，JavaScript 令人印象深刻，是因为它的几乎每一个特性都使它成为优化的噩梦，但是它速度很快。 javascript 为什么会执行速度很快呢？这就是我们需要去深入探究的问题。 在本文中，我们将仔细研究不同 JavaScript 引擎用于实现良好运行时性能的一些技术，在研究过程中省略了一些细节，并简化了事情。本文的目标不是让您了解事物的确切运作方式，而是让您了解并理解引擎如何提升其运行时的一些基本知识。 执行模型 当您的浏览器下载 JavaScript 时，其首要任务是让它尽快运行。它通过将代码转换为字节码、虚拟机指令，然后将其移交给理解如何执行它们的解释器或虚拟机来实现。 您可能会问为什么浏览器会将 JavaScript 转换为虚拟机指令而不是实际的机器指令？这是个好问题。事实上，直到最近，V8（Chrome 的 JavaScript 引擎）还一直在做直接转换为机器指令的工作。 特定编程语言的虚拟机通常是更容易编译的目标，因为它与源语言的关系更密切。实际的机器有一个更通用的指令集，因此需要更多的工作来翻译编程语言以很好地处理这些指令。这种困难意味着编译需要更长的时间，同时也意味着 JavaScript 开始执行需要更长的时间。 例如，理解 JavaScript 的虚拟机也可能理解 JavaScript 对象。因此，执行像 object.x 这样的语句所需的虚拟指令可能是一两条指令。一台不了解 JavaScript 对象如何工作的实际机器需要更多的指令来确定 .x 在内存中的位置以及如何获取它。 虚拟机的问题在于它是虚拟的, 它是不存在的。指令不能直接执行，必须在运行时解释。解释代码总是比直接执行代码慢。 这里有一个问题需要权衡。需要在更快的编译时间与更快的运行时间中做一个选择。在许多情况下，更快的编译是一个很好的权衡。用户不太可能关心单个按钮的点击是否需要 20 或 40 毫秒的执行时间，尤其是当按钮只被按下一次时。快速编译 JavaScript，即使生成的代码执行速度较慢，也会让用户更快地查看页面并与页面交互。 有些情况在计算上是昂贵的。诸如游戏、语法高亮之类的场景。在这种情况下，编译和执行机器指令的时间加起来可能会减少总执行时间。那么 JavaScript 是如何处理这些情况的呢？ 经常被执行的代码 每当 JavaScript 引擎检测到某个函数执行了很多次时，它就会将该函数交给优化编译器。该编译器将虚拟机指令翻译成实际的机器指令。更重要的是，由于该函数已经运行了多次，优化编译器可以根据之前的运行做出一些假设。换句话说，它可以执行推测优化以生成更快的代码。 如果这些推测后来被证明是错误的，会发生什么？ JavaScript引擎可以简单地删除错误的函数，并还原为使用未优化版本。一旦该函数再运行几次，它就可以尝试再次将其传递给优化编译器，这一次它会提供更多可用于推测优化的信息。 既然我们知道频繁运行的函数在优化过程中使用来自先前执行的信息，接下来要探索的是这是什么类型的信息。 翻译问题 JavaScript 中的几乎所有东西都是对象。不幸的是，JavaScript 对象很难让机器处理。让我们看看下面的代码： function addFive(obj) { return obj.method() + 5; } 将函数转换为机器指令非常简单，就像从函数返回一样。但是机器不知道对象是什么，比如访问obj的method属性需要怎么翻译呢？ 如果知道 obj 是什么样子会很有帮助，但在 JavaScript 中我们永远无法确定。任何对象都可以添加或删除方法属性。即使method确实存在，我们实际上也不能确定它是否是一个函数，更不用说调用它之后的返回值了。 让我们尝试将上述代码转换为没有对象的 JavaScript 子集，来了解转换为机器指令可能是什么样的。 首先，我们需要一种表示对象的方法。我们还需要一种从其中检索值的方法。在机器代码中支持数组是比较的，所以我们可能会使用这样的表示： // An object like { method: function() {} } // could be represented as: // [ [ &quot;method&quot; ], // property names // [ function() {} ] ] // property values function lookup(obj, name) { for (var i = 0; i &lt; obj[0].length; i++) { if (obj[0][i] === name) return i; } return -1; } 参考上述的表示，我们可以尝试对 addFive 进行一个简单的实现 function addFive(obj) { var propertyIndex = lookup(obj, &quot;method&quot;); var property = propertyIndex &lt; 0 ? undefined : obj[1][propertyIndex]; if (typeof(property) !== &quot;function&quot;) { throw NotAFunction(obj, &quot;method&quot;); } var callResult = property(/* this */ obj); return callResult + 5; } 当然，这在 obj.method() 返回的不是数字的情况下不能运行，所以我们需要稍微调整一下实现： function addFive(obj) { var propertyIndex = lookup(obj, &quot;method&quot;); var property = propertyIndex &lt; 0 ? undefined : obj[1][propertyIndex]; if (typeof(property) !== &quot;function&quot;) { throw NotAFunction(obj, &quot;method&quot;); } var callResult = property(/* this */ obj); if (typeof(callResult) === &quot;string&quot;) { return stringConcat(callResult, &quot;5&quot;); } else if (typeof(callResult !== &quot;number&quot;) { throw NotANumber(callResult); } return callResult + 5; } 这是能运行的，但我希望很明显，如果我们能提前知道 obj 的结构是什么，以及方法的类型是什么，那么这段代码可以跳过几个步骤。 隐藏类 主流的 JavaScript 引擎都以某种方式跟踪对象是什么样的呢？在 Chrome 中，这个概念被称为隐藏类。 让我们从以下代码片段开始： var obj = {}; // empty object obj.x = 1; // shape has now changed to include a `x` property obj.toString = function() { return &quot;TODO&quot;; }; // shape changes delete obj.x; // shape changes again 如果我们将其转换为机器指令，我们将如何在添加和删除新属性时跟踪对象的样子？如果我们使用上一个示例将对象表示为数组的想法，它可能看起来像这样： var emptyObj__Class = [ null, // No parent hidden class [], // Property names [] // Property types ]; var obj = [ emptyObj__Class, // Hidden class of `obj` [] // Property values ]; var obj_X__Class = [ emptyObj__Class, // Contains same properties as empty object [&quot;x&quot;], // As well as one property called `x` [&quot;number&quot;] // Where `x` is a number ]; obj[0] = obj_X__Class; // Shape changes obj[1].push(1); // value of `x` var obj_X_ToString__Class = [ obj_X__Class, // Contains same properties as previous shape [&quot;toString&quot;], // And one property called `toString` [&quot;function&quot;] // Where `toString` is a function ]; obj[0] = obj_X_ToString__Class; // shape change obj[1].push(function() { return &quot;TODO&quot;; }); // `toString` value var obj_ToString__Class = [ null, // Starting from scratch when deleting `x` [&quot;toString&quot;], [&quot;function&quot;] ]; obj[0] = obj_ToString__Class; obj[1] = [obj[1][1]]; 如果我们要生成这样的虚拟机指令，我们现在就有了一种方法来跟踪对象在任何给定时间的样子。然而，这本身并不能真正帮助我们。我们需要将这些信息存储在有价值的地方。 内联缓存 每当 JavaScript 代码对对象执行属性访问时，JavaScript 引擎都会将该对象的隐藏类以及查找结果（属性名称到索引的映射）存储在缓存中。这些缓存被称为内联缓存，它们有两个重要目的： 在执行字节码时，如果所涉及的对象具有缓存中的隐藏类，它们会加速属性访问。 在优化期间，它们包含有关访问对象属性时所涉及的对象类型的信息，这有助于优化编译器生成特别适合这些类型的代码。 内联缓存对它们存储信息的隐藏类的数量有限制。这可以保留内存，但也确保在缓存中执行查找速度很快。如果从内联缓存中检索索引比从隐藏类中检索索引花费的时间更长，则缓存没有任何用处。 据我所知， Chrome在中，内联缓存最多会跟踪 4 个隐藏类。在此之后，内联缓存将被禁用，信息将存储在全局缓存中。全局缓存的大小也有限制，一旦达到限制，新条目将覆盖旧条目。 为了最好地利用内联缓存并帮助优化编译器，应该尝试编写仅对单一类型的对象执行属性访问的函数。不仅如此，生成的代码的性能将是次优的 内联 一种单独且重要的优化是内联。简而言之，这种优化用被调用函数的实现代替了函数调用。举个例子： function map(fn, list) { var newList = []; for (var i = 0; i &lt; list.length; i++) { newList.push(fn(list[i])); } return newList; } function incrementNumbers(list) { return map(function(n) { return n + 1; }, list); } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 内联后，代码最终可能看起来像这样： function incrementNumbers(list) { var newList = []; var fn = function(n) { return n + 1; }; for (var i = 0; i &lt; list.length; i++) { newList.push(fn(list[i])); } return newList; } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 这样做的一个好处是删除了函数调用。更大的好处是 JavaScript 引擎现在可以更深入地了解函数的实际作用。基于这个新版本，JavaScript 引擎可能会决定再次执行内联： function incrementNumbers(list) { var newList = []; for (var i = 0; i &lt; list.length; i++) { newList.push(list[i] + 1); } return newList; } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 另一个函数调用已被删除。更重要的是，优化器现在可能会推测 incrementNumbers 只会以数字列表作为参数被调用。它还可能决定内联 incrementNumbers([1, 2, 3]) 调用本身，并发现 list.length 为 3，这又可能导致： var list = [1, 2, 3]; var newList = []; newList.push(list[0] + 1); newList.push(list[1] + 1); newList.push(list[2] + 1); list = newList; 简而言之，内联可以实现跨函数边界无法执行的优化。 但是，可以内联的内容是有限的。由于代码重复，内联会导致更大的函数，这需要额外的内存。 JavaScript 引擎对一个函数在完全跳过内联之前可以达到的大小有一个预算。 一些函数调用也很难内联。特别是当一个函数作为参数传入时。 此外，作为参数传递的函数很难内联，除非它总是同一个函数。虽然这可能会让您觉得这是一件奇怪的事情，但由于内联，最终可能会出现这种情况。 结论 JavaScript 引擎有许多提高运行时性能的技巧，比这里介绍的要多得多。但是，本文中描述的优化适用于大多数浏览器，并且很容易验证它们是否被应用。因此，当我们尝试提高 Elm 的运行时性能时，我们将主要关注这些优化。 参考 What’s up with monomorphism Shapes and inline caches Optimizing prototypes ","link":"https://umeimmense.github.io/post/javascript-yin-qing-ru-he-ti-sheng-qi-yun-xing-shi-de-xing-neng"},{"title":"7 个可能需要的自定义 React Hook","content":"前言 本文主要编制了一份清单，列出了在项目中可能会需要用到的的七个Hooks。 1. useToggle 这个hook很常见，它用于在 true 和 false 之间切换布尔值。当我们想要显示/隐藏模式或打开/关闭侧边菜单时，它很有用。这个hook的基本版本如下所示： 实现v1 // useToggle.jsx import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); return [state, toggle]; }; export default useToggle; 案例1 import useToggle from './useToggle'; const App = () =&gt; { const [show, toggleShow] = useToggle(); return ( &lt;Modal show={show} onClose={toggleShow}&gt; &lt;h1&gt;Hello there&lt;/h1&gt; &lt;/Modal&gt; ); } 当我们想要显示/隐藏表中一行的模式时，可以稍微修改此hook以用于用例。我添加了一个 customToggle 方法，该方法将值设置为给定值，而不是切换先前的状态值。 实现v2 // useToggle.jsx modified import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); const customToggle = useCallback((value) =&gt; { setState(value); }, []); return [state, toggle, customToggle]; }; export default useToggle; 案例2 假设我们在一个表格中有一堆行，我们想提供一个删除行的选项。单击删除按钮应打开一个确认模式。 对于这种类型的功能，我们需要状态中的两个变量。首先，保存一个布尔值来确定是否显示删除确认模式，其次保存必须显示删除模式的行 ID。 使用这个hook，我们可以用一个状态变量来完成。这是如何做到的： import useToggle from './useToggle'; // initial data const rows = [ { id: 1, name: 'John' }, { id: 2, name: 'Doe' } ]; const App = () =&gt; { // using hook const [delModal, toggleDelModal, setDelModalCustom] = useToggle(); return ( &lt;div&gt; &lt;table&gt; {rows.map(row =&gt; ( &lt;tr&gt; &lt;td&gt;{row.id}&lt;/td&gt; &lt;td&gt;{row.name}&lt;/td&gt; &lt;td onClick={() =&gt; setDelModalCustom(row.id)}&gt;Delete&lt;/td&gt; &lt;/tr&gt; ))} &lt;/table&gt; &lt;DeleteModal show={Boolean(delModal)} onClose={toggleDelModal} itemToDelete={delModal} // it will hold the current row id &gt; &lt;h1&gt; Are you sure you want to delete row with id {delModal} &lt;/h1&gt; &lt;/DeleteModal&gt; &lt;/div&gt; ); } 2. usePageBottom 使用此hook，您可以确定用户是否已滚动到页面底部。非常适合无限滚动的应用程序，当用户滚动到页面底部时，您需要获取更多数据。 // usePageBottom.jsx import { useState, useEffect } from 'react'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = () =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }; // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 案例 import usePageBottom from './usePageBottom'; const App = (props) =&gt; { // hook usage const scrolledBottom = usePageBottom(); return ( &lt;div className=&quot;App&quot; style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 节流版本（可选） 减少像窗口滚动事件这样多次触发的事件的通知是最佳实践，我们可以使用节流设置事件侦听器。我正在使用 lodash 的throttle；你也可以使用去debounce。 // usePageBottom with throttle import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 3. useElementBottom 就像页面底部一样，我们也可以确定用户是否已经滚动到元素的底部。在这个hook中，传递了对元素的引用，因此我们可以使用元素的高度和当前滚动位置来确定元素是否滚动到底部。 // useElementBottom.jsx import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const useElementBottom = (element) =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const { current } = element; // current holds the reference to element // if current scroll from bottom is less than equal to 10px const scrollBottom = current.scrollHeight - current.scrollTop - current.clientHeight; const reachingBottom = scrollBottom &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on element scroll useEffect(() =&gt; { const { current } = element; current.addEventListener('scroll', handleScroll); return () =&gt; current.removeEventListener('scroll', handleScroll); }, []); return reachedBottom; }; export default useElementBottom; 案例 import useElementBottom from './useElementBottom'; const App = (props) =&gt; { const element = useRef(); // hook usage const scrolledBottom = useElementBottom(element); return ( &lt;div ref={element} style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 4. usePrevious 我们可以制作一个自定义hook来获取 prop 或 state 的先前值。使用 React 类组件，可以使用 componentDidUpdate 生命周期来获取之前的 prop 和 state 值。对于功能组件，我们可以使用自定义hook来完成，如下所示： // usePrevious.jsx import { useEffect, useRef } from 'react'; const usePrevious = (value) =&gt; { const ref = useRef(); // store current value in ref useEffect(() =&gt; { ref.current = value; }, [value]); // return previous value (happens before update in useEffect above) return ref.current; }; export default usePrevious; 我们使用 useRef hook来存储先前的值。我们的hook在 useEffect 中更新引用对象之前返回先前的值。 import usePrevious from './usePrevious'; const App = () =&gt; { const [count, setCount] = useState(0); const prevCount = usePrevious(count); return ( &lt;div&gt; &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; ); } 5. useWindowSize 这个hook返回窗口的宽度和高度。我们在调整窗口大小时设置了一个受限制的 set 事件侦听器，以便我们每次都能获得正确的宽度和高度。 // useWindowSize import { useState, useEffect, useCallback } from 'react'; import { throttle } from 'throttle'; const useWindowSize = () =&gt; { const [size, setSize] = useState({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); // throttled set listener that runs on window resize const throttledSetResizeListner = useCallback( throttle(() =&gt; { // set size in state setSize({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); }, 1000), [] ); // effect for binding resize event on window useEffect(() =&gt; { // add throtelled set window resize event listener window.addEventListener('resize', throttledSetResizeListner); // remove throttled set window resize event listener return () =&gt; window.removeEventListener('resize', throttledSetResizeListner); }, [throttledSetResizeListner]); return size; }; export default useWindowSize; 案例 当你想根据窗口的宽度或高度在你的 JS 代码中做一些事情时，它很有用。 import useWindowSize from './useWindowSize'; const App = () =&gt; { const { innerWidth, innerHeight } = useWindowSize(); return ( &lt;div&gt; {innerWidth &lt;= 768 ? 'I am on small screen' : 'I am on large screen'} &lt;/div&gt; ); } 6. useEventListener 使用此hook可以轻松地将事件侦听器绑定到窗口或窗口元素。在hook的effect中，我们检查元素是否是来自 useRef 的引用。如果没有，我们将事件侦听器添加到全局窗口对象。 import { useEffect } from 'react'; const useEventListener = (event, handler, referencedElement) =&gt; { // effect for binding event handler to the element useEffect(() =&gt; { const element = referencedElement?.current || window; const isSupported = element &amp;&amp; element.addEventListener; if (!isSupported) return; // bind event to the element element.addEventListener(event, handler); return () =&gt; element.removeEventListener(event, handler); }, [referencedElement, event, handler]); return; }; export default useEventListener; import useEventListener from './useEventListener'; const App = (props) =&gt; { const element = useRef(); useEventListener('mouseover', handler, element); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div ref={element}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 我们还可以使用相同的hook将事件添加到窗口 import useEventListener from './useEventListener'; const App = (props) =&gt; { // adding event listener on window scroll useEventListener('scroll', handler); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 7. useLocalStorageState 有时，可能需要在本地存储和状态之间同步一个值。这个hook的作用完全一样。我们正在使用 useState 并检查指定的键是否在本地存储中具有某个值，以便我们可以将其用作初始值。这允许我们在页面刷新时保持值与状态同步。 // useLocalStorageState import { useState, useEffect } from 'react'; const useLocalStorageState = (key, defaultValue) =&gt; { const [value, setValue] = useState(() =&gt; { let val; try { // if there is a value in local storage for given key, set it as initial state val = JSON.parse(localStorage.getItem(key) || String(defaultValue)); } catch (error) { // otherwise, set default value as initial state val = defaultValue; } return val; }); // effect to update local storage when state changes useEffect(() =&gt; { localStorage.setItem(key, JSON.stringify(value)); }, [value]); return [value, setValue]; }; export default useLocalStorageState; 当值更新时，会运行一个effect ，更新本地存储中的值。 案例 假设你想在本地存储中存储用户主题首选项 import useLocalStorageState from './useLocalStorageState'; const App = (props) =&gt; { // setting default theme to light const [theme, setTheme] = useLocalStorageState('theme', 'light'); return ( &lt;div&gt; &lt;p&gt;Current theme is {theme}&lt;/p&gt; &lt;button onClick={() =&gt; setTheme('dark')}&gt; Change theme to dark &lt;/button&gt; &lt;/div&gt; ); } 当你点击更改主题按钮时，状态和本地存储中的值都会更新。页面刷新后，你将获得存储在本地存储中的最后一个值。 结语 感谢你阅读到最后。我希望这些自定义hook对你有用。 ","link":"https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook"},{"title":"10个常用的JavaScript使用技巧","content":"前言 编写简短、简洁和干净的 JavaScript 代码的技巧😎 JavaScript 有很多很酷的特性，大多数初学者和中级开发人员都不知道。我挑选了 10 个我在日常 JavaScript 项目中使用的技巧。 1. 有条件的向对象中添加属性 我们可以使用扩展运算符 ... 来有条件地向 JavaScript 对象快速添加属性。 const condition = true; const person = { id: 1, name: 'John Doe', ...(condition &amp;&amp; { age: 16 }), }; 如果每个操作数的计算结果都为true， &amp;&amp; 运算符将返回最后计算的表达式。因此返回一个对象 { age: 16 }，然后将其作为 person 对象的一部分。 如果条件为 false，则 JavaScript 将执行以下操作： const person = { id: 1, name: 'John Doe', ...(false), // evaluates to false }; // spreading false has no effect on the object console.log(person); // { id: 1, name: 'John Doe' } 2. 检查一个属性是否存在于一个对象中 我们可以使用in关键字来检查 JavaScript 对象中是否存在属性 const person = { name: 'John Doe', salary: 1000 }; console.log('salary' in person); // returns true console.log('age' in person); // returns false 3. 对象中的动态属性名称 使用动态键设置对象属性很简单。只需使用 ['key_name'] 符号添加属性 const dynamic = 'flavour'; var item = { name: 'Biscuit', [dynamic]: 'Chocolate' } console.log(item); // { name: 'Biscuit', flavour: 'Chocolate' } 同样的技巧也可用于使用动态键引用对象属性： const keyName = 'name'; console.log(item[keyName]); // returns 'Biscuit' 4. 使用动态键进行对象解构 你可能知道你可以解构一个变量并立即用 : 符号重命名它。但是你知道当你不知道键名或键名是动态的时，你也可以解构对象的属性吗？ 首先，让我们看看如何在解构（用别名解构）时重命名变量。 const person = { id: 1, name: 'John Doe' }; const { name: personName } = person; console.log(personName); // returns 'John Doe' 现在，让我们使用动态键来解构属性： const templates = { 'hello': 'Hello there', 'bye': 'Good bye' }; const templateName = 'bye'; const { [templateName]: template } = templates; console.log(template) // returns 'Good bye' 5. ?? 运算符 这 ??当你要检查变量是 null 还是 undefined 时，运算符很有用。当其左侧操作数为空或未定义时，它返回右侧操作数，否则返回其左侧操作数。 const foo = null ?? 'Hello'; console.log(foo); // returns 'Hello' const bar = 'Not null' ?? 'Hello'; console.log(bar); // returns 'Not null' const baz = 0 ?? 'Hello'; console.log(baz); // returns 0 在第三个示例中，返回 0 是因为即使 0 在 JavaScript 中被认为是假的，但它不是 null 或未定义的。你可能认为我们可以使用 ||运算符在这里，但这两者之间存在差异： const cannotBeZero = 0 || 5; console.log(cannotBeZero); // returns 5 const canBeZero = 0 ?? 5; console.log(canBeZero); // returns 0 6. ?. 可选链 我们都可能曾经遇到过TypeError：无法读取 null 的属性“foo”之类的错误。这对每个 JavaSript 开发人员来说都是头疼的问题。引入了可选链就是为了解决这个问题。让我们来看看： const book = { id:1, title: 'Title', author: null }; // normally, you would do this console.log(book.author.age) // throws error console.log(book.author &amp;&amp; book.author.age); // returns null (no error) // with optional chaining console.log(book.author?.age); // returns undefined // or deep optional chaining console.log(book.author?.address?.city); // returns undefined 你还可以使用具有以下功能的可选链： const person = { firstName: 'Haseeb', lastName: 'Anwar', printName: function () { return `${this.firstName} ${this.lastName}`; }, }; console.log(person.printName()); // returns 'Haseeb Anwar' console.log(persone.doesNotExist?.()); // returns undefined 7. 使用 !! 的布尔转换符 这 !!运算符可用于将表达式的结果快速转换为布尔值 true 或 false。就是这样： const greeting = 'Hello there!'; console.log(!!greeting) // returns true const noGreeting = ''; console.log(!!noGreeting); // returns false 8. 字符串和整数转换 使用 + 运算符快速将字符串转换为数字，如下所示： const stringNumer = '123'; console.log(+stringNumer); // returns integer 123 console.log(typeof +stringNumer); // returns 'number' 要将数字快速转换为字符串，请使用 + 运算符后跟空字符串 &quot;&quot;： const myString = 25 + ''; console.log(myString); // returns '25' console.log(typeof myString); // returns 'string' 这些类型转换非常方便，但它们的清晰度和代码可读性较差。因此，在生产中使用它们之前，你可能需要考虑一下。不过可以用才code golf中。 9. 检查数组中的假值 你熟悉 filter、some 和 every 数组方法。但你也应该知道，你可以仅使用布尔方法来测试真值： const myArray = [null, false, 'Hello', undefined, 0]; // filter falsy values const filtered = myArray.filter(Boolean); console.log(filtered); // returns ['Hello'] // check if at least one value is truthy const anyTruthy = myArray.some(Boolean); console.log(anyTruthy); // returns true // check if all values are truthy const allTruthy = myArray.every(Boolean); console.log(allTruthy); // returns false 这是它的工作原理。众所周知，这些数组方法采用回调函数，因此我们将布尔值作为回调函数传递。 Boolean 本身接受一个参数并根据参数的真实性返回true或 false。所以我们可以这样说： myArray.filter(val =&gt; Boolean(val)); 是不是和这个一样： myArray.filter(Boolean); 10.展平数组 原型 Array 上有一个方法 flat 可以让你从数组的数组中创建一个数组： const myArray = [{ id: 1 }, [{ id: 2 }], [{ id: 3 }]]; const flattedArray = myArray.flat(); // returns [ { id: 1 }, { id: 2 }, { id: 3 } 你还可以定义一个深度级别，指定嵌套数组结构应展平的深度。例如： const arr = [0, 1, 2, [[[3, 4]]]]; console.log(arr.flat(2)); // returns [0, 1, 2, [3,4]] 结语 感谢你阅读到最后。我希望这些技巧对你有用。 ","link":"https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao"}]}