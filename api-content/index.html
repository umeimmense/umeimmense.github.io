{"posts":[{"title":"数据整理","content":"数据整理 课程链接：数据整理 · the missing semester of your cs education (missing-semester-cn.github.io) [toc] 您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！ 这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。 在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。 例如这样一条命令 journalctl | grep -i intel，它会找到所有包含intel(区分大小写)的系统日志。您可能并不认为是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。 让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器： ssh myserver journalctl 内容太多了。现在让我们把涉及 sshd 的信息过滤出来： ssh myserver journalctl | grep sshd 注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 grep 程序！ ssh 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 ssh 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下： ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' | less 多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 less 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了： $ ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' &gt; ssh.log $ less ssh.log 过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 sed 这个非常强大的工具。 sed 是一个基于文本编辑器ed构建的&quot;流编辑器&quot; 。在 sed 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 s，即替换命令，例如我们可以这样写： ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed 's/.*Disconnected from //' 上面这段命令中，我们使用了一段简单的正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。s 命令的语法如下：s/REGEX/SUBSTITUTION/, 其中 REGEX 部分是我们需要使用的正则表达式，而 SUBSTITUTION 是用于替换匹配结果的文本。 正则表达式 正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： /.*Disconnected from /。正则表达式通常以（尽管并不总是） /开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有： . 除空格之外的&quot;任意单个字符&quot; * 匹配前面字符零次或多次 + 匹配前面字符一次或多次 [abc] 匹配 a, b 和 c 中的任意一个 (RX1|RX2) 任何能够匹配RX1 或 RX2的结果 ^ 行首 $ 行尾 sed 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加\\才能使其具有特殊含义。或者，您也可以添加-E选项来支持这些匹配。 回过头我们再看/.*Disconnected from /，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含&quot;Disconnected from &quot;的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 &quot;Disconnected from&quot; 作为自己的用户名会怎样呢？ Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth] 正则表达式会如何匹配？* 和 + 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下： 46.97.239.16 port 55920 [preauth] 这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给 * 或 + 增加一个? 后缀使其变成非贪婪模式，但是很可惜 sed 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式： perl -pe 's/.*?Disconnected from //' 让我们回到 sed 命令并使用它完成后续的任务，毕竟对于这一类任务，sed是最常见的工具。sed 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。sed 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。 好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？ 想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配一整行： | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \\[preauth\\])?$//' 让我们借助正则表达式在线调试工具regex debugger 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（[^ ]+ 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀[preauth]，最后再匹配行尾。 注意，这样做的话，即使用户名是“Disconnected from”，对匹配结果也不会有任何影响，您知道这是为什么吗？ 问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名保留下来。对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如\\1、 \\2、\\3等等，因此可以使用如下命令： | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' 想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章e-mail address，匹配电子邮箱可一点也不简单。网络上还有很多关于如何匹配电子邮箱地址的讨论。人们还为其编写了测试用例及 测试矩阵。您甚至可以编写一个用于判断一个数是否为质数的正则表达式。 正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。 回到数据整理 OK，现在我们有如下表达式： ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' sed 还可以做很多各种各样有趣的事情，例如文本注入：(使用 i 命令)，打印特定的行 (使用 p命令)，基于索引选择特定行等等。详情请见man sed! 现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登陆我们的系统。但这还不够，让我们过滤出那些最常出现的用户： ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c sort 会对其输入数据进行排序。uniq -c 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常登陆的用户： ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 sort -n 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序 -k1,1 则表示“仅基于以空格分割的第一列进行排序”。,n 部分表示“仅排序到第n个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！ 如果我们希望得到登陆次数最少的用户，我们可以使用 head 来代替tail。或者使用sort -r来进行倒序排序。 相当不错。但我们只想获取用户名，而且不要一行一个地显示。 ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | awk '{print $2}' | paste -sd, 我们可以利用 paste命令来合并行(-s)，并指定一个分隔符进行分割 (-d)，那awk的作用又是什么呢？ awk -- 另外一种编辑器 awk 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 awk 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。 首先， {print $2} 的作用是什么？ awk 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。 让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以c 开头，以 e 结尾，并且仅尝试过一次登陆的用户。 | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l 让我们好好分析一下。首先，注意这次我们为 awk指定了一个匹配模式串（也就是{...}前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是uniq -c得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 wc -l 统计输出结果的行数。 不过，既然 awk 是一种编程语言，那么则可以这样： BEGIN { rows = 0 } $1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 } END { print rows } BEGIN 也是一种模式，它会匹配输入的开头（ END 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 grep 和 sed ，因为 awk 就可以解决所有问题。至于怎么做，就留给读者们做课后练习吧。 分析数据 想做数学计算也是可以的！例如这样，您可以将每行的数字加起来： | paste -sd+ | bc -l 下面这种更加复杂的表达式也可以： echo &quot;2*($(data | paste -sd+))&quot; | bc -l 您可以通过多种方式获取统计数据。如果已经安装了R语言，st是个不错的选择： ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | awk '{print $1}' | R --slave -e 'x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)' R 也是一种编程语言，它非常适合被用来进行数据分析和绘制图表。这里我们不会讲的特别详细， 您只需要知道summary 可以打印统计结果。我们通过输入的信息计算出一个矩阵，然后R语言就可以得到我们想要的统计数据。 如果您希望绘制一些简单的图表， gnuplot 可以帮助到您： ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | gnuplot -p -e 'set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes' 利用数据整理来确定参数 有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 xargs 即可实现： rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed 's/-x86.*//' | xargs rustup toolchain uninstall 整理二进制数据 虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。 ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -' 课后练习 学习一下这篇简短的 交互式正则表达式教程.✔️ 统计words文件 (/usr/share/dict/words) 中包含至少三个a 且不以's 结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ sed的 y命令，或者 tr 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很有挑战性的问题：哪个组合从未出现过？✔️ # 输出组合数 cat ./words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep &quot;.*a.*a.*a[a-z]*$&quot; | sed -E 's/.*(..)/\\1/' | sort | uniq -c | sort -nk1,1 | wc -l # 保存至word.txt cat ./words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep &quot;.*a.*a.*a[a-z]*$&quot; | sed -E 's/.*(..)/\\1/' | sort | uniq -c | sort -nk1,1 | awk '{print $2}' &gt; word.txt # 编写python脚本输出全部组合 letter = &quot;abcdefghijklmnopqrstuvwxyz&quot; for a in letter: for b in letter: print(a+b) # 保存至allword.txt python word.py &gt; allword.txt # 删除匹配项 cat word.txt | xargs -n 1 -i sed -i '/{}/d ' ./allword.txt # 打印剩余组合数 cat allword.txt | wc -l 进行原地替换听上去很有诱惑力，例如： sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt。但是这并不是一个明智的做法，为什么呢？还是说只有 sed是这样的? 查看 man sed 来完成这个问题 sed是一个面向行的文本流处理程序 找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 journalctl ，而在 macOS 上使用 log show。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作： Logs begin at ... 和 systemd[577]: Startup finished in ... 在 macOS 上, 查找: === system boot: 和 Previous shutdown cause: 5 查看之前三次重启启动信息中不同的部分 (参见 journalctl的-b 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用sed '0,/STRING/d' 来删除 STRING匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用uniq )。最后，删除所有出现过3次的内容（因为这些内容上三次启动日志中的重复部分）。 在网上找一个类似 这个 或者 这个的数据集。或者从 这里找一些。使用 curl 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么pup可能会更有帮助。对于JSON类型的数据，可以试试jq。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。✔️ # 数据集：https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm # 以标签为依据提取数据，通过paste和sed格式化，截取需要的部分 cat ./tree.htm | pup --color 'tbody text{}' | paste -sd, | sed -E 's/([A-Z])/\\n\\1/g' | tail -n +1754 &gt; list.txt # 按列提取并排列求最值 cat list.txt | awk -F , '{print $2}' | sort -n # 将分隔符替换为‘-’，使用bc命令即可求出两列之差 cat list.txt | awk -F , '{print $2,$3}'| sed 's/ /-/' | tail -n +3 | bc -l | paste -sd+ | bc -l ","link":"https://umeimmense.github.io/post/shu-ju-zheng-li"},{"title":"编辑器（Vim）","content":" 课程链接：编辑器 (Vim) · the missing semester of your cs education (missing-semester-cn.github.io) 写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如 微软的 Word 与 Visual Studio Code） 作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤： 阅读教程（比如这节课以及我们为您提供的资源） 坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低） 随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有。 如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。当学习时间累计达到20个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。 该学哪个编辑器？ 程序员们对自己正在使用的文本编辑器通常有着 非常强的执念。 现在最流行的编辑器是什么？ Stack Overflow的调查(这个调查可能并不如我们想象的那样客观，因为Stack Overflow 的用户并不能代表所有程序员 )显示， Visual Studio Code是目前最流行的代码编辑器。而Vim 则是最流行的基于命令行的编辑器。 Vim 这门课的所有教员都使用Vim作为编辑器。Vim有着悠久历史；它始于1976年的Vi编辑器，到现在还在 不断开发中。Vim有很多聪明的设计思想，所以很多其他工具也支持Vim模式（比如，140万人安装了 Vim emulation for VS code）。即使你最后使用 其他编辑器，Vim也值得学习。 由于不可能在50分钟内教授Vim的所有功能， 我们会专注于解释Vim的设计哲学，教你基础知识， 展示一部分高级功能，然后给你掌握这个工具所需要的资源。 Vim的哲学 在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以， Vim 是一个 多模态 编辑 器： 它对于插入文字和操纵文字有不同的模式。 Vim 既是可编程的 （可以使用 Vimscript 或者像 Python 一样的其他程序语言）， Vim 的接口本身也是一个程序语言： 键入操作 （以及其助记名） 是命令， 这些命令也是可组合的。 Vim 避免了使用鼠标，因为那样太慢了； Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。 这样的设计哲学的结果是一个能跟上你思维速度的编辑器。 编辑模式 Vim的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式： 正常模式：在文件中四处移动光标进行修改 插入模式：插入文本 替换模式：替换文本 可视化（一般，行，块）模式：选中文本块 命令模式：用于执行命令 在不同的操作模式下， 键盘敲击的含义也不同。比如，x 在插入模式会插入字母x，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。 在默认设置下，Vim会在左下角显示当前的模式。 Vim启动时的默认模式是正常模式。通常你会把大部分 时间花在正常模式和插入模式。 你可以按下 &lt;ESC&gt; （退出键） 从任何其他模式返回正常模式。 在正常模式，键入 i 进入插入 模式， R 进入替换模式， v 进入可视（一般）模式， V 进入可视（行）模式， &lt;C-v&gt; （Ctrl-V, 有时也写作 ^V）进入可视（块）模式， : 进入命令模式。 因为你会在使用 Vim 时大量使用 &lt;ESC&gt; 键，所以可以考虑把大小写锁定键重定义成 &lt;ESC&gt; 键 （MacOS 教程 ）。 基本操作 插入文本 在正常模式， 键入 i 进入插入模式。 现在 Vim 跟很多其他的编辑器一样， 直到你键入&lt;ESC&gt; 返回正常模式。 你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。 缓存， 标签页， 窗口 Vim 会维护一系列打开的文件，称为 “缓存”。 一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口 （分隔面板）。每个窗口显示一个缓存。 跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系； 窗口只是视角。 一个缓存可以在 多个 窗口打开，甚至在同一 个标签页内的多个窗口打开。这个功能其实很好用， 比如在查看同一个文件的不同部分的时候。 Vim 默认打开一个标签页，这个标签也包含一个窗口。 命令行 在正常模式下键入 : 进入命令行模式。 在键入 : 后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能， 包括打开， 保存， 关闭文件， 以及 退出 Vim。 :q 退出 （关闭窗口） :w 保存 （写） :wq 保存然后退出 :e {文件名} 打开要编辑的文件 :ls 显示打开的缓存 :help {标题} 打开帮助文档 :help :w 打开 :w 命令的帮助文档 :help w 打开 w 移动的帮助文档 Vim 的接口其实是一种编程语言 Vim 最重要的设计思想是 Vim 的界面本身是一个程序语言。 键入操作 （以及他们的助记名） 本身是命令， 这些命令可以组合使用。 这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。 移动 多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。 基本移动: hjkl （左， 下， 上， 右） 词： w （下一个词）， b （词初）， e （词尾） 行： 0 （行初）， ^ （第一个非空格字符）， $ （行尾） 屏幕： H （屏幕首行）， M （屏幕中间）， L （屏幕底部） 翻页： Ctrl-u （上翻）， Ctrl-d （下翻） 文件： gg （文件头）， G （文件尾） 行数： :{行数}&lt;CR&gt; 或者 {行数}G ({行数}为行数) 杂项： % （找到配对，比如括号或者 /* */ 之类的注释对） 查找： f{字符} ， t{字符} ， F{字符} ， T{字符} 查找/到 向前/向后 在本行的{字符} , / ; 用于导航匹配 搜索: /{正则表达式}, n / N 用于导航匹配 选择 可视化模式: 可视化 可视化行 可视化块 可以用移动命令来选中。 编辑 所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。 i 进入插入模式 但是对于操纵/编辑文本，不单想用退格键完成 O / o 在之上/之下插入行 d{移动命令} 删除 {移动命令} 例如， dw 删除词, d$ 删除到行尾, d0 删除到行头。 c{移动命令} 改变 {移动命令} 例如， cw 改变词 比如 d{移动命令} 再 i x 删除字符 （等同于 dl） s 替换字符 （等同于 xi） 可视化模式 + 操作 选中文字, d 删除 或者 c 改变 u 撤销, &lt;C-r&gt; 重做 y 复制 / “yank” （其他一些命令比如 d 也会复制） p 粘贴 更多值得学习的: 比如 ~ 改变字符的大小写 计数 你可以用一个计数来结合“名词” 和 “动词”， 这会执行指定操作若干次。 3w 向前移动三个词 5j 向下移动5行 7dw 删除7个词 修饰语 你可以用修饰语改变 “名词” 的意义。修饰语有 i， 表示 “内部” 或者 “在内“， 和 a， 表示 ”周围“。 ci( 改变当前括号内的内容 ci[ 改变当前方括号内的内容 da' 删除一个单引号字符串， 包括周围的单引号 演示 这里是一个有问题的 fizz buzz 实现： def fizz_buzz(limit): for i in range(limit): if i % 3 == 0: print('fizz') if i % 5 == 0: print('fizz') if i % 3 and i % 5: print(i) def main(): fizz_buzz(10) 我们会修复以下问题： 主函数没有被调用 从 0 而不是 1 开始 在 15 的整数倍的时候在不用行打印 “fizz” 和 “buzz” 在 5 的整数倍的时候打印 “fizz” 采用硬编码的参数 10 而不是从命令控制行读取参数 展示详情请观看课程视频。 比较上面用 Vim 的操作和你可能使用其他程序的操作。 值得一提的是 Vim 需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。 自定义 Vim Vim 由一个位于 ~/.vimrc 的文本配置文件 （包含 Vim 脚本命令）。 你可能会启用很多基本 设置。 我们提供一个文档详细的基本设置， 你可以用它当作你的初始设置。 我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。 在 这儿 下载我们的设置， 然后将它保存成 ~/.vimrc. Vim 能够被重度自定义， 花时间探索自定义选项是值得的。 你可以参考其他人的在 GitHub 上共享的设置文件， 比如， 你的授课人的 Vim 设置 (Anish, Jon (uses neovim), Jose)。 有很多好的博客文章也聊到了这个话题。 尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它， 然后采用对你有用的部分。 扩展 Vim Vim 有很多扩展插件。 跟很多互联网上已经过时的建议相反， 你 不 需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。 你可以使用内置的插件管理系统。 只需要创建一个 ~/.vim/pack/vendor/start/ 的文件夹， 然后把插件放到这里 （比如通过 git clone）。 以下是一些我们最爱的插件： ctrlp.vim: 模糊文件查找 ack.vim: 代码搜索 nerdtree: 文件浏览器 vim-easymotion: 魔术操作 我们尽量避免在这里提供一份冗长的插件列表。 你可以查看讲师们的开源的配置文件 (Anish, Jon, Jose) 来看看我们使用的其他插件。 浏览 Vim Awesome 来了解一些很棒的插件。 这个话题也有很多博客文章： 搜索 “best Vim plugins”。 其他程序的 Vim 模式 很多工具提供了 Vim 模式。 这些 Vim 模式的质量参差不齐； 取决于具体工具， 有的提供了 很多酷炫的 Vim 功能， 但是大多数对基本功能支持的很好。 Shell 如果你是一个 Bash 用户， 用 set -o vi。 如果你用 Zsh： bindkey -v。 Fish 用 fish_vi_key_bindings。 另外， 不管利用什么 shell， 你可以 export EDITOR=vim。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如， git 会使用这个编辑器来编辑 commit 信息。 Readline 很多程序使用 GNU Readline 库来作为 它们的命令控制行界面。 Readline 也支持基本的 Vim 模式， 可以通过在 ~/.inputrc 添加如下行开启： set editing-mode vi 比如， 在这个设置下， Python REPL 会支持 Vim 快捷键。 其他 甚至有 Vim 的网页浏览快捷键 browsers, 受欢迎的有 用于 Google Chrome 的 Vimium 和用于 Firefox 的 Tridactyl。 你甚至可以在 Jupyter notebooks 中用 Vim 快捷键。 Vim 进阶 这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你， 但是你 可以在使用中学习。 一个好的对策是: 当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有： 上网搜寻一下。 搜索和替换 :s （替换） 命令 （文档）。 %s/foo/bar/g 在整个文件中将 foo 全局替换成 bar %s/\\[.*\\](\\(.*\\))/\\1/g 将有命名的 Markdown 链接替换成简单 URLs 多窗口 用 :sp / :vsp 来分割窗口 同一个缓存可以在多个窗口中显示。 宏 q{字符} 来开始在寄存器 {字符} 中录制宏 q 停止录制 @{字符} 重放宏 宏的执行遇错误会停止 {计数}@{字符} 执行一个宏 {计数} 次 宏可以递归 首先用 q{字符}q 清除宏 录制该宏， 用 @{字符} 来递归调用该宏 （在录制完成之前不会有任何操作） 例子： 将 xml 转成 json ( file ) 一个有 “name” / “email” 键对象的数组 用一个 Python 程序？ 用 sed / 正则表达式 g/people/d %s/&lt;person&gt;/{/g %s/&lt;name&gt;\\(.*\\)&lt;\\/name&gt;/&quot;name&quot;: &quot;\\1&quot;,/g … Vim 命令 / 宏 Gdd, ggdd 删除第一行和最后一行 格式化最后一个元素的宏 （寄存器 e ） 跳转到有 &lt;name&gt; 的行 qe^r&quot;f&gt;s&quot;: &quot;&lt;ESC&gt;f&lt;C&quot;&lt;ESC&gt;q 格式化一个人的宏 跳转到有 &lt;person&gt; 的行 qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q 格式化一个人然后转到另外一个人的宏 跳转到有 &lt;person&gt; 的行 qq@pjq 执行宏到文件尾 999@q 手动移除最后的 , 然后加上 [ 和 ] 分隔符 扩展资料 vimtutor 是一个 Vim 安装时自带的教程 Vim Adventures 是一个学习使用 Vim 的游戏 Vim Tips Wiki Vim Advent Calendar 有很多 Vim 小技巧 Vim Golf 是用 Vim 的用户界面作为程序语言的 code golf Vi/Vim Stack Exchange Vim Screencasts Practical Vim （书） 课后练习 完成 vimtutor。 备注： 它在一个 80x24 （80 列， 24 行） 终端窗口看起来最好。✔️ 下载我们的 基本 vimrc， 然后把它保存到 ~/.vimrc。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。✔️ 安装和配置一个插件：✔️ ctrlp.vim. 用 mkdir -p ~/.vim/pack/vendor/start 创建插件文件夹 下载这个插件： cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim 读这个插件的 文档。 尝试用 CtrlP 来在一个工程文件夹里定位一个文件， 打开 Vim, 然后用 Vim 命令控制行开始 :CtrlP. 自定义 CtrlP： 添加 configuration 到你的 ~/.vimrc 来用按 Ctrl-P 打开 CtrlP 练习使用 Vim, 在你自己的机器上重做 演示。✔️ main is never called G end of file o open new line below type in &quot;if name ...&quot; thing starts at 0 instead of 1 search for /range ww to move forward 2 words i to insert text, &quot;1, &quot; ea to insert after limit, &quot;+1&quot; newline for &quot;fizzbuzz&quot; jj$i to insert text at end of line add &quot;, end=''&quot; jj. to repeat for second print jjo to open line below if add &quot;else: print()&quot; fizz fizz ci' to change fizz command-line argument ggO to open above &quot;import sys&quot; /10 ci( to &quot;int(sys.argv[1])&quot; # fizz_buzz.py import sys def fizz_buzz(limit): for i in range(1, limit+1): if i % 3 == 0: print('fizz', end='') if i % 5 == 0: print('buzz', end='') if i % 3 and i % 5: print(i) def main(): fizz_buzz(int(sys.argv[1])) if __name__ == '__main__': main() 下个月用 Vim 做你 所有 文件编辑。 每当不够高效的时候, 或者你感觉 “一定有一个更好的方式”， 尝试求助搜索引擎， 很有可能有一个更好的方式。 如果你遇到难题， 来我们的答疑时间或者给我们发邮件。✔️ 在你的其他工具中设置 Vim 快捷键 （见上面的操作指南）。✔️ 进一步自定义你的 ~/.vimrc 和安装更多插件。✔️ （高阶） 用 Vim 宏将 XML 转换到 JSON (例子文件)。 尝试着先完全自己做， 但是在你卡住的时候可以查看上面 宏 章节。✔️ 用 sed / 正则表达式 cat example-data.xml | sed '/people/d' | sed 's/&lt;person&gt;/{/g' | sed 's/&lt;\\/person&gt;/},/g' | sed 's/&lt;name&gt;\\(.*\\)&lt;\\/name&gt;/&quot;name&quot;: &quot;\\1&quot;,/g' | sed 's/&lt;email&gt;\\(.*\\)&lt;\\/email&gt;/&quot;email&quot;: &quot;\\1&quot;/g' &gt;data_changed.json # 手动移除最后的 , 然后加上 [ 和 ] 分隔符 Vim 命令 / 宏 Gdd, ggdd 删除第一行和最后一行 格式化name的宏 （寄存器e） 跳转到有 &lt;name&gt; 的行 qe^r&quot;f&gt;s&quot;: &quot;&lt;ESC&gt;f&lt;C&quot;&lt;ESC&gt;q 格式化person的宏 跳转到有 &lt;person&gt; 的行 qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q 格式化一个人然后转到另外一个人的宏 跳转到有 &lt;person&gt; 的行 qq@pjq 执行宏到文件尾 999@q 手动移除最后的 , 然后加上 [ 和 ] 分隔符 ","link":"https://umeimmense.github.io/post/bian-ji-qi-vim"},{"title":"Shell 工具和脚本","content":"Shell 工具和脚本 课程链接：Shell 工具和脚本 · the missing semester of your cs education (missing-semester-cn.github.io) Shell 脚本 到目前为止，我们已经学习来如何在shell中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。 shell脚本是一种更加复杂度的工具。 大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对shell所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是shell脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于bash脚本，因为它最流行，应用更为广泛。 在bash中为变量赋值的语法是foo=bar，访问变量中存储的数值，其语法为 $foo。 需要注意的是，foo = bar （使用空格隔开）是不能正确工作的，因为解释器会调用程序foo 并将 = 和 bar作为参数。 总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。 Bash中的字符串通过' 和 &quot;分隔符来定义，但是它们的含义并不相同。以'定义的字符串为原义字符串，其中的变量不会被转义，而 &quot;定义的字符串会将变量值进行替换。 foo=bar echo &quot;$foo&quot; # 打印 bar echo '$foo' # 打印 $foo 和其他大多数的编程语言一样，bash也支持if, case, while 和 for 这些控制流关键字。同样地， , bash 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个函数并使用cd进入该文件夹。 mcd () { mkdir -p &quot;$1&quot; cd &quot;$1&quot; } 这里 $1 是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考 这里。 $0 - 脚本名 $1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。 $@ - 所有参数 $# - 参数个数 $? - 前一个命令的返回值 $$ - 当前脚本的进程识别码 !! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。 $_ - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 命令通常使用 STDOUT来返回输出值，使用STDERR 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。 退出码可以搭配&amp;&amp; (与操作符) 和 || (或操作符)使用，用来进行条件判断，决定是否执行其他程序。同一行的多个命令可以用;分隔。程序 true 的返回码永远是0，false 的返回码永远是1。让我们看几个例子 false || echo &quot;Oops, fail&quot; # Oops, fail true || echo &quot;Will not be printed&quot; # true &amp;&amp; echo &quot;Things went well&quot; # Things went well false &amp;&amp; echo &quot;Will not be printed&quot; # false ; echo &quot;This will always run&quot; # This will always run 另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 命令替换 (command substitution)实现。 当您通过 $( CMD ) 这样的方式来执行CMD 这个命令时，然后它的输出结果会替换掉 $( CMD ) 。例如，如果执行 for file in $(ls) ，shell首先将调用ls ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 进程替换（process substitution）， &lt;( CMD ) 会执行 CMD 并将结果输出到一个临时文件中，并将 &lt;( CMD ) 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， diff &lt;(ls foo) &lt;(ls bar) 会显示文件夹 foo 和 bar 中文件的区别。 说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用grep 搜索字符串 foobar，如果没有找到，则将其作为注释追加到文件中。 #!/bin/bash echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间 echo &quot;Running program $0 with $# arguments with pid $$&quot; for file in $@; do grep foobar $file &gt; /dev/null 2&gt; /dev/null # 如果模式没有找到，则grep退出状态为 1 # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息 if [[ $? -ne 0 ]]; then echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fi done 在条件语句中，我们比较 $? 是否等于0。 Bash实现了许多类似的比较操作，您可以查看 test 手册。 在bash中进行比较时，尽量使用双方括号 [[ ]] 而不是单方括号 [ ]，这样会降低犯错的几率，尽管这样并不能兼容 sh。 更详细的说明参见这里。 当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 通配（ globbing） 通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。例如，对于文件foo, foo1, foo2, foo10 和 bar, rm foo?这条命令会删除foo1 和 foo2 ，而rm foo* 则会删除除了bar之外的所有文件。 花括号{} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。 convert image.{png,jpg} # 会展开为 convert image.png image.jpg cp /path/to/project/{foo,bar,baz}.sh /newpath # 会展开为 cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath # 也可以结合通配使用 mv *{.py,.sh} folder # 会移动所有 *.py 和 *.sh 文件 mkdir foo bar # 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件 touch {foo,bar}/{a..h} touch foo/x bar/y # 显示foo和bar文件的不同 diff &lt;(ls foo) &lt;(ls bar) # 输出 # &lt; x # --- # &gt; y 编写 bash 脚本有时候会很别扭和反直觉。例如 shellcheck这样的工具可以帮助你定位sh/bash脚本中的错误。 注意，脚本并不一定只有用bash写才能在终端里调用。比如说，这是一段Python脚本，作用是将输入的参数倒序输出： #!/usr/local/bin/python import sys for arg in reversed(sys.argv[1:]): print(arg) shell知道去用python解释器而不是shell命令来运行这段脚本，是因为脚本的开头第一行的shebang。 在 shebang 行中使用 env 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。env 会利用我们第一节讲座中介绍过的PATH 环境变量来进行定位。 例如，使用了env的shebang看上去时这样的#!/usr/bin/env python。 shell函数和脚本有如下一些不同点： 函数只能用与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 shebang 是很重要的。 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。 函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 export 将环境变量导出，并将值传递给环境变量。 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。 Shell 工具 查看命令如何使用 看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 ls -l, mv -i 和 mkdir -p。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？ 一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。 在上一节中我们介绍过，最常用的方法是为对应的命令行添加-h 或 --help 标记。另外一个更详细的方法则是使用man 命令。man 命令是手册（manual）的缩写，它提供了命令的用户手册。 例如，man rm 会输出命令 rm 的说明，同时还有其标记列表，包括之前我们介绍过的-i。 事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 :help 命令或键入 ?来获取帮助。 有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。 TLDR pages 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。 例如，自己就常常在tldr上搜索tar 和 ffmpeg 的用法。 查找文件 程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 find的工具，它是shell上用于查找文件的绝佳工具。find命令会递归地搜索符合条件的文件，例如： # 查找所有名称为src的文件夹 find . -name src -type d # 查找所有文件夹路径中包含test的python文件 find . -path '**/test/**/*.py' -type f # 查找前一天修改的所有文件 find . -mtime -1 # 查找所有大小在500k至10M的tar.gz文件 find . -size +500k -size -10M -name '*.tar.gz' 除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。 # Delete all files with .tmp extension find . -name '*.tmp' -exec rm {} \\; # Find all PNG files and convert them to JPG find . -name '*.png' -exec convert {} {}.jpg \\; 尽管 find 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 PATTERN 的文件，您需要执行 find -name '*PATTERN*' (如果您希望模式匹配时是不区分大小写，可以使用-iname选项） 您当然可以使用alias设置别名来简化上述操作，但shell的哲学之一便是寻找（更好用的）替代方案。 记住，shell最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。 例如， fd 就是一个更简单、更快速、更友好的程序，它可以用来作为find的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式PATTERN 搜索的语法是 fd PATTERN。 大多数人都认为 find 和 fd 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。 这就要靠 locate 了。 locate 使用一个由 updatedb负责更新的数据库，在大多数系统中 updatedb 都会通过 cron每日更新。这便需要我们在速度和时效性之间作出权衡。而且，find 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，locate则只能通过文件名。 here有一个更详细的对比。 查找代码 查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。 为了实现这一点，很多类UNIX的系统都提供了grep命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。 grep 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 -C ：获取查找结果的上下文（Context）；-v 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， grep -C 5 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 -R 会递归地进入子目录并搜索所有的文本文件。 但是，我们有很多办法可以对 grep -R 进行改进，例如使其忽略.git 文件夹，使用多CPU等等。 因此也出现了很多它的替代品，包括 ack, ag 和 rg。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (rg) ，因为它速度快，而且用法非常符合直觉。例子如下： # 查找所有使用了 requests 库的文件 rg -t py 'import requests' # 查找所有没有写 shebang 的文件（包含隐藏文件） rg -u --files-without-match &quot;^#!&quot; # 查找所有的foo字符串，并打印其之后的5行 rg foo -A 5 # 打印匹配的统计信息（匹配的行和文件的数量） rg --stats PATTERN 与 find/fd 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。 查找 shell 命令 目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。 history 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 grep 进行模式搜索。 history | grep find 会打印包含find子串的命令。 对于大多数的shell来说，您可以使用 Ctrl+R 对命令历史记录进行回溯搜索。敲 Ctrl+R 后您可以输入子串来进行匹配，查找历史命令行。 反复按下就会在所有搜索结果中循环。在 zsh中，使用方向键上或下也可以完成这项工作。 Ctrl+R 可以配合 fzf 使用。fzf 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。 另外一个和历史命令相关的技巧我喜欢称之为基于历史的自动补全。 这一特性最初是由 fish shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 zsh 中也可以使用，它可以极大的提高用户体验。 最后，有一点值得注意，输入命令时，如果您在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。如果你不小心忘了在前面加空格，可以通过编辑。bash_history或 .zhistory 来手动地从历史记录中移除那一项。 文件夹导航 之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录 间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 ln -s创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。 对于本课程的主题来说，我们希望对常用的情况进行优化。使用fasd可以查找最常用和/或最近使用的文件和目录。 Fasd 基于 frecency对文件和文件排序，也就是说它会同时针对频率（frequency ）和时效（ recency）进行排序。 最直接的用法是自动跳转 （autojump），对于经常访问的目录，在目录名子串前加入一个命令 z 就可以快速切换命令到该目录。例如， 如果您经常访问/home/user/files/cool_project 目录，那么可以直接使用 z cool 跳转到该目录。 还有一些更复杂的工具可以用来概览目录结构，例如 tree, broot 或更加完整的文件管理器，例如 nnn 或 ranger。 课后练习 阅读 man ls ，然后使用ls 命令进行如下操作： 所有文件（包括隐藏文件） 文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) 文件以最近访问顺序排序 以彩色文本显示输出结果 典型输出如下：✔️ -rw-r--r-- 1 user group 1.1M Jan 14 09:53 baz drwxr-xr-x 5 user group 160 Jan 14 09:53 . -rw-r--r-- 1 user group 514 Jan 14 06:42 bar -rw-r--r-- 1 user group 106M Jan 13 12:12 foo drwx------+ 47 user group 1.5K Jan 12 18:08 .. ls -lath --color=auto 编写两个bash函数 marco 和 polo 执行下面的操作。 每当你执行 marco 时，当前的工作目录应当以某种形式保存，当执行 polo 时，无论现在处在什么目录下，都应当 cd 回到当时执行 marco 的目录。 为了方便debug，你可以把代码写在单独的文件 marco.sh 中，并通过 source marco.sh命令，（重新）加载函数。✔️ marco(){ export MARCO=$(pwd) } polo(){ cd &quot;$MARCO&quot; } 假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。✔️ #!/usr/bin/env bash n=$(( RANDOM % 100 )) if [[ n -eq 42 ]]; then echo &quot;Something went wrong&quot; &gt;&amp;2 echo &quot;The error was using magic numbers&quot; exit 1 fi echo &quot;Everything went according to plan&quot; # errcheck.sh #! /bin/bash ./err.sh &gt; ./record.txt 2&gt; ./record.txt m=1 while [ $? -eq 0 ] do let m++ ./err.sh &gt;&gt; ./record.txt 2&gt;&gt; ./record.txt done cat ./record.txt echo &quot;run times: $m&quot; 本节课我们讲解的 find 命令中的 -exec 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如tar 则需要从参数接受输入。这里我们可以使用xargs 命令，它可以使用标准输入中的内容作为参数。 例如 ls | xargs rm 会删除当前目录中的所有文件。 您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 xargs的参数-d）✔️ --delimiter=&quot;\\n\\b&quot; 以回车换行为分隔符 find -name &quot;*.html&quot; | xargs --delimiter=&quot;\\n\\b&quot; zip -r taylorswift.zip find . -type f -name &quot;*.html&quot; | xargs -d '\\n' tar -cvzf archive.tar.gz (进阶) 编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？✔️ find ./test/ -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head ","link":"https://umeimmense.github.io/post/shell-gong-ju-he-jiao-ben"},{"title":"课程概览与 shell","content":" 课程链接：课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io) 动机 作为计算机科学家，我们都知道计算机最擅长帮助我们完成重复性的工作。 但是我们却常常忘记这一点也适用于我们使用计算机的方式，而不仅仅是利用计算机程序去帮我们求解问题。 在从事与计算机相关的工作时，我们有很多触手可及的工具可以帮助我们更高效的解决问题。 但是我们中的大多数人实际上只利用了这些工具中的很少一部分，我们常常只是死记硬背一些如咒语般的命令， 或是当我们卡住的时候，盲目地从网上复制粘贴一些命令。 本课程意在帮你解决这一问题。 我们希望教会您如何挖掘现有工具的潜力，并向您介绍一些新的工具。也许我们还可以促使您想要去探索（甚至是去开发）更多的工具。 我们认为这是大多数计算机科学相关课程中缺少的重要一环。 课程结构 本课程包含 11 个时长在一小时左右的讲座，每一个讲座都会关注一个 特定的主题。尽管这些讲座之间基本上是各自独立的，但随着课程的进行，我们会假定您已经掌握了之前的内容。 每个讲座都有在线笔记供查阅，但是课上的很多内容并不会包含在笔记中。因此我们也会把课程录制下来发布到互联网上供大家观看学习。 我们希望能在这 11 个一小时讲座中涵盖大部分必须的内容，因此课程的信息密度是相当大的。为了能帮助您以自己的节奏来掌握讲座内容，每次课程都包含一组练习来帮助您掌握本节课的重点。 课后我们会安排答疑的时间来回答您的问题。如果您参加的是在线课程，可以发送邮件到 missing-semester@mit.edu 来联系我们。 由于时长的限制，我们不可能达到那些专门课程一样的细致程度，我们会适时地将您介绍一些优秀的资源，帮助您深入的理解相关的工具或主题。 但是如果您还有一些特别关注的话题，也请联系我们。 shell 是什么？ 如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell 几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。 本节课我们会使用 Bourne Again SHell, 简称 &quot;bash&quot; 。 这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开shell 提示符（您输入指令的地方），您首先需要打开 终端 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。 使用 shell 当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的： missing:~$ 这是 shell 最主要的文本接口。它告诉你，你的主机名是 missing 并且您当前的工作目录（&quot;current working directory&quot;）或者说您当前所在的位置是 ~ (表示 &quot;home&quot;)。 $ 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入 命令 ，命令最终会被 shell 解析。最简单的命令是执行一个程序： missing:~$ date Fri 10 Jan 2020 11:49:31 AM EST missing:~$ 这里，我们执行了 date 这个程序，不出意料地，它打印出了当前的日前和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 参数 ： missing:~$ echo hello hello 上例中，我们让 shell 执行 echo ，同时指定参数 hello。echo 程序将该参数打印出来。 shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 \\ 进行处理（My\\ Photos）。 但是，shell 是如何知道去哪里寻找 date 或 echo 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 环境变量 $PATH，它会列出当 shell 接到某条指令时，进行程序搜索的路径： missing:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin missing:~$ which echo /bin/echo missing:~$ /bin/echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 当我们执行 echo 命令时，shell 了解到需要执行 echo 这个程序，随后它便会在 $PATH 中搜索由 : 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 可执行程序，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用 which 程序。我们也可以绕过 $PATH，通过直接指定需要执行的程序的路径来执行该程序 在shell中导航 shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 / 分割，而在Windows上是 \\。路径 / 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： C:\\）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 / 开头，那么它是一个 绝对路径，其他的都是 相对路径 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 pwd 命令来获取。此外，切换目录需要使用 cd 命令。在路径中，. 表示的是当前目录，而 .. 表示上级目录： missing:~$ pwd /home/missing missing:~$ cd /home missing:/home$ pwd /home missing:/home$ cd .. missing:/$ pwd / missing:/$ cd ./home missing:/home$ pwd /home missing:/home$ cd missing missing:~$ pwd /home/missing missing:~$ ../../bin/echo hello hello 注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。 一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。 为了查看指定目录下包含哪些文件，我们使用 ls 命令： missing:~$ ls missing:~$ cd .. missing:/home$ ls missing missing:/home$ cd .. missing:/$ ls bin boot dev etc home ... 除非我们利用第一个参数指定目录，否则 ls 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 - 开头，并可以改变程序的行为。通常，在执行程序时使用 -h 或 --help 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，ls --help 的输出如下： -l use a long listing format missing:~$ ls -l /home drwxr-xr-x 1 missing users 4096 Jun 15 2019 missing 这个参数可以打印出更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 d 表示 missing 是一个目录。然后接下来的九个字符，每三个字符构成一组。 （rwx）. 它们分别代表了文件所有者（missing），用户组（users） 以及其他所有人具有的权限。其中 - 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（w），missing 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：x）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（r）。对于文件来说，权限的意义也是类似的。注意，/bin 目录下的程序在最后一组，即表示所有人的用户组中，均包含 x 权限，也就是说任何人都可以执行这些程序。 在这个阶段，还有几个趁手的命令是您需要掌握的，例如 mv（用于重命名或移动文件）、 cp（拷贝文件）以及 mkdir（新建文件夹）。 如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 man 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 q 可以退出该程序。 missing:~$ man ls 在程序间创建连接 在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！ 最简单的重定向是 &lt; file 和 &gt; file。这两个命令可以将程序的输入输出流分别重定向到文件： missing:~$ echo hello &gt; hello.txt missing:~$ cat hello.txt hello missing:~$ cat &lt; hello.txt hello missing:~$ cat &lt; hello.txt &gt; hello2.txt missing:~$ cat hello2.txt hello 您还可以使用 &gt;&gt; 来向一个文件追加内容。使用管道（ pipes ），我们能够更好的利用文件重定向。 | 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来： missing:~$ ls -l / | tail -n1 drwxr-xr-x 1 root root 4096 Jun 20 2019 var missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2 219 我们会在数据清理一章中更加详细的探讨如何更好的利用管道。 一个功能全面又强大的工具 对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。 您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。 通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 取而代之的是我们会在需要的时候使用 sudo 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。 当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。 有一件事情是您必须作为根用户才能做的，那就是向 sysfs 文件写入内容。系统被挂载在 /sys 下，sysfs 文件则暴露了一些内核（kernel）参数。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。注意 Windows 和 macOS 没有这个文件 例如，您笔记本电脑的屏幕亮度写在 brightness 文件中，它位于 /sys/class/backlight 通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是： $ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*' /sys/class/backlight/thinkpad_screen/brightness $ cd /sys/class/backlight/thinkpad_screen $ sudo echo 3 &gt; brightness An error occurred while redirecting file 'brightness' open: Permission denied 出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 sudo 命令！关于 shell，有件事我们必须要知道。|、&gt;、和 &lt; 是通过 shell 执行的，而不是被各个程序单独执行。 echo 等程序并不知道 | 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， shell (权限为您的当前用户) 在设置 sudo echo 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。 明白这一点后，我们可以这样操作： $ echo 3 | sudo tee brightness 因为打开 /sys 文件的是 tee 这个程序，并且该程序以 root 权限在运行，因此操作可以进行。 这样您就可以在 /sys 中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）： $ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness 接下来..... 学到这里，您掌握的 shell 知识已经可以完成一些基础的任务了。您应该已经可以查找感兴趣的文件并使用大多数程序的基本功能了。 在下一场讲座中，我们会探讨如何利用 shell 及其他工具执行并自动化更复杂的任务。 课后练习 在 /tmp 下新建一个名为 missing 的文件夹。✔️ mkdir missing 用 man 查看程序 touch 的使用手册。✔️ man touch 用 touch 在 missing 文件夹中新建一个叫 semester 的文件。✔️ touch semester 将以下内容一行一行地写入semester文件： #!/bin/sh curl --head --silent https://missing.csail.mit.edu 第一行可能有点棘手， # 在Bash中表示注释，而 ! 即使被双引号（&quot;）包裹也具有特殊的含义。 单引号（'）则不一样，此处利用这一点解决输入问题。更多信息请参考 Bash quoting手册✔️ echo \\#'!'/bin/sh &gt; semester echo curl --head --silent https://missing.csail.mit.edu &gt;&gt; semester 尝试执行这个文件。例如，将该脚本的路径（./semester）输入到您的shell中并回车。如果程序无法执行，请使用 ls命令来获取信息并理解其不能执行的原因。✔️ 提示权限不够 执行ls -l命令 显示-rw-r--r-- ...显然没有可执行x权限 查看 chmod 的手册(例如，使用man chmod命令)✔️ man chmod 使用 chmod 命令改变权限，使 ./semester 能够成功执行，不要使用sh semester来执行该程序。您的shell是如何知晓这个文件需要使用sh来解析呢？更多信息请参考：shebang✔️ chmod ugo+x semester ./semester 使用 | 和 &gt; ，将 semester 文件输出的最后更改日期信息，写入根目录下的 last-modified.txt 的文件中✔️ ./semester | grep -i &quot;last-modified&quot; &gt; /home/last-modified.txt 写一段命令来从 /sys 中获取笔记本的电量信息，或者台式机CPU的温度。注意：macOS并没有sysfs，所以mac用户可以跳过这一题✔️ cat /sys/class/power_supply/battery/capacity ","link":"https://umeimmense.github.io/post/ke-cheng-gai-lan-yu-shell"},{"title":"什么是 DNS？ | DNS 的工作方式","content":"前言 阅读本文后，你将能够了解到一下内容： 定义 DNS 理解 DNS 的工作方式 区分递归和迭代 DNS 查找 将权威性域名服务器与递归 DNS 解析器分开 探索 DNS 高速缓存的工作方式 什么是 DNS？ 域名系统 (DNS) 是互联网的电话簿。人们通过例如 nytimes.com 或 espn.com 等域名在线访问信息。Web 浏览器通过 互联网协议 （IP） 地址进行交互。DNS 将域名转换为 IP 地址，以便浏览器能够加载互联网资源。 连接到 Internet 的每个设备都有一个唯一 IP 地址，其他计算机可使用该 IP 地址查找此设备。DNS 服务器使人们无需存储例如 192.168.1.1（IPv4 中）等 IP 地址或更复杂的较新字母数字 IP 地址，例如 2400:cb00:2048:1::c629:d7a2（IPv6 中）。 DNS 如何工作？ DNS 解析过程涉及将主机名（例如 www.example.com）转换为计算机友好的 IP 地址（例如 192.168.1.1）。Internet 上的每个设备都被分配了一个 IP 地址，必须有该地址才能找到相应的 Internet 设备 - 就像使用街道地址来查找特定住所一样。当用户想要加载网页时，用户在 Web 浏览器中键入的内容（example.com）与查找 example.com 网页所需的机器友好地址之间必须进行转换。 为理解 DNS 解析过程，务必了解 DNS 查询必须通过的各种硬件设备。对于 Web 浏览器而言，DNS 查询是“在幕后”发生的，除了初始请求外，不需要从用户的计算机进行任何交互。 加载网页涉及 4 个 DNS 服务器： DNS 解析器 - 该解析器可被视为被要求去图书馆的某个地方查找特定图书的图书馆员。DNS 解析器是一种服务器，旨在通过 Web 浏览器等应用程序接收客户端计算机的查询。然后，解析器一般负责发出其他请求，以便满足客户端的 DNS 查询。 根域名服务器 - 根域名服务器是将人类可读的主机名转换（解析）为 IP 地址的第一步。可将其视为指向不同书架的图书馆中的索引 - 一般其作为对其他更具体位置的引用。 TLD 名称服务器 —— 顶级域名服务器（TLD）可看做是图书馆中一个特殊的书架。这个域名服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 example.com 中，TLD 服务器为 “com”）。 权威性域名服务器 - 可将这个最终域名服务器视为书架上的字典，其中特定名称可被转换成其定义。权威性域名服务器是域名服务器查询中的最后一站。如果权威性域名服务器能够访问请求的记录，则其会将已请求主机名的 IP 地址返回到发出初始请求的 DNS 解析器（图书管理员）。 权威性 DNS 服务器与递归 DNS 解析器之间的区别是什么？ 这两个概念都是指 DNS 基础设施不可或缺的服务器（服务器组），但各自担当不同的角色，并且位于 DNS 查询管道内的不同位置。考虑二者差异的一种方式是，递归解析器位于 DNS 查询的开头，而权威性域名服务器位于末尾。 递归 DNS 解析器 递归解析器是一种计算机，其响应来自客户端的递归请求并花时间追踪 DNS 记录。为执行此操作，其发出一系列请求，直至到达用于所请求的记录的权威性 DNS 域名服务器为止（或者超时，或者如果未找到记录，则返回错误）。幸运的是，递归 DNS 解析器并不总是需要发出多个请求才能追踪响应客户端所需的记录；缓存是一种数据持久性过程，可通过在 DNS 查找中更早地服务于所请求的资源记录来为所需的请求提供捷径。 权威性 DNS 服务器 简言之，权威性 DNS 服务器是实际持有并负责 DNS 资源记录的服务器。这是位于 DNS 查找链底部的服务器，其将使用所查询的资源记录进行响应，从而最终允许发出请求的 Web 浏览器达到访问网站或其他 Web 资源所需的 IP 地址。权威性域名服务器从自身数据满足查询需求，无需查询其他来源，因为这是某些 DNS 记录的最终真实来源。 值得一提的是，在查询对象为子域（例如 foo.example.com 或 blog.example.com）的情况下，将向权威性域名服务器之后的序列添加一个附加域名服务器，其负责存储该子域的 CNAME 记录。 DNS 查找有哪些步骤？ 大多数情况下，DNS 与正被转换为相应 IP 地址的域名有关。要了解此过程的工作方式，在 DNS 查找从 Web 浏览器经过 DNS 查找过程然后再返回时，跟踪 DNS 查找的路径会有所帮助。我们来看一下这些步骤。 注意：通常，DNS 查找信息将本地缓存在查询计算机内，或者远程缓存在 DNS 基础设施内。DNS 查找通常有 8 个步骤。缓存 DNS 信息时，将从 DNS 查找过程中跳过一些步骤，从而使该过程更快。以下示例概述了不缓存任何内容时的所有 8 个步骤。 DNS 查找的 8 个步骤： 用户在 Web 浏览器中键入 “example.com”，查询传输到 Internet 中，并被 DNS 递归解析器接收。 接着，解析器查询 DNS 根域名服务器（.）。 然后，根服务器使用存储其域信息的顶级域（TLD）DNS 服务器（例如 .com 或 .net）的地址响应该解析器。在搜索 example.com 时，我们的请求指向 .com TLD。 然后，解析器向 .com TLD 发出请求。 TLD 服务器随后使用该域的域名服务器 example.com 的 IP 地址进行响应。 最后，递归解析器将查询发送到域的域名服务器。 example.com 的 IP 地址而后从域名服务器返回解析器。 然后 DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。 DNS 查找的这 8 个步骤返回 example.com 的 IP 地址后，浏览器便能发出对该网页的请求： 浏览器向该 IP 地址发出 HTTP 请求。 位于该 IP 的服务器返回将在浏览器中呈现的网页（第 10 步）。 什么是 DNS 解析器？ DNS 解析器是 DNS 查找的第一站，其负责与发出初始请求的客户端打交道。解析器启动查询序列，最终使 URL 转换为必要的 IP 地址。 注意：典型的未缓存 DNS 查找将涉及递归查询和迭代查询。 务必区分递归 DNS 查询和递归 DNS 解析器。该查询是指向需要解析该查询的 DNS 解析器发出的请求。DNS 递归解析器是一种计算机，其接受递归查询并通过发出必要的请求来处理响应。 DNS 查询有哪些类型？ 典型 DNS 查找中会出现三种类型的查询。通过组合使用这些查询，优化的 DNS 解析过程可缩短传输距离。在理想情况下，可以使用缓存的记录数据，从而使 DNS 域名服务器能够返回非递归查询。 3 种 DNS 查询类型： 递归查询 - 在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息。 迭代查询 - 在这种情况下，DNS 客户端将允许 DNS 服务器返回其能够给出的最佳应答。如果所查询的 DNS 服务器与查询名称不匹配，则其将返回对较低级别域名空间具有权威性的 DNS 服务器的引用。然后，DNS 客户端将对引用地址进行查询。此过程继续使用查询链中的其他 DNS 服务器，直至发生错误或超时为止。 非递归查询 - 当 DNS 解析器客户端查询 DNS 服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。DNS 服务器通常会缓存 DNS 记录，以防止更多带宽消耗和上游服务器上的负载。 什么是 DNS 高速缓存？DNS 高速缓存发生在哪里？ 缓存的目的是将数据临时存储在某个位置，从而提高数据请求的性能和可靠性。DNS 高速缓存涉及将数据存储在更靠近请求客户端的位置，以便能够更早地解析 DNS 查询，并且能够避免在 DNS 查找链中进一步向下的额外查询，从而缩短加载时间并减少带宽/CPU 消耗。DNS 数据可缓存到各种不同的位置上，每个位置均将存储 DNS 记录并保存由生存时间（TTL）决定的一段时间。 浏览器 DNS 缓存 现代 Web 浏览器设计为默认将 DNS 记录缓存一段时间。目的很明显；越靠近 Web 浏览器进行 DNS 缓存，为检查缓存并向 IP 地址发出正确请求而必须采取的处理步骤就越少。发出对 DNS 记录的请求时，浏览器缓存是针对所请求的记录而检查的第一个位置。 在 Chrome 浏览器中，您可以转到 chrome://net-internals/#dns 查看 DNS 缓存的状态。 操作系统（OS）级 DNS 缓存 操作系统级 DNS 解析器是 DNS 查询离开您计算机前的第二站，也是本地最后一站。操作系统内旨在处理此查询的过程通常称为“存根解析器”或 DNS 客户端。当存根解析器获取来自某个应用程序的请求时，其首先检查自己的缓存，以便查看是否有此记录。如果没有，则将本地网络外部的 DNS 查询（设置了递归标记）发送到 Internet 服务提供商（ISP）内部的 DNS 递归解析器。 与先前所有步骤一样，当 ISP 内的递归解析器收到 DNS 查询时，其还将查看所请求的主机到 IP 地址转换是否已经存储在其本地持久性层中。 根据其缓存中具有的记录类型，递归解析器还具有其他功能： 如果解析器没有 A 记录，但确实有针对权威性域名服务器的 NS 记录，则其将直接查询这些域名服务器，从而绕过 DNS 查询中的几个步骤。此快捷方式可防止从根和 .com 域名服务器（在我们对 example.com 的搜索中）进行查找，并且有助于更快地解析 DNS 查询。 如果解析器没有 NS 记录，它会向 TLD 服务器（本例中为 .com）发送查询，从而跳过根服务器。 万一解析器没有指向 TLD 服务器的记录，其将查询根服务器。这种情况通常在清除了 DNS 高速缓存后发生。 原文地址 ","link":"https://umeimmense.github.io/post/shi-me-shi-dns-or-dns-de-gong-zuo-fang-shi"},{"title":"自定义 React Hook: 实现 useHash 获取 url 上的 hash 值","content":"实现 useHash 本节我们实现自定义React hook useHash，它能实时获取浏览器的hash值，并允许更改它。 使用 useState hook 获取 Location 对象的 hash 属性。 使用 useCallback hook 创建一个更新状态的处理程序。 在挂载时使用 useEffect hook为“hashchange”事件添加监听器，并在卸载时清理它。 使用 useCallback hook 创建一个函数，该函数使用给定值更新 Location 对象的哈希属性。 实现 const useHash = () =&gt; { const [hash, setHash] = React.useState(() =&gt; window.location.hash); const hashChangeHandler = React.useCallback(() =&gt; { setHash(window.location.hash); }, []); React.useEffect(() =&gt; { window.addEventListener('hashchange', hashChangeHandler); return () =&gt; { window.removeEventListener('hashchange', hashChangeHandler); }; }, []); const updateHash = React.useCallback( newHash =&gt; { if (newHash !== hash) window.location.hash = newHash; }, [hash] ); return [hash, updateHash]; }; 样例 const MyApp = () =&gt; { const [hash, setHash] = useHash(); React.useEffect(() =&gt; { setHash('#list'); }, []); return ( &lt;&gt; &lt;p&gt;window.location.href: {window.location.href}&lt;/p&gt; &lt;p&gt;Edit hash: &lt;/p&gt; &lt;input value={hash} onChange={e =&gt; setHash(e.target.value)} /&gt; &lt;/&gt; ); }; ReactDOM.render(&lt;MyApp /&gt;, document.getElementById('root')); ","link":"https://umeimmense.github.io/post/zi-ding-yi-react-hook-shi-xian-usehash-huo-qu-url-shang-de-hash-zhi"},{"title":"自定义 React Hook: 实现只在更新时执行的 useUpdateEffect","content":"实现 useUpdateEffect 本节我们实现自定义React hook useUpdateEffect ，它会忽略第一次的副作用，只在后续更新时执行。 import * as React from 'react'; const App = () =&gt; { const [toggle, setToggle] = React.useState(true); const handleToggle = () =&gt; { setToggle(!toggle); }; const didMount = React.useRef(false); React.useEffect(() =&gt; { if (didMount.current) { console.log('I run only if toggle changes.'); } else { didMount.current = true; } }, [toggle]); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleToggle}&gt; Toggle &lt;/button&gt; {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;} &lt;/div&gt; ); }; export default App; 如果你定义一个可复用的自定义Hook，它只在更新时（而不是在挂载时）触发效果函数，你可以使用下面的hook： import * as React from 'react'; const useEffectOnlyOnUpdate = (callback, dependencies) =&gt; { const didMount = React.useRef(false); React.useEffect(() =&gt; { if (didMount.current) { callback(dependencies); } else { didMount.current = true; } }, [callback, dependencies]); }; const App = () =&gt; { const [toggle, setToggle] = React.useState(true); const handleToggle = () =&gt; { setToggle(!toggle); }; useEffectOnlyOnUpdate((dependencies) =&gt; { console.log('I run only if toggle changes.'); }, [toggle]); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleToggle}&gt; Toggle &lt;/button&gt; {toggle &amp;&amp; &lt;div&gt;Hello React&lt;/div&gt;} &lt;/div&gt; ); }; export default App; ","link":"https://umeimmense.github.io/post/react-zi-ding-yi-hooks-useupdateeffect"},{"title":"如何在 React Table 中实现 Search","content":"前言 在本节中，将实现带有搜索功能的 React Table。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户在表中搜索数据。 实现 React Table库没有自带搜索功能，但是，由于你可以从外部访问数据，因此你可以在将其传递给表之前对其进行操作。让我们看看这是如何工作的。 首先，创建一个 React useState Hook - 保存搜索的状态 - 和一个新的事件处理程序 - 作为稍后用户交互的回调函数： const App = () =&gt; { const [search, setSearch] = React.useState(''); const handleSearch = (event) =&gt; { setSearch(event.target.value); }; ... }; 接下来，在 Table 组件中，添加一个 HTML 输入字段来设置搜索状态： const App = () =&gt; { ... return ( &lt;&gt; &lt;label htmlFor=&quot;search&quot;&gt; Search by Task: &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt; &lt;/label&gt; &lt;Table data={data}&gt; ... &lt;/Table&gt; &lt;/&gt; ); }; 搜索状态生效。最后 展示的就是Table 组件之前搜索项目列表： const App = () =&gt; { const [search, setSearch] = React.useState(''); const handleSearch = (event) =&gt; { setSearch(event.target.value); }; const data = { nodes: nodes.filter((item) =&gt; item.name.includes(search) ), }; return ( &lt;&gt; &lt;label htmlFor=&quot;search&quot;&gt; Search by Task: &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt; &lt;/label&gt; &lt;Table data={data}&gt; ... &lt;/Table&gt; &lt;/&gt; ); };const App = () =&gt; { const [search, setSearch] = React.useState(''); const handleSearch = (event) =&gt; { setSearch(event.target.value); }; const data = { nodes: nodes.filter((item) =&gt; item.name.includes(search) ), }; return ( &lt;&gt; &lt;label htmlFor=&quot;search&quot;&gt; Search by Task: &lt;input id=&quot;search&quot; type=&quot;text&quot; onChange={handleSearch} /&gt; &lt;/label&gt; &lt;Table data={data}&gt; ... &lt;/Table&gt; &lt;/&gt; ); }; 如果你希望Table搜索不区分大小写，则需要调整过滤器功能： const data = { nodes: nodes.filter((item) =&gt; item.name.toLowerCase().includes(search.toLowerCase()) ), }; React Table 没有为搜索功能提供原生插件。但是，你可以将搜索到的列表从外部传递到Table并从外部进行搜索，因此你拥有所有选项。 ","link":"https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-search"},{"title":"如何在 React Table 中实现 Sort","content":"前言 在本节中，我想向你展示如何使用 React Table Library 及其 useSort 插件来实现排序功能。在前面的例子中，你已经安装了 React Table Library 来创建一个 Table 组件。现在，我们将允许用户通过单击列标题对Table中的列进行排序。 实现 首先，导入 useSort Hook： import { useSort } from '@table-library/react-table-library/sort'; 其次，使用Table的数据对其进行初始化，并将其作为 prop 传递给 Table 组件： const App = () =&gt; { const data = { nodes }; const sort = useSort(data); return ( &lt;Table data={data} sort={sort}&gt; ... &lt;/Table&gt; ); }; 之后，将你的标题列转换为可排序的： import { useSort, HeaderCellSort , } from '@table-library/react-table-library/sort'; const App = () =&gt; { ... return ( &lt;Table data={data} sort={sort}&gt; {(tableList) =&gt; ( &lt;&gt; &lt;Header&gt; &lt;HeaderRow&gt; &lt;HeaderCellSort sortKey=&quot;TASK&quot;&gt; Task &lt;/HeaderCellSort&gt; &lt;HeaderCellSort sortKey=&quot;DEADLINE&quot;&gt; Deadline &lt;/HeaderCellSort&gt; &lt;HeaderCellSort sortKey=&quot;TYPE&quot;&gt; Type &lt;/HeaderCellSort&gt; &lt;HeaderCellSort sortKey=&quot;COMPLETE&quot;&gt; Complete &lt;/HeaderCellSort&gt; &lt;/HeaderRow&gt; &lt;/Header&gt; &lt;Body&gt; ... &lt;/Body&gt; &lt;/&gt; )} &lt;/Table&gt; ); }; 然后为每个排序键创建各自的排序函数： const App = () =&gt; { const data = { nodes }; const sort = useSort(data, null, { sortFns: { TASK: (array) =&gt; array.sort((a, b) =&gt; a.name.localeCompare(b.name)), DEADLINE: (array) =&gt; array.sort((a, b) =&gt; a.deadline - b.deadline), TYPE: (array) =&gt; array.sort((a, b) =&gt; a.type.localeCompare(b.type)), COMPLETE: (array) =&gt; array.sort((a, b) =&gt; a.isComplete - b.isComplete), }, }); return ( &lt;Table data={data} sort={sort}&gt; ... &lt;/Table&gt; ); }; 只需几行，你就有一个可排序的Table。我们可以按字符串排序（按字母顺序）、按日期排序、按布尔值排序和按枚举排序。由于自己传递了 sortBy 函数，因此如何对列进行排序取决于sortBy 函数。 可能缺少的获取当前排序的onChange事件。让我们看看它是如何与 useSort 结合使用的： const App = () =&gt; { const data = { nodes }; const sort = useSort(data, { onChange: onSortChange, }, { sortFns: ..., } ); function onSortChange(action, state) { console.log(action, state); } ... }; onChange 回调函数使你可以访问触发排序更改的操作以及Table的实际排序状态。通过访问此信息，你可以基于它触发更多的Table或非Table事件（例如，服务器端排序等副作用）。 最后，值得注意的是，你传递给Table的排序对象包含排序状态——这使你能够随时访问它——以及以编程方式对列进行排序的所有函数。当在这个 React Table中使用自定义排序组件时，我们稍后会详细看到这一点。 无论如何，表中的列排序通常会带来更多要求。让我们来看看其中的两个： 例如，有时用户想要具有初始排序状态。这也可以通过 useSort 来实现，方法是传入一个默认的排序状态： const App = () =&gt; { ... const sort = useSort(data, { state: { sortKey: 'TASK', reverse: false, }, onChange: onSortChange, }, { sortFns: ..., } ); ... }; 另一个案例是将排序图标与来自第三方库（例如 Material UI）的自定义排序图标交换： import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined'; import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined'; import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined'; const App = () =&gt; { ... const sort = useSort( data, { onChange: onSortChange, }, { sortIcon: { margin: '0px', iconDefault: &lt;UnfoldMoreOutlinedIcon /&gt;, iconUp: &lt;KeyboardArrowUpOutlinedIcon /&gt;, iconDown: ( &lt;KeyboardArrowDownOutlinedIcon /&gt; ), }, sortFns: ... } ); ... }; 排序功能还有更多选项。只需前往 React Table 文档以了解有关它们的更多信息。 最后，使用 React Table Library 可以完全用自定义组件交换排序组件。对于我们的表格排序插件，我们可能希望将排序标题组件与我们自己的来自第三方库的 HTML 按钮进行交换。下面，你将看到一个如何在 React 表库中使用 Material UI 组件的示例。 首先，从你的第三方库中导入自定义组件（和自定义图标）： import MaterialButton from '@mui/material/Button'; import UnfoldMoreOutlinedIcon from '@mui/icons-material/UnfoldMoreOutlined'; import KeyboardArrowUpOutlinedIcon from '@mui/icons-material/KeyboardArrowUpOutlined'; import KeyboardArrowDownOutlinedIcon from '@mui/icons-material/KeyboardArrowDownOutlined'; 其次Table Header 使用第三方按钮： const App = () =&gt; { ... const getIcon = (sortKey) =&gt; { if (sort.state.sortKey === sortKey &amp;&amp; sort.state.reverse) { return &lt;KeyboardArrowDownOutlinedIcon /&gt;; } if (sort.state.sortKey === sortKey &amp;&amp; !sort.state.reverse) { return &lt;KeyboardArrowUpOutlinedIcon /&gt;; } return &lt;UnfoldMoreOutlinedIcon /&gt;; }; return ( &lt;Table data={data} sort={sort}&gt; {(tableList) =&gt; ( &lt;&gt; &lt;Header&gt; &lt;HeaderRow&gt; &lt;HeaderCell&gt; &lt;MaterialButton fullWidth style={{ justifyContent: 'flex-start' }} endIcon={getIcon('TASK')} onClick={() =&gt; sort.fns.onToggleSort({ sortKey: 'TASK', }) } &gt; Task &lt;/MaterialButton&gt; &lt;/HeaderCell&gt; ... &lt;/HeaderRow&gt; &lt;/Header&gt; &lt;Body&gt; ... &lt;/Body&gt; &lt;/&gt; )} &lt;/Table&gt; ); }; 请注意 useSort 中的排序对象如何为你提供创建自定义组件所需的一切。这样，你可以为每个表格列自定义排序组件。通过使用排序状态和所有排序功能，你可以从任何地方读取和写入排序状态。 ","link":"https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-sort"},{"title":"如何在 React Table 中实现 Resize","content":"前言 在本教程中，我想向你展示如何使用 React Table Library 及其调整大小功能。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件。现在，我们将允许用户调整表中列的大小。 实现 首先在Table的列上设置 resize 属性 &lt;Header&gt; &lt;HeaderRow&gt; &lt;HeaderCell resize&gt;Task&lt;/HeaderCell&gt; &lt;HeaderCell resize&gt;Deadline&lt;/HeaderCell&gt; &lt;HeaderCell resize&gt;Type&lt;/HeaderCell&gt; &lt;HeaderCell resize&gt;Complete&lt;/HeaderCell&gt; &lt;HeaderCell resize&gt;Tasks&lt;/HeaderCell&gt; &lt;/HeaderRow&gt; &lt;/Header&gt; 这是为Table启用可调整大小的列的最直接的方法。但是，如果你想有更多的配置选项，你可以传递一个对象。 例如，如果使用默认值，你可以为每个表格列定义最小宽度。 &lt;HeaderCell resize={{ minWidth: 50 }}&gt;Task&lt;/HeaderCell&gt; 你还可以调整大小区域的突出显示颜色并扩大调整区域的大小： &lt;HeaderCell resize={{ resizerWidth: 15, resizerHighlight: '#98d8ff', }} &gt; Task &lt;/HeaderCell&gt; ","link":"https://umeimmense.github.io/post/ru-he-zai-react-table-zhong-shi-xian-resize"},{"title":"如何 React Table 实现 Fixed Column","content":"前言 在本节中中，我想向你展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的列粘在一边： 实现 import { useTheme } from '@table-library/react-table-library/theme'; const App = () =&gt; { const data = { nodes }; const theme = useTheme({ BaseCell: ` &amp;:nth-of-type(1) { left: 0px; min-width: 250px; width: 250px; } &amp;:nth-of-type(2) { left: 250px; min-width: 150px; width: 150px; } &amp;:nth-of-type(3), &amp;:nth-of-type(4) { min-width: 50%; width: 50%; } `, }); return (...); }; 我们将列固定在左侧。你也可以以相同的方式将列固定到右侧。缺少的是给 Cell 组件一个 pinLeft（或 pinRight）Props来指示它们固定到一边： const App = () =&gt; { ... return ( &lt;Table data={data} theme={theme} layout={{ custom: true, horizontalScroll: true }}&gt; {(tableList) =&gt; ( &lt;&gt; &lt;Header&gt; &lt;HeaderRow&gt; &lt;HeaderCell pinLeft&gt;Task&lt;/HeaderCell&gt; &lt;HeaderCell pinLeft&gt;Deadline&lt;/HeaderCell&gt; &lt;HeaderCell&gt;Type&lt;/HeaderCell&gt; &lt;HeaderCell&gt;Complete&lt;/HeaderCell&gt; &lt;/HeaderRow&gt; &lt;/Header&gt; &lt;Body&gt; {tableList.map((item) =&gt; ( &lt;Row key={item.id} item={item}&gt; &lt;Cell pinLeft&gt;{item.name}&lt;/Cell&gt; &lt;Cell pinLeft&gt; {item.deadline.toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit', })} &lt;/Cell&gt; &lt;Cell&gt;{item.type}&lt;/Cell&gt; &lt;Cell&gt;{item.isComplete.toString()}&lt;/Cell&gt; &lt;/Row&gt; ))} &lt;/Body&gt; &lt;/&gt; )} &lt;/Table&gt; ); }; 一切就绪后，表格的非固定列将沿垂直方向滚动，而该列在表格的一侧保持固定。 ","link":"https://umeimmense.github.io/post/ru-he-react-table-shi-xian-gu-ding-lie"},{"title":"如何 React Table 实现 Fixed Header","content":"前言 在本节中中，我想向您展示如何使用带有固定标题的 React Table库。在前面的例子中，你已经安装了 React Table Library 来创建一个Table组件并给它一个主题。现在，我们将允许用户将他们的标题粘贴到顶部： 实现 import { useTheme } from '@table-library/react-table-library/theme'; const App = () =&gt; { const data = { nodes }; const theme = useTheme({ Table: ` height: 100%; `, }); return ( &lt;div style={{ height: '150px', }} &gt; &lt;Table data={data} theme={theme}&gt; ... &lt;/Table&gt; &lt;/div&gt; ); }; 固定Table标题所需的一切都是Table组件周围的容器组件。这样，Table的行将在垂直方向滚动，而标题保持在Table的顶部。 ","link":"https://umeimmense.github.io/post/ru-he-reacttable-shi-xian-gu-ding-biao-ti"},{"title":"如何在 React Table 使用 Theme","content":"前言 在本节中，我想向你展示如何使用 React Table Library 及其 useTheme 插件来使用自定义样式对你的表格进行主题化。在前面的例子中，你已经安装了 React Table Library 来创建一个Table 组件。 实现 首先，导入 useTheme Hook： import { useTheme } from '@table-library/react-table-library/theme'; 其次，用它创建一个主题并将其作为Props传递给 Table 组件： const THEME = {}; const App = () =&gt; { const data = { nodes }; const theme = useTheme(THEME); return ( &lt;Table data={data} theme={theme}&gt; ... &lt;/Table&gt; ); }; 只需几行，你就为表格创建了一个自定义主题。但是，主题是空的，接下来让我们看看如何使用它来调整表格的样式： const THEME = { HeaderRow: ` font-size: 14px; background-color: #eaf5fd; `, Row: ` font-size: 14px; &amp;:nth-child(odd) { background-color: #d2e9fb; } &amp;:nth-child(even) { background-color: #eaf5fd; } `, }; 本质上，主题是一本字典，你可以在其中设置表格的不同组件的样式。在最后一个示例中，我们设置了标题行和行组件的样式。由于两个组件共享一些相同的样式，你也可以将此样式提取为一个共同点： const THEME = { BaseRow: ` font-size: 14px; `, HeaderRow: ` background-color: #eaf5fd; `, Row: ` &amp;:nth-child(odd) { background-color: #d2e9fb; } &amp;:nth-child(even) { background-color: #eaf5fd; } `, }; 以下组件可用作样式键：Table、HeaderRow、Row、HeaderCell、Cell、BaseRow、BaseCell。最后，这应该为你提供所有入口点，以便为表格设置所有不同组件的样式。 ","link":"https://umeimmense.github.io/post/ru-he-zai-react-table-shi-yong-zhu-ti"},{"title":"如何创建 React Table 组件","content":"前言 在本节中，我想向你展示如何使用 React Table​​库在 React 中创建Table组件。在本节之后，你可以使用库的文档继续构建许多其他示例，例如搜索、过滤、排序、选择、嵌套树表或 React 表的分页功能。但让我们从基础开始。 实现 让我们从通过命令行安装 React Table Library ： npm install @table-library/react-table-library @emotion/react 任务是在 React Table​​组件中显示以下项列表： const list = [ { id: '1', name: 'VSCode', deadline: new Date(2022, 1, 17), type: 'SETUP', isComplete: true, }, { id: '2', name: 'JavaScript', deadline: new Date(2022, 2, 28), type: 'LEARN', isComplete: true, }, { id: '3', name: 'React', deadline: new Date(2022, 3, 8), type: 'LEARN', isComplete: false, } ]; 我们将从在 Table 组件可以使用的对象中构建列表开始。组件本身从库中导入： import * as React from 'react'; import { Table } from '@table-library/react-table-library/table'; const list = [ ... ]; const App = () =&gt; { const data = { nodes: list }; return &lt;Table data={data}&gt;{(tableList) =&gt; null}&lt;/Table&gt;; }; Table 组件接受一个数据对象作为带有节点属性的Props。这些节点是我们列表中的项，但是，该表使其对节点的命名更加通用，因为该表不仅可以显示列表结构，还可以显示树结构。 此外，Table 组件使用一个子函数作为子函数，它使我们能够以 tableList 的形式访问表中的列表。在内部，表格组件将各种修改应用于我们的列表——例如排序、分页等，如果启用了这些插件 - 因此应该使用 tableList（而不是数据或列表）来呈现表中的项。 React Table 库使用组合而不是配置。因此，你可以从库本身获得所有必要的构建块作为组件。让我们从表格的标题开始： import * as React from 'react'; import { Table, Header, HeaderRow, HeaderCell, } from '@table-library/react-table-library/table'; const list = [ ... ]; const App = () =&gt; { const data = { nodes: list }; return ( &lt;Table data={data}&gt; {(tableList) =&gt; ( &lt;Header&gt; &lt;HeaderRow&gt; &lt;HeaderCell&gt;Task&lt;/HeaderCell&gt; &lt;HeaderCell&gt;Deadline&lt;/HeaderCell&gt; &lt;HeaderCell&gt;Type&lt;/HeaderCell&gt; &lt;HeaderCell&gt;Complete&lt;/HeaderCell&gt; &lt;/HeaderRow&gt; &lt;/Header&gt; )} &lt;/Table&gt; ); }; 通过使用这些组件，你可以将表创建为组件的组合，而每个组件都有自己的职责。例如，我们不是只有一个 Table 组件可以接受一个大型配置对象，而是有可组合的组件——例如 Header、HeaderRow 和 HeaderCell，它们可以接收专用的 props。 接下来，让我们像在 React 中渲染列表时所习惯的那样显示我们的项，方法是渲染 Row 组件，并为 Body 组件中的每个项提供一个键： import * as React from 'react'; import { Table, Header, HeaderRow, HeaderCell, Body, Row, Cell, } from '@table-library/react-table-library/table'; const list = [ ... ]; const App = () =&gt; { const data = { nodes: list }; return ( &lt;Table data={data}&gt; {(tableList) =&gt; ( &lt;&gt; &lt;Header&gt; ... &lt;/Header&gt; &lt;Body&gt; {tableList.map((item) =&gt; ( &lt;Row key={item.id} item={item}&gt; &lt;Cell&gt;{item.name}&lt;/Cell&gt; &lt;Cell&gt; {item.deadline.toLocaleDateString( 'en-US', { year: 'numeric', month: '2-digit', day: '2-digit', } )} &lt;/Cell&gt; &lt;Cell&gt;{item.type}&lt;/Cell&gt; &lt;Cell&gt;{item.isComplete.toString()}&lt;/Cell&gt; &lt;/Row&gt; ))} &lt;/Body&gt; &lt;/&gt; )} &lt;/Table&gt; ); }; 由于你可以完全控制在 Cell 组件中呈现的内容，因此你可以根据需要格式化数据。布尔值可以转换为字符串，日期可以格式化为可读版本。 Cell 组件没有特殊的props来完成渲染。使用 React 表格​​库可以直接在 React 中呈现表格组件。 ","link":"https://umeimmense.github.io/post/ru-he-chuang-jian-react-table-zu-jian"},{"title":"自定义 React Hook：获取滚动条宽度","content":"前言 本节实现一个简洁的自定义 React Hook，它可以让你获得滚动条的宽度。你可以在任何 React 组件中使用它，它会返回这个特定浏览器（和操作系统）的滚动条的宽度： import * as React from 'react'; export const useScrollbarWidth = () =&gt; { const didCompute = React.useRef(false); const widthRef = React.useRef(0); if (didCompute.current) return widthRef.current; // Creating invisible container const outer = document.createElement('div'); outer.style.visibility = 'hidden'; outer.style.overflow = 'scroll'; // forcing scrollbar to appear outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps document.body.appendChild(outer); // Creating inner element and placing it in the container const inner = document.createElement('div'); outer.appendChild(inner); // Calculating difference between container's full width and the child width const scrollbarWidth = outer.offsetWidth - inner.offsetWidth; // Removing temporary elements from the DOM outer.parentNode.removeChild(outer); didCompute.current = true; widthRef.current = scrollbarWidth; return scrollbarWidth; }; 本质上，自定义Hook只是将隐藏的滚动条呈现到项目中，对其进行测量，然后再次将其删除。之后它返回结果。 作为替代方案，如果你希望在水平滚动容器的情况下使用高度而不是滚动条的宽度，则只需将宽度属性替换为高度属性。 就我个人而言，我自己从未遇到过这个问题，但是，当我们在客户端机器上测试应用程序时，在某些情况下滚动条没有覆盖并占用空间。通常这没关系，但是，我们遇到了一些用例，我们必须拥有滚动条的大小才能解决有关应用程序布局的问题。 ","link":"https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-tiao-kuan-du"},{"title":"自定义 React Hook：获取滚动方向","content":"前言 本节我们实现一个简洁的自定义 React Hook，它可以检测用户的滚动方向： import * as React from 'react'; const THRESHOLD = 0; const useScrollDirection = () =&gt; { const [scrollDirection, setScrollDirection] = React.useState('up'); const blocking = React.useRef(false); const prevScrollY = React.useRef(0); React.useEffect(() =&gt; { prevScrollY.current = window.pageYOffset; const updateScrollDirection = () =&gt; { const scrollY = window.pageYOffset; if (Math.abs(scrollY - prevScrollY.current) &gt;= THRESHOLD) { const newScrollDirection = scrollY &gt; prevScrollY.current ? 'down' : 'up'; setScrollDirection(newScrollDirection); prevScrollY.current = scrollY &gt; 0 ? scrollY : 0; } blocking.current = false; }; const onScroll = () =&gt; { if (!blocking.current) { blocking.current = true; window.requestAnimationFrame(updateScrollDirection); } }; window.addEventListener('scroll', onScroll); return () =&gt; window.removeEventListener('scroll', onScroll); }, [scrollDirection]); return scrollDirection; }; export { useScrollDirection }; 在一个函数组件中，自定义的 React Hook可以这样使用： import * as React from 'react'; import { useScrollDirection } from './useScrollDirection'; const App = () =&gt; { const scrollDirection = useScrollDirection(ref); console.log('up'); return (...); }; 最后，可能有很多方法可以改进这个自定义Hook（例如，检查水平而不是垂直滚动方向）。 ","link":"https://umeimmense.github.io/post/zi-ding-yi-react-hookhuo-qu-gun-dong-fang-xiang"},{"title":"自定义 React Hook：检查是否溢出","content":"前言 本节我们实现一个简洁的自定义 React Hook，它检查元素的内容是否溢出（这里：垂直溢出）： import * as React from 'react'; export const useIsOverflow = (ref, callback) =&gt; { const [isOverflow, setIsOverflow] = React.useState(undefined); React.useLayoutEffect(() =&gt; { const { current } = ref; const trigger = () =&gt; { const hasOverflow = current.scrollHeight &gt; current.clientHeight; setIsOverflow(hasOverflow); if (callback) callback(hasOverflow); }; if (current) { trigger(); } }, [callback, ref]); return isOverflow; }; 如果你想检测水平溢出，可以将 hasOverflow 分配交换为以下内容： const hasOverflow = current.scrollWidth &gt; current.clientWidth; 在一个函数组件中，自定义的 React Hook可以这样使用： import * as React from 'react'; import { useIsOverflow } from './useIsOverflow'; const App = () =&gt; { const ref = React.useRef(); const isOverflow = useIsOverflow(ref); console.log(isOverflow); // true return ( &lt;div style={{ overflow: 'auto', height: '100px' }} ref={ref}&gt; &lt;div style={{ height: '200px' }}&gt;Hello React&lt;/div&gt; &lt;/div&gt; ); }; Hook第一次返回未定义，因为状态尚未设置。 自定义Hook还接受一个可选的回调函数，该函数在检查溢出后触发： const App = () =&gt; { const ref = React.useRef(); const isOverflow = useIsOverflow(ref, (isOverflowFromCallback) =&gt; { console.log(isOverflowFromCallback); // true }); console.log(isOverflow); // true return ( &lt;div style={{ overflow: 'auto', height: '100px' }} ref={ref}&gt; &lt;div style={{ height: '200px' }}&gt;Hello React&lt;/div&gt; &lt;/div&gt; ); }; 如果元素的大小发生变化，你可以调整自定义Hook以再次检查验证溢出，但前提是浏览器支持 ResizeObserver： import * as React from 'react'; export const useIsOverflow = (ref, callback) =&gt; { const [isOverflow, setIsOverflow] = React.useState(undefined); React.useLayoutEffect(() =&gt; { const { current } = ref; const trigger = () =&gt; { const hasOverflow = current.scrollHeight &gt; current.clientHeight; setIsOverflow(hasOverflow); if (callback) callback(hasOverflow); }; if (current) { if ('ResizeObserver' in window) { new ResizeObserver(trigger).observe(current); } trigger(); } }, [callback, ref]); return isOverflow; }; 最后，可能有很多方法可以改进这个自定义Hook（例如，在自定义Hook中初始化 ref 并从自定义Hook返回它以将其附加到元素，只触发一次自定义Hook）。 ","link":"https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-cha-shi-fou-yi-chu"},{"title":"自定义 React Hook：使用LocalStorage","content":"实现 useLocalStorage 一个简洁的自定义 React Hook，展示了如何在 React 中使用本地存储来存储状态。你可以在任何 React 组件中使用它，它允许你在本地存储中写入和读取状态： import * as React from 'react'; const useLocalStorage = (storageKey, fallbackState) =&gt; { const [value, setValue] = React.useState( JSON.parse(localStorage.getItem(storageKey)) ?? fallbackState ); React.useEffect(() =&gt; { localStorage.setItem(storageKey, JSON.stringify(value)); }, [value, storageKey]); return [value, setValue]; }; const App = () =&gt; { const [isOpen, setOpen] = useLocalStorage('is-open', false); const handleToggle = () =&gt; { setOpen(!isOpen); }; return ( &lt;div&gt; &lt;button onClick={handleToggle}&gt;Toggle&lt;/button&gt; {isOpen &amp;&amp; &lt;div&gt;Content&lt;/div&gt;} &lt;/div&gt; ); }; export default App; 本地存储Hook只是作为一种学习体验。如果你在生产环境中依赖 React 应用程序的本地存储，你应该检查更广泛使用的Hook（因此是健壮的）。 ","link":"https://umeimmense.github.io/post/zi-ding-yi-react-hookshi-yong-localstorage"},{"title":"自定义 React Hook：检测组件外部的点击","content":"前言 本章我们一起来聊聊如何创建自定义 React Hook来检测 React 组件外部的点击。例如，你可能希望为各种组件（如对话框或下拉菜单）提供此类自定义 React Hook，因为当用户单击它们外部时它们应该关闭。所以我们需要一种方法来找出这个外部点击。 在这里学到的大部分内容都可以追溯到 JavaScript 中事件冒泡和捕获的概念。因此，如果你需要对冒泡、目标和捕获阶段进行复习，我建议你阅读以下文章，之前该文章涉及 React 的这个主题。 实现 让我们从 React 中的一个函数组件开始，我们使用 React 的 useState Hook 和一个事件处理程序来增加一个计数器： import * as React from 'react'; const style = { padding: '10px', border: '1px solid black', display: 'flex', justifyContent: 'flex-end', }; function App() { const [count, setCount] = React.useState(0); const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div style={style}&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } export default App; 一切都按预期工作。接下来，我们要在用户单击按钮外部时重置状态（此处为：计数）。我们可以编写用于重置状态的事件处理程序，但是尚不清楚在哪里使用它： function App() { const [count, setCount] = React.useState(0); const handleClickOutside = () =&gt; { setCount(0); }; const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div style={style}&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } 一种原始的方法是在顶级组件的最外层 HTML 元素（这里：）上使用这个新的处理程序。但是，更好的方法是在文档级别使用此事件处理程序作为最佳实践，因为最外层的 HTML 元素可能会在开发过程中发生变化。 我们将直接在自定义Hook中实现这一点，以避免冗余重构： const useOutsideClick = (callback) =&gt; { const ref = React.useRef(); React.useEffect(() =&gt; { const handleClick = (event) =&gt; { callback(); }; document.addEventListener('click', handleClick); return () =&gt; { document.removeEventListener('click', handleClick); }; }, []); return ref; }; 自定义Hook会启动一个最终返回的 React ref。它还没有真正用在Hook的实现细节中。此外，自定义Hook使用 React 的 useEffect Hook在文档级别分配（和删除）一个事件监听器（这里：单击事件）。毕竟，每当单击文档时，处理程序以及传递的回调函数都会运行。 现在自定义Hook可以在我们的 React 组件中以下列方式使用：将事件处理程序作为回调函数传递给Hook——只要单击文档就会执行。此外，使用返回的引用（此处为：ref）并将其分配给按钮 HTML 元素： function App() { const [count, setCount] = React.useState(0); const handleClickOutside = () =&gt; { setCount(0); }; const ref = useOutsideClick(handleClickOutside); const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div style={style}&gt; &lt;button ref={ref} type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } 但是，你会注意到，处理程序将始终触发，即使在单击按钮本身时也是如此。如果你再次检查自定义Hook，你将看到该引用（ref）并没有真正在其中使用。我们想要完成的事情：仅在单击传递的 ref（此处表示按钮）之外的任何内容时执行回调函数，而不是在单击 ref 本身（或其内容）时执行回调函数： const useOutsideClick = (callback) =&gt; { const ref = React.useRef(); React.useEffect(() =&gt; { const handleClick = (event) =&gt; { if (ref.current &amp;&amp; !ref.current.contains(event.target)) { callback(); } }; document.addEventListener('click', handleClick); return () =&gt; { document.removeEventListener('click', handleClick); }; }, [ref]); return ref; }; 就是这样。分配给按钮的引用是触发按钮的事件处理程序和文档的事件处理程序之间的边界。在参考之外点击的所有内容都将被视为外部点击。 但是缺少一个小的改进：如果我们需要通过在事件处理程序上使用 stopPropagation() 方法来停止某些边缘情况下的事件冒泡怎么办。例如，在下面我们通过单击容器元素来扩展组件并在那里停止事件的传播： const style = { padding: '10px', border: '1px solid black', display: 'flex', justifyContent: 'space-between', }; ... function App() { const [count, setCount] = React.useState(0); const handleClickOutside = () =&gt; { setCount(0); }; const ref = useOutsideClick(handleClickOutside); const handleClick = () =&gt; { setCount((state) =&gt; state + 1); }; const handleHeaderClick = (event) =&gt; { // do something event.stopPropagation(); }; return ( &lt;div style={style} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button ref={ref} type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } 当我们尝试这个例子时，我们会看到容器上的点击不会作为“外部点击”，因为即使它是外部点击，由于事件停止冒泡，它永远不会到达文档的事件侦听器。 通过使用冒泡和捕获阶段，我们可以调整自定义Hook以在捕获阶段触发。因为捕获阶段发生在冒泡阶段之前，所以即使事件在冒泡阶段停止传播，对文档的点击也将始终运行： const useOutsideClick = (callback) =&gt; { const ref = React.useRef(); React.useEffect(() =&gt; { const handleClick = (event) =&gt; { if (ref.current &amp;&amp; !ref.current.contains(event.target)) { callback(); } }; document.addEventListener('click', handleClick, true); return () =&gt; { document.removeEventListener('click', handleClick, true); }; }, [ref]); return ref; }; 就是这样。你创建了一个自定义挂钩来检测引用的组件/元素之外的点击。建议你再次阅读事件冒泡和捕获文章，以更深入地解释这些阶段发生的事情。 ","link":"https://umeimmense.github.io/post/zi-ding-yi-react-hookjian-ce-zu-jian-wai-bu-de-dian-ji"},{"title":"如何创建自定义 React Hook ","content":"前言 React 很久以前就引入了 Hooks。随着 Hooks 的发布，函数组件能够使用内置 Hooks 的状态和副作用，例如 React 的 useState Hook 和 React 的 useEffect Hook。 不过，React 只提供了少数内置 Hook（例如 useReducer、useCallback、useMemo、useContext）。但是，通过使用这些 Hooks 作为基础，React 开发人员可以创建自己的称为自定义 Hooks 的 Hooks。 在我们创建自定义Hook之前，你需要知道创建一个有两个规则： 自定义 Hooks 以“use”为前缀命名。例如，自定义Hook可以命名为 useLocalStorage 或 useAuthentication。在我们的例子中，自定义Hook将被命名为 useBoolean。 自定义 Hooks 由内置的 React Hooks 或其他自定义 Hooks 组成。因此，自定义 Hook 始终是一个或多个 Hook 的新组合。如果自定义 Hook 在内部不使用任何Hook，则它不是自定义 Hook，不应具有前缀“use”。 自定义Hook 我们将创建一个名为 useBoolean 的自定义 Hook，让我们看看它为我们解决了什么问题。让我们从一个小例子开始： import * as React from 'react'; function App() { const [isToggle, setToggle] = React.useState(false); const handleToggle = () =&gt; setToggle(!isToggle); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleToggle}&gt; Toggle &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } export default App; 该组件呈现一个用于切换布尔值的按钮。在React 应用程序中，要么切换它（如上一个示例），要么将其显式设置为 true 或 false（如下一个示例）： import * as React from 'react'; function App() { const [isToggle, setToggle] = React.useState(false); const handleToggle = () =&gt; setToggle(!isToggle); const handleTrue = () =&gt; setToggle(true); const handleFalse = () =&gt; setToggle(false); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleToggle}&gt; Toggle &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={handleTrue}&gt; To True &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={handleFalse}&gt; To False &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } export default App; 一些观点可能会争辩说，我们本可以使用内联处理程序，这样就不会有事件处理程序的重复声明。然而，我个人尽量避免使用内联处理程序，因为它们向 JSX 注入了太多逻辑，而应该在组件的函数签名和返回语句之间定义。但这只是个人喜好。 无论如何，每次使用有状态布尔值时，都会遇到相同的实现细节：要么切换布尔值，要么将其设置为两个可能值之一。为了在多个 React 组件中使用有状态布尔值时屏蔽这些重复代码，我开始为它创建一个自定义Hook： const useBoolean = () =&gt; { const [state, setState] = React.useState(); const handleTrue = () =&gt; setState(true); const handleFalse = () =&gt; setState(false); const handleToggle = () =&gt; setState(!state); return [ state, { setTrue: handleTrue, setFalse: handleFalse, setToggle: handleToggle, }, ]; }; 基本上所有实现细节，即状态和事件处理程序，都移到了这个名为 useBoolean 的自定义Hook中。此外，自定义Hook返回状态和更新数组中状态的函数。 从自定义Hook返回多个值时，返回一个数组是最佳实践，因为 React 的内置 Hooks（在返回多个值的情况下）利用了数组，因此也使用了数组解构。使用数组解构的好处是可以为解构的值赋予任何名称（在对象解构的情况下，代码比重命名值要少）。 const useBoolean = (initialState = false) =&gt; { const [state, setState] = React.useState(initialState); const handleTrue = () =&gt; setState(true); const handleFalse = () =&gt; setState(false); const handleToggle = () =&gt; setState(!state); return [ state, { setTrue: handleTrue, setFalse: handleFalse, setToggle: handleToggle, }, ]; }; 一个很好的补充是也添加一个初始状态（如最后一个代码片段所示）。回到我们的 App 组件，我们可以通过向它传递初始状态并使用它的返回值来显示状态并更新它来使用这个新的自定义Hook： function App() { const [isToggle, { setToggle }] = useBoolean(false); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={setToggle}&gt; Toggle &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } 由于自定义Hook不仅提供了切换有状态布尔值的功能，而且还可以将其显式设置为True或False，我们也可以使用这些功能： function App() { const [isToggle, { setToggle, setTrue, setFalse, }] = useBoolean(false); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={setToggle}&gt; Toggle &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={setTrue}&gt; To True &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={setFalse}&gt; To False &lt;/button&gt; {isToggle.toString()} &lt;/div&gt; ); } 本质上，我们将有状态的布尔值和所有在布尔值上运行的事件处理程序提取到一个自定义Hook中。通过每次我们需要一个有状态的布尔值时使用这个自定义钩子，我们可以节省定义事件处理程序，其中包括有关如何操作布尔值的实现细节，而不是使用从钩子返回的函数。 总之，我们已经学习了如何使用 React 的内置 Hook 之一（称为 useState）来创建自定义钩子。这个自定义钩子并不复杂，但是，它应该向你展示如何减少 React 项目中的复杂性和冗余。 ","link":"https://umeimmense.github.io/post/ru-he-chuang-jian-zi-ding-yi-react-hook"},{"title":"React 中的事件处理","content":"前言 在本节中，我们将了解 React 中用于 HTML 元素（例如按钮和输入元素）的事件处理程序。你将学习如何使用带有 onClick 事件的按钮，以及如何定义和使用不同类型的事件处理程序。本质上，我们将介绍三种事件处理程序：事件处理程序、内联事件处理程序和回调事件处理程序。 React中的事件处理程序 首先，我们将从 React 中针对特定 onClick 事件处理程序的按钮示例开始。这是关于如何在 React 中使用事件处理程序（也称为事件处理程序函数或处理程序）处理事件的最基本示例。按钮具有接收函数的 onClick 属性。每次触发事件时都会调用此函数（此处：单击按钮时）： import React from 'react'; function App() { function handleClick() { console.log('Button click ...'); } return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Event Handler &lt;/button&gt; &lt;/div&gt; ); } 对于其他属性，如 onChange（onChange 事件处理程序）和 onSubmit（onSubmit 事件处理程序），它的工作方式类似。对于初学者来说，onClick 经常不起作用，因为他们没有传递函数，而是直接在 JSX 中调用函数。例如，在下一个版本中，事件处理程序仅在第一次渲染组件时被调用一次。其他每一次单击都不会调用事件处理函数，因为函数的返回值用于 onClick 属性而不是函数本身。所以没有什么可调用的；除非函数返回另一个函数： import React from 'react'; function App() { function handleClick() { console.log('Button click ...'); } // don't do this return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleClick()}&gt; Event Handler &lt;/button&gt; &lt;/div&gt; ); } 通过使用 JavaScript 箭头函数，可以使事件处理函数更加简洁。不过，这是一个可选步骤。就个人而言，我喜欢将事件处理程序作为箭头函数： import React from 'react'; function App() { const handleClick = () =&gt; { console.log('Button click ...'); }; return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Event Handler &lt;/button&gt; &lt;/div&gt; ); } 但是一旦更多的事件处理程序在 React 组件中添加，通过再次给它们函数语句来使它们与其他变量更容易区分是很好的： import React from 'react'; function App() { const user = { id: '123abc', username: 'Robin Wieruch', }; function handleUserSignIn() { // do something } function handleUserSignUp() { // do something } function handleUserSignOut() { // do something } ... } 毕竟，onClick 事件的事件处理程序应该实现一些业务逻辑。在本例中，React 的 useState Hook 用于通过 onClick 按钮事件更新某些状态： import React from 'react'; function App() { const [count, setCount] = React.useState(0); function handleClick() { setCount(count + 1); } return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Increase Count &lt;/button&gt; &lt;/div&gt; ); } 下一个示例向你展示了一个输入字段而不是一个按钮。在那里，我们使用的是始终作为第一个参数传递给事件处理函数的实际事件。该事件是来自 React 的合成事件，它本质上封装了原生 HTML 事件并在其之上添加了一些功能。每次有人使用事件的目标属性输入输入字段时，此事件都会为你提供输入字段的值： import React from 'react'; function App() { const [text, setText] = React.useState(''); function handleChange(event) { setText(event.target.value); } return ( &lt;div&gt; &lt;input type=&quot;text&quot; onChange={handleChange} /&gt; {text} &lt;/div&gt; ); } 以前我们没有使用过该事件，因为在我们的按钮示例中我们不需要它。在输入字段示例中，我们需要它。最后但同样重要的是，不要忘记将值传递给输入元素以使其成为受控组件： import React from 'react'; function App() { const [text, setText] = React.useState(''); function handleChange(event) { setText(event.target.value); } return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={text} onChange={handleChange} /&gt; {text} &lt;/div&gt; ); } 简而言之，这就是事件处理程序。让我们了解 React 中更高级的处理程序。 React 中的内联事件处理程序 内联事件处理程序，也称为内联处理程序，通过直接在 JSX 中使用事件处理程序为我们提供了许多新选项： import React from 'react'; function App() { const [count, setCount] = React.useState(0); return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={function() { setCount(count + 1); }} &gt; Increase Count &lt;/button&gt; &lt;/div&gt; ); } 在 JSX 中使用通用函数语句虽然很冗长。因此，JavaScript 箭头函数可以方便地定义更简洁的内联处理程序： import React from 'react'; function App() { const [count, setCount] = React.useState(0); return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={() =&gt; setCount(count + 1)} &gt; Increase Count &lt;/button&gt; &lt;/div&gt; ); } 一般来说，开发者都是懒惰的人，所以经常使用内联事件处理程序来避免在 JSX 之外进行额外的函数声明。然而，这会将大量业务逻辑转移到 JSX 中，这使得它的可读性、可维护性和易错性降低。就个人而言，我喜欢在没有内联事件处理程序的情况下保持 JSX 干净，并在 JSX 之外声明事件处理程序。 内联处理程序也用于将参数传递给在 JSX 之外定义的更通用的处理程序： import React from 'react'; function App() { const [count, setCount] = React.useState(0); function handleCount(delta) { setCount(count + delta); } return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={() =&gt; handleCount(1)}&gt; Increase Count &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; handleCount(-1)}&gt; Decrease Count &lt;/button&gt; &lt;/div&gt; ); } 这样，也可以并行传递事件和参数。即使在此示例中不需要它，但你肯定会在将来遇到需要该事件的一种或另一种情况（例如 React Forms 的 preventDefault ）： import React from 'react'; function App() { const [count, setCount] = React.useState(0); function handleCount(event, delta) { setCount(count + delta); } return ( &lt;div&gt; Count: {count} &lt;button type=&quot;button&quot; onClick={event =&gt; handleCount(event, 1)}&gt; Increase Count &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={event =&gt; handleCount(event, -1)}&gt; Decrease Count &lt;/button&gt; &lt;/div&gt; ); } 因此，当你需要传递事件和参数时，例如当你需要为 onClick 事件提供额外参数时，内联事件处理程序可能会为你提供帮助。然后 JSX 之外的更通用的事件处理程序可以使用这个额外的参数。 React 中的回调事件处理程序 简而言之，有回调事件处理程序或回调处理程序。当子组件需要与父组件通信时使用它们。由于 React props 只在组件树中向下传递，因此使用回调处理程序（其核心是一个函数）进行向上通信： import React from 'react'; function App() { const [text, setText] = React.useState(''); // 1 function handleTextChange(event) { setText(event.target.value); // 3 } return ( &lt;div&gt; &lt;MyInput inputValue={text} onInputChange={handleTextChange} /&gt; {text} &lt;/div&gt; ); } // 2 function MyInput({ inputValue, onInputChange }) { return ( &lt;input type=&quot;text&quot; value={inputValue} onChange={onInputChange} /&gt; ); } 回调处理程序在某处定义 (1)，在其他地方使用 (2)，但回调到其定义的位置 (3)。这样，就可以从子组件到父组件进行通信。回调处理程序通过 React props 向下传递，并在调用函数时向上通信。 你已经了解了 React 的事件处理程序、内联事件处理程序和回调事件处理程序，以及如何在按钮中为它们的 onClick 事件和在输入字段中为它们的 onChange 事件使用它们。还有其他事件处理程序，例如表单元素的 onSubmit，实际上需要该事件来阻止本机浏览器行为。无论如何，所有这些事件处理程序都有其特定目的。你的目标应该是让你的代码保持可读性和可维护性， ","link":"https://umeimmense.github.io/post/react-de-shi-jian-chu-li"},{"title":"React 中的事件冒泡和捕获","content":"前言 本文主题是React事件冒泡和捕获的 。大多数 JavaScript 开发人员可能已经熟悉这个主题，因为它起源于 JavaScript 及其 DOM API。但是，在本文中，我想为 React 中的事件冒泡和捕获整理一些信息。 React 中的事件处理程序可用于侦听特定事件（例如单击事件）。我们将从 React 中的一个函数组件开始，我们使用 React 的 useState Hook 来增加一个计数器： import * as React from 'react'; function App() { const [count, setCount] = React.useState(0); const handleClick = () =&gt; { setCount(count + 1); }; return ( &lt;button type=&quot;button&quot; onClick={handleClick}&gt; Count: {count} &lt;/button&gt; ); } export default App; 在原生 JavaScript 中，这相当于 element.addEventListener('click', handleClick);。 React 中有很多事件。下面显示了鼠标和触摸事件的事件列表： touchstart touchmove touchend mousemove mousedown mouseup click 此特定事件列表按其执行顺序显示。因此，如果在 HTML 元素中添加了 mouseup 和 click 事件侦听器，则 mouseup 事件将在 click 事件之前触发： import * as React from 'react'; function App() { const handleClick = () =&gt; { alert('click'); }; const handleMouseUp = () =&gt; { alert('mouseup'); }; return ( &lt;button type=&quot;button&quot; onClick={handleClick} onMouseUp={handleMouseUp} &gt; Which one fires first? &lt;/button&gt; ); } export default App; 在某些情况下，你可能希望在另一个事件触发时阻止其中一个事件。例如，当触摸事件发生并被处理时，你可能希望阻止所有点击事件。 无论如何，在前面的示例中，所有事件都发生在同一个 HTML 元素上。关于事件冒泡或捕获还没有什么可看的。接下来，让我们探索使用多个 HTML 元素的事件冒泡： import * as React from 'react'; function App() { const [count, setCount] = React.useState(0); const handleCount = () =&gt; { setCount((state) =&gt; state + 1); }; return ( &lt;div onClick={handleCount}&gt; &lt;button type=&quot;button&quot; onClick={handleCount}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } export default App; 在这个例子中，按钮似乎被点击了两次，因为计数器增加了 2 而不是 1。然而，发生的事情是包装容器元素也调用了它的事件处理程序。进入在 React 中事件冒泡。 React 中的事件冒泡 下面的示例显示了两个具有相同样式的 HTML 元素。为了简单起见，我们在这里使用内联样式，但是，你可以随意使用更复杂的方式来设置你的 React 应用程序的样式。 无论如何，让我们进入事件冒泡的话题。如你所见，在下一个示例中，只有外部容器元素侦听单击事件，而不是内部容器元素。但无论你是单击外部元素还是内部元素，都会触发事件处理程序： import * as React from 'react'; const style = { padding: '10px 30px', border: '1px solid black', }; function App() { const handleClick = () =&gt; { alert('click'); }; return ( &lt;div style={style} onClick={handleClick}&gt; &lt;div style={style}&gt;Click Me&lt;/div&gt; &lt;/div&gt; ); } export default App; 在 JavaScript 中，这个原理称为事件冒泡。每当在 HTML 元素（例如内部 HTML 元素）上发生事件时，它就会开始运行通过该特定元素的处理程序，然后是其父 HTML 元素（例如外部 HTML 元素，它实际上在其中找到侦听处理程序）的处理程序，然后一直向上遍历每个祖先 HTML 元素，直到它到达文档的根。 在下一个示例中尝试一下，当单击内部 HTML 元素时，两个事件处理程序都会被触发。如果单击外部 HTML 元素，则仅触发外部元素的事件处理程序： import * as React from 'react'; const style = { padding: '10px 30px', border: '1px solid black', }; function App() { const handleOuterClick = () =&gt; { alert('outer click'); }; const handleInnerClick = () =&gt; { alert('inner click'); }; return ( &lt;div style={style} onClick={handleOuterClick}&gt; &lt;div style={style} onClick={handleInnerClick}&gt; Click Me &lt;/div&gt; &lt;/div&gt; ); } export default App; 换句话说，事件从它们的起源开始冒泡整个文档。通过 React 的 useEffect Hook 在文档上添加一个事件监听器，自己验证这种行为： import * as React from 'react'; const style = { padding: '10px 30px', border: '1px solid black', }; function App() { const handleOuterClick = () =&gt; { alert('outer click'); }; const handleInnerClick = () =&gt; { alert('inner click'); }; React.useEffect(() =&gt; { const handleDocumentClick = () =&gt; { alert('document click'); }; document.addEventListener('click', handleDocumentClick); return () =&gt; { document.removeEventListener('click', handleDocumentClick); }; }, []); return ( &lt;div style={style} onClick={handleOuterClick}&gt; &lt;div style={style} onClick={handleInnerClick}&gt; Click Me &lt;/div&gt; &lt;/div&gt; ); } export default App; 因此，如果一个事件从其交互元素中冒出整个文档，那么在某些情况下如何停止冒泡呢？在 React 中输入 stopPropagation React stopPropagation stopPropagation() 方法是 DOM API 的原生方法。由于 React 将事件包装到称为合成事件的 React 版本中，因此该 API 仍然可用于 React 事件，它还可以用于停止事件的传播： import * as React from 'react'; function App() { const [count, setCount] = React.useState(0); const handleCount = (event) =&gt; { setCount((state) =&gt; state + 1); event.stopPropagation(); }; return ( &lt;div onClick={handleCount}&gt; &lt;button type=&quot;button&quot; onClick={handleCount}&gt; Count: {count} &lt;/button&gt; &lt;/div&gt; ); } export default App; 我们通过对事件使用 stopPropagation() 方法扩展了前面的示例之一。这样，当按钮被点击时，事件不会冒泡，也不会触发周围容器元素的事件处理程序。 反之，当容器元素被显式点击时（在这种情况下不太可能没有任何进一步的样式），只有容器的事件处理程序会触发。这里容器元素上的 stopPropagation() 有点多余，因为它上面没有事件处理程序。 最佳时机：默认情况下不要停止事件传播。例如，如果你将在项目中的每个按钮上使用 stopPropagation()，但稍后你想在文档级别跟踪用户点击，你将不会再收到这些事件。默认情况下使用 stopPropagation() 往往会导致错误，因此仅在必要时使用它。 当停止事件传播有意义时，让我们看看更复杂的场景。例如，可能有一个可点击的标题，可以将用户从任何页面导航到主页，但是，在标题内有一个按钮可以让用户从应用程序中注销。两个元素都应该是可点击的，不会相互干扰： import * as React from 'react'; const styleHeader = { padding: '10px', border: '1px solid black', boxSizing: 'border-box', width: '100%', display: 'flex', justifyContent: 'space-between', }; function App() { const [isActive, setActive] = React.useState(false); const handleHeaderClick = () =&gt; { alert('header click (e.g. navigate to home page)'); }; const handleButtonClick = (event) =&gt; { alert('button click (e.g. log out user)'); if (isActive) { event.stopPropagation(); } }; return ( &lt;&gt; &lt;div style={styleHeader} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt; Log Out &lt;/button&gt; &lt;/div&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; setActive(!isActive)}&gt; Stop Propagation: {isActive.toString()} &lt;/button&gt; &lt;/&gt; ); } export default App; 在不停止传播的情况下，注销按钮将触发它自己的事件处理程序，但也会触发标题上的事件处理程序，因为事件会冒泡到它上面。当 stopPropagation() 被激活时，单击注销按钮不会导致标题上的冒泡事件，因为该事件被阻止冒泡。 总之，只要有一个带有处理程序的元素嵌套在另一个带有处理程序的元素中，两者都在侦听相同的事件（这里：单击事件），使用 stopPropagation() 将有助于将事件委托给正确的处理程序（通过防止他们从冒泡）。 target &amp;&amp; currentTarget 当单击带有监听器（事件处理程序）的 HTML 元素时，你可以访问它的事件（在 React 中它是合成事件）。在其他属性中，事件可以访问表示导致事件的元素的目标属性。因此，如果按钮具有事件处理程序并且用户单击此按钮，则该事件将以按钮元素作为目标。 即使这个事件冒泡到另一个事件处理程序，如果一个嵌套元素导致了这个事件，那么目标仍然由这个嵌套元素表示。因此，在所有处理程序中，事件的目标都不会改变。 从事件处理程序到事件处理程序的变化是事件的 currentTarget，因为它表示实际事件处理程序正在运行的元素： import * as React from 'react'; const style = { display: 'block', padding: '10px 30px', border: '1px solid black', }; function App() { const handleDivClick = (event) =&gt; { alert(` &lt;div /&gt; \\n event.target: ${event.target} \\n event.currentTarget: ${event.currentTarget} `); }; const handleSpanClick = (event) =&gt; { alert(` &lt;span /&gt; \\n event.target: ${event.target} \\n event.currentTarget: ${event.currentTarget} `); }; return ( &lt;div style={style} onClick={handleDivClick}&gt; &lt;span style={style} onClick={handleSpanClick}&gt; Click Me &lt;/span&gt; &lt;/div&gt; ); } export default App; 通常你将与事件的目标进行交互，例如停止事件的传播或阻止默认行为。但是，有时你希望从正在运行的事件处理程序访问元素，因此你可以改用 currentTarget。 React 中的事件捕获 当谈到 JavaScript 中的事件冒泡时，不得不提的是存在事件捕获的概念。实际上两者都是依次发生的：当用户与元素交互时，DOM API 会向下遍历文档（捕获阶段）到目标元素（目标阶段），然后 DOM API 才会再次向上遍历（冒泡阶段）。 在某些情况下，你可能希望在捕获阶段中的事件到达冒泡阶段之前对其进行拦截。然后，你可以使用 onClickCapture 而不是 onClick 来处理 JSX 中的单击事件，或者使用 addEventListener() 方法的第三个参数来激活在捕获阶段而不是冒泡阶段的监听： function App() { const handleOuterClick = () =&gt; { alert('outer click'); }; const handleInnerClick = () =&gt; { alert('inner click'); }; React.useEffect(() =&gt; { const handleDocumentClick = () =&gt; { alert('document click'); }; document.addEventListener( 'click', handleDocumentClick, true ); return () =&gt; { document.removeEventListener( 'click', handleDocumentClick, true ); }; }, []); return ( &lt;div style={style} onClickCapture={handleOuterClick}&gt; &lt;div style={style} onClickCapture={handleInnerClick}&gt; Click Me &lt;/div&gt; &lt;/div&gt; ); } 谈到“某些情况”有点含糊。因此，让我们回到前面的示例，其中我们将注销按钮嵌套在标题元素中。如果单击该按钮以不触发标头的事件处理程序，则该按钮将停止事件的传播。现在，如果你想通过在顶级文档级别引入分析跟踪来扩展此示例，你可以验证自己对于单击按钮，你不会收到分析跟踪，而只会收到标题，因为按钮阻止了从冒泡到文档的事件： function App() { const handleHeaderClick = () =&gt; { alert('header click (e.g. navigate to home page)'); }; const handleButtonClick = (event) =&gt; { alert('button click (e.g. log out user)'); // important: stops event from appearing // in the document's event handler event.stopPropagation(); }; React.useEffect(() =&gt; { const handleDocumentClick = (event) =&gt; { alert(` document clicked - \\n run analytics for clicked element: ${event.target} `); }; document.addEventListener('click', handleDocumentClick); return () =&gt; { document.removeEventListener('click', handleDocumentClick); }; }, []); return ( &lt;&gt; &lt;div style={styleHeader} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt; Log Out &lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); } 凭借我们对捕获阶段的了解，我们可以在实际用户交互冒泡之前对事件进行分析跟踪。在这种情况下，我们通过将第三个参数设置为 true（使用捕获阶段而不是冒泡阶段）在文档上添加事件侦听器： function App() { const handleHeaderClick = () =&gt; { alert('header click (e.g. navigate to home page)'); }; const handleButtonClick = (event) =&gt; { alert('button click (e.g. log out user)'); // important: stops event from appearing // in the document's event handler event.stopPropagation(); }; React.useEffect(() =&gt; { const handleDocumentClick = (event) =&gt; { alert(` document clicked - \\n run analytics for clicked element: ${event.target} `); }; document.addEventListener( 'click', handleDocumentClick, true ); return () =&gt; { document.removeEventListener( 'click', handleDocumentClick, true ); }; }, []); return ( &lt;&gt; &lt;div style={styleHeader} onClick={handleHeaderClick}&gt; &lt;div&gt;Header&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={handleButtonClick}&gt; Log Out &lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); } 当点击注销按钮时，捕获阶段从上到下遍历所有处理程序，从而触发文档级别的处理程序进行分析跟踪。然后它向下遍历元素到目标（此处：按钮），因为没有其他事件处理程序正在侦听捕获阶段（例如，通过使用 onClickCapture 代替）。从那里，事件冒泡并触发按钮的事件处理程序，阻止事件传播到标题的事件处理程序。 在日常工作中，大多数开发人员使用冒泡阶段通过使用事件处理程序来拦截事件，并使用 stopPropagation() 方法阻止事件传播。因此，在开发人员的脑海中，总是有事件模型在 HTML 树中冒泡。然而，正如某些边缘情况所示，了解捕获阶段也是有意义的。 理解 JavaScript 中的事件冒泡对于在 React 中使用它至关重要。每当你有一个复杂的页面，其中带有事件处理程序的伪按钮被包装到其他伪按钮中时，就无法绕过本机 stopPropagation 方法。但是，请谨慎使用它，而不是默认使用它，否则从长远来看，你可能会遇到错误。 ","link":"https://umeimmense.github.io/post/react-shi-jian-mou-pao-he-bu-huo"},{"title":"React 中的浅比较是如何工作的？","content":"前言 浅比较在 React 开发中无处不在。它在不同的流程中起着关键作用，也可以在 React 组件生命周期的多个地方找到。类组件是否应该更新的机制，React hooks 的依赖数组，通过 React.memo 进行记忆等等。 如果你曾经阅读过 React 的官方文档，你很可能已经经常看到浅比较这个术语。因此，本文将研究浅比较的概念，它到底是什么，它是如何工作的。 什么是浅比较？ 理解浅层比较最直接的方法是深入研究它的实现。相应的代码可以在共享子包的 React Github 项目中找到。例如下面的实现： import is from './objectIs'; import hasOwnProperty from './hasOwnProperty'; /** * Performs equality by iterating through keys on an object and returning false * when any key has values which are not strictly equal between the arguments. * Returns true when the values of all keys are strictly equal. */ function shallowEqual(objA: mixed, objB: mixed): boolean { if (is(objA, objB)) { return true; } if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) { return false; } const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) { return false; } // Test for A's keys different from B. for (let i = 0; i &lt; keysA.length; i++) { const currentKey = keysA[i]; if ( !hasOwnProperty.call(objB, currentKey) || !is(objA[currentKey], objB[currentKey]) ) { return false; } } return true; } 这过程中发生了很多事情，所以让我们将其拆分并逐步执行该功能。 function shallowEqual(objA: mixed, objB: mixed): boolean { // ... } 从函数定义开始，函数接受两个将相互比较的实体。与 TypeScript 不同，此代码使用 Flow 作为类型检查系统。两个函数参数都是使用特殊的混合 Flow 类型键入的，类似于 TypeScript 的未知数。它表明参数可以是任何类型的值，该函数将找出其余的并使其工作。 import is from './objectIs'; function shallowEqual(objA: mixed, objB: mixed): boolean { if (is(objA, objB)) { return true; } // ... } 其次，首先使用来自 React 内部对象的 is 函数将函数参数相互比较。导入的函数只不过是 JavaScript 的 Object.is 函数的 polyfill 版本。这个比较函数基本上等同于常见的 === 运算符，但有两个例外： Object.is 认为相反的有符号零（+0 和 -0）不相等，而 === 认为它们相等。 Object.is 认为 Number.NaN 和 NaN 相等，而 === 认为它们不相等。 基本上，第一个条件语句处理所有简单的情况：如果两个函数参数具有相同的值，对于原始类型，或引用相同的对象，对于数组和对象，那么它们被认为是浅比较相等的。 function shallowEqual(objA: mixed, objB: mixed): boolean { // ... if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) { return false; } // ... } 在处理了两个函数参数值相等或引用同一个对象的所有简单情况之后，我们想要进入更复杂的结构（对象和数组）。但是，如果任何一个参数是原始值，前面的条件语句仍然可以给我们留下原始值。 因此，为了确保我们从现在开始处理两个复杂的结构，代码会检查任一参数是否不是对象类型或等于 null。前一个检查确保我们正在处理对象或数组，而后一个检查是过滤掉空值，因为它们的类型也是对象。如果任一条件成立，我们肯定是在处理不相等的参数（否则前面的条件语句会将它们过滤掉），因此浅比较返回 false。 function shallowEqual(objA: mixed, objB: mixed): boolean { // ... const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) { return false; } // ... } 现在可以确定我们只处理数组和对象，我们可以专注于浅比较这些数据结构。为此，我们必须深入研究复杂数据结构的值，并在两个函数参数之间进行比较。 但在我们这样做之前，我们可以通过一个简单的检查来确保两个参数具有相同数量的值。如果不是，则通过浅层比较可以保证它们不相等，这可以节省我们一些精力。为此，我们使用参数的键。对于对象，键数组将由实际键组成，而对于数组，键数组将由字符串中原始数组中占用的索引组成。 import hasOwnProperty from './hasOwnProperty'; function shallowEqual(objA: mixed, objB: mixed): boolean { // ... // Test for A's keys different from B. for (let i = 0; i &lt; keysA.length; i++) { const currentKey = keysA[i]; if ( !hasOwnProperty.call(objB, currentKey) || !is(objA[currentKey], objB[currentKey]) ) { return false; } } return true; } 作为最后一步，我们按键迭代两个函数参数的值，并逐个验证它们以确定它们是否等效。为此，代码使用在上一步中生成的键数组，使用 hasOwnProperty 检查键是否实际上是参数的属性，并使用与比较值之前相同的 Object.is 函数。 如果事实证明任何键在两个参数之间没有等效值，那么通过浅比较可以肯定它们不相等。因此，我们缩短了 for 循环，并从 shallowEqual 函数中返回 false。如果所有值都相等，那么我们可以通过浅比较调用函数参数相等并从函数返回 true。 一些有趣的点 现在我们了解了浅层比较及其背后的实现，我们可以从这些知识中学到一些有趣的东西： 浅比较不使用严格相等、=== 运算符，而是使用 Object.is 函数。 通过浅比较，空对象和数组是等价的。 通过浅比较，以索引为键的对象等效于在各个索引处具有相同值的数组。例如。 { 0: 2, 1: 3 } 等价于 [2, 3]。 由于 Object.is 优于 === 的使用，通过浅比较，+0 和 -0 不等价，NaN 和 Number.NaN 也不等价。- 如果它们在复杂结构内进行比较，这也适用。 虽然两个内联创建的对象（或数组）通过浅比较相等（{} 和 [] 浅相等），但具有嵌套内联对象的内联对象不相等（{ someKey: {} } 和 { someKey: [] } 不浅平等的）。 ","link":"https://umeimmense.github.io/post/react-zhong-de-qian-bi-jiao-shi-ru-he-gong-zuo-de"},{"title":"React Suspense 基本指南","content":"前言 在 React 18 中发布的另一个重要特性是 Suspense。如果你在之前使用过 React ，那么你就会知道 Suspense 功能并不是特别新。早在 2018 年，Suspense 作为 React 16.6 版的一部分作为实验性功能发布。然后，它主要针对与React.lazy。 但是现在，有了 React 18，Suspense 的正式发布就在我们面前。伴随着并发渲染的发布，Suspense 的真正威力终于解锁了。Suspense 和并发渲染之间的交互为改善用户体验开辟了广阔的世界。 但就像所有功能一样，就像并发渲染一样，从基础开始很重要。Suspense 到底是什么？为什么我们首先需要Suspense ？Suspense 如何解决这个问题？有什么好处？为了帮助你理解这些基础知识，本文将详细介绍这些问题，并为你提供有关 Suspense 的知识基础。 什么是Suspense？ 本质上，Suspense 是 React 开发人员向 React 指示组件正在等待数据准备好的一种机制。然后 React 知道它应该等待该数据被获取。同时，将向用户显示一个反馈，并且 React 将继续渲染应用程序的其余部分。数据准备好后，React 会返回到那个特定的 UI 并相应地更新它。 从根本上说，这听起来与 React 开发人员必须实现数据获取流程的当前方式没有太大区别：使用某种状态来指示组件是否仍在等待数据，useEffect开始获取数据，显示加载状态基于数据的状态，并在数据准备好后更新 UI。 但在实践中，Suspense 使这在技术上完全不同。与上面提到的数据获取流程相反，Suspense 与 React 深度集成，允许开发人员更直观地编排加载状态，并避免竞争条件。为了更好地理解这些细节，了解我们为什么需要 Suspense 很重要。 为什么我们需要Suspense？ 在没有 Suspense 的情况下，实现数据获取流程的主要方法有两种：渲染时获取和渲染后获取。但是，这些传统的数据获取流程存在一些问题。要了解 Suspense，我们必须深入研究这些流程的问题和局限性。 渲染时获取 useEffect大多数人将使用和状态变量来实现前面提到的数据获取流程。这意味着只有在组件呈现时才开始获取数据。所有数据获取都发生在组件的副作用和生命周期方法中。 这种方法的主要问题是:组件仅在渲染时触发数据获取，异步特性迫使组件必须等待其他组件的数据请求。 假设我们有一个ComponentA获取一些数据并具有加载状态的组件。在内部，ComponentA还呈现另一个组件ComponentB，该组件也自己执行一些数据获取。但是由于数据获取的实现方式，ComponentB只有在渲染时才开始获取数据。这意味着它必须等到ComponentA完成获取数据然后渲染ComponentB。 这导致了瀑布式方法，其中组件之间的数据获取顺序发生，这实质上意味着它们相互阻塞。 function ComponentA() { const [data, setData] = useState(null); useEffect(() =&gt; { fetchAwesomeData().then(data =&gt; setData(data)); }, []); if (user === null) { return &lt;p&gt;Loading data...&lt;/p&gt;; } return ( &lt;&gt; &lt;h1&gt;{data.title}&lt;/h1&gt; &lt;ComponentB /&gt; &lt;/&gt; ); } function ComponentB() { const [data, setData] = useState(null); useEffect(() =&gt; { fetchGreatData().then(data =&gt; setData(data)); }, []); return data === null ? &lt;h2&gt;Loading data...&lt;/h2&gt; : &lt;SomeComponent data={data} /&gt;; } 渲染后获取 为了防止组件之间数据获取的顺序阻塞，一种替代方法是尽早开始所有数据获取。因此，与其让组件负责处理渲染时的数据获取，而且数据请求都单独发生，而是在树开始渲染之前启动所有请求。 这种方法的优点是所有数据请求都是一起发起的，因此ComponentB不必等待ComponentA完成。这解决了组件顺序阻塞彼此数据流的问题。但是，它引入了另一个问题，我们必须等待所有数据请求完成，然后才能为用户呈现任何内容。可以想象，这不是最佳体验。 // Start fetching before rendering the entire tree function fetchAllData() { return Promise.all([ fetchAwesomeData(), fetchGreatData() ]).then(([awesomeData, greatData]) =&gt; ({ awesomeData, greatData })) } const promise = fetchAllData(); function ComponentA() { const [awesomeData, setAwesomeData] = useState(null); const [greatData, setGreatData] = useState(null); useEffect(() =&gt; { promise.then(({ awesomeData, greatData }) =&gt; { setAwesomeData(awesomeData); setGreatData(greatData); }); }, []); if (user === null) { return &lt;p&gt;Loading data...&lt;/p&gt;; } return ( &lt;&gt; &lt;h1&gt;{data.title}&lt;/h1&gt; &lt;ComponentB /&gt; &lt;/&gt; ); } function ComponentB({data}) { return data === null ? &lt;h2&gt;Loading data...&lt;/h2&gt; : &lt;SomeComponent data={data} /&gt;; } Suspense 如何解决数据获取问题？ 从本质上讲，**fetch-on-render **和 fetch-then-render 的主要问题归结为我们试图强制同步两个不同的流程，即数据获取流程和 React 生命周期。借助 Suspense，我们获得了一种不同类型的数据获取方法，即所谓的 render-as-you-fetch 方法。 const specialSuspenseResource = fetchAllDataSuspense(); function App() { return ( &lt;Suspense fallback={&lt;h1&gt;Loading data...&lt;/h1&gt;}&gt; &lt;ComponentA /&gt; &lt;Suspense fallback={&lt;h2&gt;Loading data...&lt;/h2&gt;}&gt; &lt;ComponentB /&gt; &lt;/Suspense&gt; &lt;/Suspense&gt; ); } function ComponentA() { const data = specialSuspenseResource.awesomeData.read(); return &lt;h1&gt;{data.title}&lt;/h1&gt;; } function ComponentB() { const data = specialSuspenseResource.greatData.read(); return &lt;SomeComponent data={data} /&gt;; } 与之前实现的不同之处在于它允许组件在 React 到达它的那一刻启动数据获取。这甚至发生在组件渲染之前，并且 React 并没有就此停止。然后它继续评估组件的子树，并在等待数据获取完成时继续尝试渲染它。 这意味着 Suspense 不会阻塞渲染，这意味着子组件不必等待父组件完成后再发起其数据获取请求。React 尝试尽可能多地渲染，同时启动适当的数据获取请求。请求完成后，React 将重新访问相应的组件并使用新接收的数据相应地更新 UI。 Suspense有什么好处？ 尽早开始获取数据。Suspense 引入的 render-as-you-fetch 方法最大和最直接的好处是数据获取尽早启动。这意味着用户必须等待的时间更少，应用程序更快，这对任何前端应用程序都是普遍有益的。 更直观的加载状态。使用 Suspense，组件不必再包含大量的 if 语句或单独跟踪状态来实现加载状态。相反，加载状态被集成到它所属的组件本身中。这使得组件更直观，通过保持加载代码接近相关代码，并且更可重用，因为加载状态包含在组件中。 避免竞争条件。我没有在本文中深入讨论的现有数据获取实现的问题之一是竞争条件。在某些情况下，传统的 fetch-on-render 和 fetch-then-render 实现可能会导致竞争条件，具体取决于时间、用户输入和参数化数据请求等不同因素。主要的潜在问题是我们试图强制同步两个不同的进程，React 和数据获取。但是使用 Suspense，这可以更优雅、更集成地完成，从而避免了上述问题。 更集成的错误处理。使用 Suspense，我们基本上已经为数据请求流创建了边界。最重要的是，由于 Suspense 使其与组件代码的集成更加直观，它允许 React 开发人员还为 React 代码和数据请求实现更集成的错误处理。 总结 React Suspense 已经被关注了 3 年多。但是随着 React 18 的发布，官方发布的时间越来越近了。除了并发渲染，它将是作为 React 版本的一部分发布的最大功能之一。就其本身而言，它可以将数据获取和加载状态实现提升到一个新的直观和优雅水平。 为了帮助你了解 Suspense 的基础知识，本文介绍了几个对其很重要的问题和方面。这涉及到 Suspense 是什么，为什么我们首先需要像 Suspense 这样的东西，它如何解决某些数据获取问题以及 Suspense 带来的所有好处。 ","link":"https://umeimmense.github.io/post/react-suspense-ji-ben-zhi-nan"},{"title":"React 18 中的自动批处理","content":"前言 React 18 支持对状态更新的自动批处理支持。 这有助于避免在 Promise、setTimeout、setInterval、原生事件处理程序以及react事件处理程序中多次渲染状态更新。 因此，由于自动批处理，我们在React 应用程序中获得了开箱即用的性能改进。 什么是（自动）批处理？ 批处理是将多个状态更新分组为单个更新的过程。 如果我们有多个调用来设置组件的状态，React 会将这些更新组合在一个更新调用（称为批处理）中，从而导致组件的一次重新渲染。 当 React 自动计算出这一点并批量更新状态时，它被称为自动批处理，下面让我们通过探究更新状态的各种方式来看看它是如何工作的？ React 17 及之前的事件处理程序的状态更新 让我们举个例子来了解在 React 17 中事件处理程序上的状态更新时渲染是如何发生的？ const Counter = () =&gt; { const [count, setCount] = useState(0); const [showModal, setShowModal] = useState(false); const handleClick = () =&gt; { setCount(count + 1); setShowModal((prev) =&gt; !prev); // React renders once at the end (that's batching) }; console.log('rendered component'); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;p&gt;{`Show modal? ${showModal}`}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt; ); } 现在，我们可以看到有两个状态更新调用。 一个用于 setCount，另一个用于 setShowModal。 但是，react 确保最后只调用一个渲染。 如果更新不是批处理的，它会以不成熟方式渲染组件，导致 UI 闪烁。 即我们希望我们的组件仅在更新计数和更新 showModal 标志后才呈现。 React 17 及之前的 Promise 和原生事件处理程序的状态更新 自动批处理不适用于promise/非react处理程序（如 setTimeout、setInterval 等）中的状态更新。 const Counter = () =&gt; { const [count, setCount] = useState(0); const [showModal, setShowModal] = useState(false); const handleClick = () =&gt; { console.log('fetch called'); fetch('https://jsonplaceholder.typicode.com/todos/1') .then(() =&gt; { setCount(count + 1); // Re-render is called setShowModal((prev) =&gt; !prev); // Re-render is called }) }; console.log('rendered component'); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;p&gt;{`Show modal? ${showModal}`}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click me now&lt;/button&gt; &lt;/div&gt; ); } 通常，我们调用 API 请求来获取某些内容并根据 API 请求的响应在回调中执行状态更新。 正如我们在上面的示例中看到的，有 2 次调用来设置回调中的状态，导致 2 次重新渲染。 这是一个性能瓶颈。 这可能会导致 UI 闪烁，从而呈现部分状态更新的结果。 React 18+ 中 Promise 和原生事件处理程序的状态更新 React 通过为 Promise、setTimeout 和 setInterval、原生事件处理程序以及默认的 react 事件处理程序中的状态更新提供自动批处理支持来解决此问题。 注意：对于这个例子，我们已经更新了如下所示的 react 和 react-dom 库版本。 https://unpkg.com/react@18.0.0-beta-24dd07bd2-20211208/umd/react.development.js https://unpkg.com/react-dom@18.0.0-beta-24dd07bd2-20211208/umd/react-dom.development.js 如果我们采用与上面给出的相同示例，我们可以在下面看到渲染的数量。 const Counter = () =&gt; { const [count, setCount] = useState(0); const [showModal, setShowModal] = useState(false); const handleClick = () =&gt; { console.log('fetch called'); fetch('https://jsonplaceholder.typicode.com/todos/1') .then(() =&gt; { setCount(count + 1); setShowModal((prev) =&gt; !prev); // React 18 renders once at the end (that's automatic batching) }) }; console.log('rendered component'); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;p&gt;{`Show modal? ${showModal}`}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt; ); } 注意：我们需要将渲染升级为createRoot。 对于上面给出的示例，我们渲染了 Counter 组件，如下所示。 我们使用 ReactDOM.createRoot 创建了根，然后在其上渲染了 Counter 组件。 ","link":"https://umeimmense.github.io/post/react-18-zhong-de-zi-dong-pi-chu-li"},{"title":"探索 React 18 的三个新 API","content":"前言 目前 React 生态系统中最大的话题是 React 18 及其备受期待的并发渲染功能的完整发布。 2021 年 6 月，React 团队宣布了 React 18 的计划以及即将发生的事情。 2021年 12 月，React Conf 2021 的主题是所有新发布的并发渲染功能。 与 React 18 一起发布的几个新 API 允许用户充分利用 React 的并发渲染功能。 这些hook是： useSyncExternalStore useId useInsertionEffect 本文将介绍这三个新 API、它们的用例、它们解决的问题、添加它们的原因以及它们如何集成到并发渲染领域。 the-usesyncexternalstore-hook 在 React v16.14.0 中引入的用于适应并发渲染的 API 之一是 useMutableSource，它旨在允许 React 组件在并发渲染期间安全有效地与外部可变源集成。 Hook 将附加到数据源，等待更改，并相应地安排更新。 所有这一切都会以一种防止撕裂的方式发生，即当出现视觉不一致时，因为同一状态有多个值。 这对于新的并发渲染特性来说是一个特别突出的问题，因为状态流可以很快地交织在一起。 然而，采用 useMutableSource 被证明是困难的，原因如下： Hook 是异步的 Hook 不知道如果选择器函数的结果值发生变化，它是否可以重用它。 唯一的解决方案是重新订阅提供的数据源并再次检索快照，这可能会导致性能问题，因为它发生在每次渲染上。 对于用户和库（如 Redux），这意味着他们必须记住项目中的每个选择器，并且无法内联定义选择器函数，因为它们的引用不稳定。 它必须处理外部状态 最初的实现也有缺陷，因为它必须处理 React 之外的状态。 这意味着由于其可变性，状态可能随时更改。 因为 React 试图以异步方式解决这个问题，这有时会导致 UI 的可见部分被替换为备用，从而导致次优的用户体验。 所有这一切都使得库维护者的迁移变得痛苦，并且对开发人员和用户来说都是次优的体验。 使用 useSyncExternalStore 解决这些问题 为了解决这些问题，React 团队更改了底层实现并将 Hook 重命名为 useSyncExternalStore 以正确反映其行为。 这些变化包括： 每次选择器（用于快照）更改时都不会重新订阅外部源——相反，React 将比较选择器的结果值，而不是选择器函数，以决定是否再次检索快照，以便用户可以定义 选择器内联而不会对性能产生负面影响 每当外部存储发生更改时，生成的更新现在始终是同步的，这可以防止 UI 被替换为回退 唯一的要求是 getSnapshot Hook 参数的结果值需要是引用稳定的。 React 在内部使用它来确定是否需要检索新快照，因此它需要是不可变值或记忆/缓存对象。 为了方便起见，React 将提供一个附加版本的 Hook，它自动支持对 getSnapshot 的结果值的记忆。 如何使用 useSyncExternalStore // Code illustrating the usage of `useSyncExternalStore`. // Source: &lt;https://github.com/reactwg/react-18/discussions/86&gt; import {useSyncExternalStore} from 'react'; // React will also publish a backwards-compatible shim // It will prefer the native API, when available import {useSyncExternalStore} from 'use-sync-external-store/shim'; // Basic usage. getSnapshot must return a cached/memoized result const state = useSyncExternalStore(store.subscribe, store.getSnapshot); // Selecting a specific field using an inline getSnapshot const selectedField = useSyncExternalStore(store.subscribe, () =&gt; store.getSnapshot().selectedField); // Code illustrating the usage of the memoized version. // Source: &lt;https://github.com/reactwg/react-18/discussions/86&gt; // Name of API is not final import {useSyncExternalStoreWithSelector} from 'use-sync-external-store/with-selector'; const selection = useSyncExternalStoreWithSelector( store.subscribe, store.getSnapshot, getServerSnapshot, selector, isEqual ); The useId Hook 在服务器端运行 React 长期以来，一个 React 项目只在客户端运行。简而言之，这意味着所有代码都被发送到用户的浏览器（客户端），然后浏览器负责向用户呈现和显示应用程序。 React 作为一个整体一直在向服务器端渲染（SSR）领域扩展。在 SSR 中，服务器负责根据 React 代码生成 HTML 结构。而不是所有的 React 代码，只有 HTML 被发送到浏览器。 然后，浏览器只负责采用该结构并通过渲染组件、在其上添加 CSS 并将 JavaScript 附加到它来使其具有交互性。这个过程称为水合作用。 hydration 最重要的要求是服务器和客户端生成的 HTML 结构必须匹配。如果他们不这样做，浏览器就无法确定它应该对结构的特定部分做什么，这会导致不正确地呈现或非交互式 UI。 这在依赖于标识符的特性中尤为突出，因为它们必须在两边都匹配，例如在生成唯一样式类名称和可访问性标识符时。 useID Hook 的演进 为了解决这个问题，React 最初引入了 useOpaqueIdentifier Hook，但不幸的是，它也存在一些问题： 在不同的环境中，Hooks 会产生不同的输出（不透明）： 服务器端：它会产生一个字符串 客户端：它会产生一个特殊的对象，必须直接传递给 DOM 属性 这意味着 Hook 只能生成一个标识符，并且不可能动态生成新的 ID，因为它必须遵守 Hook 的规则。 因此，如果您的组件需要 X 个不同的标识符，它必须在不同的时间调用 Hook X，这在实践中显然不能很好地扩展。 // Code illustrating the way `useOpaqueIdentifier` handles the need for N identifiers in a single component, namely calling the hook N times. // Source: &lt;https://github.com/facebook/react/pull/17322#issuecomment-613104823&gt; function App() { const tabIdOne = React.unstable_useOpaqueIdentifier(); const panelIdOne = React.unstable_useOpaqueIdentifier(); const tabIdTwo = React.unstable_useOpaqueIdentifier(); const panelIdTwo = React.unstable_useOpaqueIdentifier(); return ( &lt;React.Fragment&gt; &lt;Tabs defaultValue=&quot;one&quot;&gt; &lt;div role=&quot;tablist&quot;&gt; &lt;Tab id={tabIdOne} panelId={panelIdOne} value=&quot;one&quot;&gt; One &lt;/Tab&gt; &lt;Tab id={tabIdTwo} panelId={panelIdTwo} value=&quot;one&quot;&gt; One &lt;/Tab&gt; &lt;/div&gt; &lt;TabPanel id={panelIdOne} tabId={tabIdOne} value=&quot;one&quot;&gt; Content One &lt;/TabPanel&gt; &lt;TabPanel id={panelIdTwo} tabId={tabIdTwo} value=&quot;two&quot;&gt; Content Two &lt;/TabPanel&gt; &lt;/Tabs&gt; &lt;/React.Fragment&gt; ); } 某些可访问性 API（如 aria-labelledby）可以通过空格分隔的列表接受多个标识符，但由于 Hook 的输出被格式化为不透明的数据类型，它总是必须直接附加到 DOM 属性。这意味着无法正确使用上述可访问性 API。 为了解决这个问题，实现已更改并重命名为 useId。这个新的 Hook API 在 SSR 和 hydration 期间生成稳定的标识符以避免不匹配。在服务器渲染的内容之外，它回退到一个全局计数器。 与使用 useOpaqueIdentifier 创建不透明数据类型（服务器中的特殊对象和客户端中的字符串）不同，useId Hook 会在两侧生成非透明字符串。 这意味着如果我们需要 X 个不同的 ID，就没有必要再调用 Hook X 次了。相反，组件可以调用 useId 一次并将其用作整个组件所需的标识符的基础（例如，使用后缀），因为它只是一个字符串。这解决了 useOpaqueIdentifier 中存在的两个问题。 如何使用 useID 下面的代码示例说明了如何根据我们上面讨论的内容使用 useId。 因为 React 生成的 ID 是全局唯一的，并且后缀是本地唯一的，所以动态创建的 ID 也是全局唯一的——因此不会导致任何水合不匹配。 // Code illustrating the improved way in which `useId` handles the need for N identifiers in a single component, namely calling the hook once and creating them dynamically. // Source: &lt;https://github.com/reactwg/react-18/discussions/111&gt; function NameFields() { const id = useId(); return ( &lt;div&gt; &lt;label htmlFor={id + '-firstName'}&gt;First Name&lt;/label&gt; &lt;div&gt; &lt;input id={id + '-firstName'} type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;label htmlFor={id + '-lastName'}&gt;Last Name&lt;/label&gt; &lt;div&gt; &lt;input id={id + '-lastName'} type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;/div&gt; ); } The useInsertionEffect Hook . CSS-in-JS 库的问题 最后一个将在 React 18 中添加的 Hook——我们将在这里讨论——是 useInsertionEffect。这个与其他的略有不同，因为它的唯一目的对于动态生成新规则并在文档中插入带有 &lt;style&gt; 标记的 CSS-in-JS 库很重要。 在某些场景下，&lt;style&gt;标签需要在客户端生成或编辑，如果不仔细处理，可能会导致并发渲染的性能问题。这是因为在添加或删除 CSS 规则时，浏览器必须检查这些规则是否适用于现有树。它必须重新计算所有样式规则并重新应用它们——而不仅仅是改变的规则。如果 React 发现另一个组件也生成了新规则，那么同样的过程将再次发生。 这实际上意味着在 React 渲染时，必须针对每一帧的所有 DOM 节点重新计算 CSS 规则。虽然你很有可能不会遇到这个问题，但它的规模并不大。 从理论上讲，有一些方法主要与时间有关。这个时间问题的最佳解决方案是在对 DOM 进行所有其他更改的同时生成这些标签，就像 React 库那样。最重要的是，它应该发生在任何尝试访问布局之前以及所有内容呈现给浏览器进行绘制之前。 这听起来像是 useLayoutEffect 可以解决的问题，但问题是同一个 Hook 将用于读取布局和插入样式规则。这可能会导致不希望的行为，例如在一次通过中多次计算布局或读取不正确的布局。 useInsertionEffect 如何解决并发渲染问题 为了解决这个问题，React 团队引入了 useInsertionEffect Hook。 它与 useLayoutEffect Hook 非常相似，但它无法访问 DOM 节点的 refs。 这意味着只能插入样式规则。 它的主要用例是插入全局 DOM 节点，如 &lt;style&gt; 或 SVGs &lt;defs&gt;。 由于这仅与在客户端生成标签有关，因此 Hook 不会在服务器上运行。 // Code illustrating the way `useInsertionEffect` is used. // Source: &lt;https://github.com/reactwg/react-18/discussions/110&gt; function useCSS(rule) { useInsertionEffect(() =&gt; { if (!isInserted.has(rule)) { isInserted.add(rule); document.head.appendChild(getStyleForRule(rule)); } }); return rule; } function Component() { let className = useCSS(rule); return &lt;div className={className} /&gt;; } React 18 最令人期待的特性是它的并发渲染特性。 随着团队的宣布，我们收到了新的 API，允许用户根据他们的用例采用并发渲染功能。 虽然有些是全新的，但有些是基于社区反馈的先前 API 的改进版本。 在本文中，我们介绍了三个最新的 API，即 useSyncExternalStore、useId 和 useInsertionEffect Hooks。 我们查看了它们的用例、它们解决的问题、与以前的版本相比为什么需要进行某些更改，以及它们用于并发渲染的目的。 React 18 充满了新功能，绝对值得期待！ ","link":"https://umeimmense.github.io/post/tan-suo-react-18-de-san-ge-xin-api"},{"title":"React 18 并发（Concurrent）渲染的入门指南","content":"前言 目前 React 领域最热门的话题是 React 18 版本。 特别是，该版本将引入一组所谓的并发渲染功能。 这些特性允许开发者选择 React 的并发渲染机制。 这种机制为 React 开发人员提供了一个全新的机会来控制和优化最终用户的体验。 这绝对是自 hooks 以来，我们在 React 世界中将收到的最令人兴奋的事情之一。 因此，你很可能以前听说过并发渲染。 可能是关于它的文章、围绕它的 API，或者 React 18 将为它带来什么。 但是，你可能会对并发渲染的基础知识感到疑惑。 究竟什么是并发渲染，为什么我们真的需要它？ 为了帮助你理解，本文将讨论这些问题。 通过研究它的目的、它试图解决什么问题以及它是如何解决它的，你将获得有关并发渲染主题的基础知识。 为什么我们需要并发渲染？ React 当前形式的问题之一是所有状态更新都是同步的。 这意味着 React 只能一一处理它们。 在许多用例和现实生活场景中，这非常好，不会对用户体验施加任何限制。 但是在 React 想要获取与其当前正在处理的状态更新不同的状态更新的情况下，现在这显然是不可能的。 React 在启动后无法中断、暂停或放弃渲染更新——这是一个阻塞的进程。 从本质上讲，这对优化用户体验的过程设置了上限。 虽然很高，但还是有上限的。 每个状态更新都被视为同等重要，即使这不适用于用户体验。 某些更新可能比其他更新具有更高的优先级或紧迫性。 与可能的情况相比，不能这样做实际上会对用户体验产生巨大的负面影响，这是次优的。 什么是并发渲染？ 并发渲染是一组功能，允许你的 React 项目选择所谓的可中断渲染。 与之前 React 被阻塞的渲染过程相反，这使得渲染过程可以从 React 端中断，这正是并发渲染的用武之地。这为 React 开发人员进一步提升 React 应用程序的用户体验开辟了许多新的可能性。 它允许 React 一次处理多个状态更新。 然而，这并不意味着 React 会突然同时执行所有排队状态更新。 相反，选择并发渲染允许 React 考虑其最佳行动方案。 幸运的是，这也是我们作为开发人员可以控制的事情。 假设 React 当前正在处理状态更新并且有一个不同的更新进来，那么 React 可以根据变量的因素做出不同的决定。 如果新的传入状态更新被标记为同等或不那么紧急，那么与之前的渲染过程相比没有任何变化。 React 将像往常一样继续当前状态更新。 完成后，它将获取新的状态更新。 但是如果新传入的状态更新被标记为更紧急，那么 React 可以决定暂停当前状态更新并首先处理传入的更新。 在完成新的更紧急的状态更新后，React 会回到原来的状态更新。 如果它确定有必要恢复它，它会这样做。 如果事实证明状态更新现在无关紧要，它可以决定完全放弃它。 下一步是什么？ 本文简要介绍了 React 18 将为 React 开发领域带来的最激动人心的功能之一，即并发渲染，并让你快速了解整个主题。 使用本文中的知识，你应该知道什么是并发渲染，了解它试图解决的问题，并大致了解它的工作原理。 幸运的是，并发渲染并不止于此。 虽然并发渲染还有很多方面需要理解或深入研究，但本文作为介绍以进入整个主题，并允许你从这里开始进一步探索 React 18。 下面准备了一些资料 这里介绍了 React 18 中引入的三个新 API。所有这些 API 都是允许某些开发人员在某些场景中选择并发渲染的hook。 官方的 React 18 公告是了解更多关于 React 18、不同特性、如何采用它以及关于即将发布的 React 版本的所有信息的好地方。 React 工作组是了解更多技术方面、获得更多指导、了解不同 API 和特性背后的思维过程以及总体上更深入地了解 React 18 中所有内容的好地方。 这就是全部！ 现在你已经牢牢掌握了并发渲染的主题，在 React 18 中为你打开了一个全新的世界供你探索。走出去，探索并享受这个新的冒险！ ","link":"https://umeimmense.github.io/post/concurrent-rendering"},{"title":"React Router 6：搜索参数","content":"前言 本文我们讨论如何在 React Router 6 中使用搜索参数。搜索参数是一项强大的功能，它使你能够捕获 URL 中的状态。通过在 URL 中包含状态，你可以与其他人实现共享。例如，如果应用程序显示产品目录，开发人员将使用户能够搜索它。在 React 中，这将转换为项目列表（此处为：产品）和用于过滤它们的 HTML 输入字段。 现在，React 开发人员很有可能会使用 React 的 useState Hook 来管理这种搜索状态。这对这个用户来说很好，但不适合与其他用户共享。 因此，一个不错的方式是在 URL 中管理搜索状态，因为这样搜索状态就可以与其他用户共享。如果一个用户按标题（例如“Rust”）搜索项目列表，则搜索参数将作为键值对附加到 URL，例如 /bookshelf?title=Rust，因为可以与另一个用户共享。所以获得链接的其他用户将在其页面上看到相同的过滤项目列表。 React Router 从状态到 URL 首先，我们将实现上一个所设想的那样，其中有一个项目列表，并通过 HTML 输入字段进行搜索。我们不会使用 React 的 useState Hook 来捕获搜索状态，而是使用 React Router 来获取可共享的 URL。 App 组件如下所示，类似于前面提到的 React Router 教程中的 App 组件： const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/bookshelf&quot;&gt;Bookshelf&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;bookshelf&quot; element={&lt;Bookshelf /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 虽然 Home 和 NoMatch 组件只是具有任何实现的占位符组件，但我们将关注 Bookshelf 组件，它将Books显示为列表组件。这些Books示例数据可以从远程 API（或模拟 API）获取： const Bookshelf = () =&gt; { const books = [ { title: 'The Road to Rust', isCompleted: false, }, { title: 'The Road to React', isCompleted: true, }, ]; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;ul&gt; {books.map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 为了使用户能够通过不区分大小写的标题匹配来过滤此列表，我们使用 React 的 useState Hook 和 HTML 输入字段。最后，事件处理程序将从输入字段中读取值并将其写入状态： const byTitle = (title) =&gt; (book) =&gt; book.title.toLowerCase().includes((title || '').toLowerCase()); const Bookshelf = () =&gt; { const books = [...]; const [title, setTitle] = React.useState(''); const handleTitle = (event) =&gt; { setTitle(event.target.value); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={title} onChange={handleTitle} /&gt; &lt;ul&gt; {books.filter(byTitle(title)).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 这就是就是“在 React 中使用状态”的版本。接下来，我们要使用 React Router 来在 URL 中捕获此状态。React Router 为我们提供了 useSearchParams hook，它几乎可以用来替代 React 的 useState hook： import * as React from 'react'; import { Routes, Route, Link, useSearchParams, } from 'react-router-dom'; ... const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useSearchParams(); const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={search.get('title')} onChange={handleTitle} /&gt; &lt;ul&gt; {books.filter(byTitle(search.get('title'))).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 由于以下两点，它不能直接替代 React 的 useState Hook。首先，它对一个对象而不是字符串进行操作，因为一个 URL 可以有多个搜索参数（例如 /bookshelf?title=Rust&amp;rating=4），因此每个搜索参数都成为该对象中的一个属性（例如{ title: 'Rust', rating: 4 })。 如果我们将 React 的 useState Hook 与对象而不是字符串一起使用，它本质上与我们之前的实现类似： const [search, setSearch] = React.useState({ title: '' }); 然而，即使 useSearchParams 返回的有状态值是对象类型（typeof search === 'object'），它仍然不能像单纯的 JavaScript 对象数据结构那样访问，因为它是 URLSearchParams 的一个实例。因此我们需要调用它的 getter 方法（例如 search.get('title')）。 其次，React Router 的 useSearchParams Hook 不接受初始状态，因为初始状态来自 URL。因此，当用户与搜索参数（例如 /bookshelf?title=Rust）共享 URL 时，另一个用户将从 React Router 的 Hook 获得 { title: 'Rust' } 作为初始状态。当应用程序将用户导航到带有搜索参数且设置了可选搜索参数的路线时，也会发生同样的情况。 这就是使用状态的 URL 而不是使用 React 的状态管理 Hook 之一。它极大地改善了用户体验，因为 URL 变得更加特定于用户在页面上看到的内容。因此，这个特定的 URL 可以与其他用户共享，他们将看到具有相同 UI 的页面。 URLSEARCHPARAMS 转换为对象 如果你在处理 React Router 的 useSearchParams Hook 时不想使用 URLSearchParams，你可以编写一个自定义hook，它返回一个 JavaScript 对象而不是 URLSearchParams 的实例： const useCustomSearchParams = () =&gt; { const [search, setSearch] = useSearchParams(); const searchAsObject = Object.fromEntries( new URLSearchParams(search) ); return [searchAsObject, setSearch]; }; const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useCustomSearchParams(); const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={search.title} onChange={handleTitle} /&gt; &lt;ul&gt; {books.filter(byTitle(search.title)).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 然而，这个自定义hook应该有一点不足，因为它不适用于重复键（例如带有 ?editions=1&amp;editions=3 的数组搜索参数）和使用复杂 URL 时的其他边界情况。 一般来说，仅使用 React Router 的 useSearchParams Hook（或这个自定义的 useCustomSearchParams hook）并不能为你提供 URL 状态管理的完整体验，因为它仅可用于字符串而不能用于其他数据类型。我们将在接下来的部分中探讨这一点以及如何解决这个问题。 搜索参数与保留数据类型 并非所有状态都只包含字符串。在前面使用 React Router 的搜索参数的例子中，我们使用了一个字符串（这里是：title），它被编码到 URL 中。当从 URL 解码这个字符串时，我们将默认得到一个字符串——这在我们的例子中有效，因为我们需要一个字符串。但是其他原始数据类型如数字或布尔值呢？更不用说复杂的数据类型，例如数组。 为了探索解决这个，我们将通过实现一个复选框来继续之前的示例。我们将使用这个复选框组件并将其连接到 React Router 的搜索参数： const bySearch = (search) =&gt; (book) =&gt; book.title .toLowerCase() .includes((search.title || '').toLowerCase()) &amp;&amp; book.isCompleted === search.isCompleted; const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useCustomSearchParams(); const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }); }; const handleIsCompleted = (event) =&gt; { setSearch({ isCompleted: event.target.checked }); }; return ( &lt;&gt; &lt;h2&gt;Bookshelf&lt;/h2&gt; &lt;input type=&quot;text&quot; value={search.title} onChange={handleTitle} /&gt; &lt;Checkbox label=&quot;Is Completed?&quot; value={search.isCompleted} onChange={handleIsCompleted} /&gt; &lt;ul&gt; {books.filter(bySearch(search)).map((book) =&gt; ( &lt;li key={book.title}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 在浏览器中实验以下。你将看到对 isCompleted 布尔值的搜索不起作用，因为来自我们的搜索对象的 isCompleted 被表示为一个字符串，如“true”或“false”。我们可以通过增强我们的自定义hook来规避这一点： const useCustomSearchParams = (param = {}) =&gt; { const [search, setSearch] = useSearchParams(); const searchAsObject = Object.fromEntries( new URLSearchParams(search) ); const transformedSearch = Object.keys(param).reduce( (acc, key) =&gt; ({ ...acc, [key]: param[key](acc[key]), }), searchAsObject ); return [transformedSearch, setSearch]; }; const PARAMS = { BooleanParam: (string = '') =&gt; string === 'true', }; const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useCustomSearchParams({ isCompleted: PARAMS.BooleanParam, }); ... return (...); }; 本质上，新版本的自定义hook采用具有可选转换功能的对象。它遍历每个转换函数，如果找到转换函数和搜索参数之间的匹配项，则将该函数应用于搜索参数。在这种情况下，我们将字符串布尔值（“true”或“false”）转换为实际的布尔值。如果没有找到匹配项，它只返回原始搜索参数。因此我们不需要标题的转换函数，因为它是一个字符串并且可以继续为字符串。 通过拥有自定义hook的实现细节，我们还可以创建其他转换器函数（例如 NumberParam），从而填补缺失数据类型转换（例如数字）的空白： const PARAMS = { BooleanParam: (string = '') =&gt; string === 'true', NumberParam: (string = '') =&gt; (string ? Number(string) : null), // other transformation functions to map all data types }; 开源组件中use-query-params这个库完美的解决这个问题。 React Router 使用搜索参数 use-query-params 库非常适合将复杂的 URL 用作超越字符串的状态的用例。在本节中，我们将探索 use-query-params 库，从而摆脱我们自定义的 useSearchParams hook。 自己按照库的安装说明进行操作。你需要在命令行上安装该库并在 React 项目的根级别实例化它： import React from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter, Route } from 'react-router-dom'; import { QueryParamProvider } from 'use-query-params'; import App from './App'; ReactDOM.render( &lt;BrowserRouter&gt; &lt;QueryParamProvider ReactRouterRoute={Route}&gt; &lt;App /&gt; &lt;/QueryParamProvider&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ); 然而， use-query-params 还没有正确适应 React Router 6。因此，你可能会看到以下错误弹出：“ 仅用作 元素的子元素，永远不会直接呈现。请将你的 包装在 中。”。因此，在根级别调整你的代码： import React from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter, useNavigate, useLocation, } from 'react-router-dom'; import { QueryParamProvider } from 'use-query-params'; import App from './App'; const RouteAdapter = ({ children }) =&gt; { const navigate = useNavigate(); const location = useLocation(); const adaptedHistory = React.useMemo( () =&gt; ({ replace(location) { navigate(location, { replace: true, state: location.state }); }, push(location) { navigate(location, { replace: false, state: location.state }); }, }), [navigate] ); return children({ history: adaptedHistory, location }); }; ReactDOM.render( &lt;BrowserRouter&gt; &lt;QueryParamProvider ReactRouterRoute={RouteAdapter}&gt; &lt;App /&gt; &lt;/QueryParamProvider&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ); 现在你可以使用 use-query-params 在 React 中进行强大的 URL 状态管理。你所要做的就是使用新的 useQueryParams 钩子。另请注意，与我们的自定义钩子相比，你还需要“转换”字符串搜索参数： import * as React from 'react'; import { Routes, Route, Link } from 'react-router-dom'; import { useQueryParams, StringParam, BooleanParam, } from 'use-query-params'; ... const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useQueryParams({ title: StringParam, isCompleted: BooleanParam, }); ... return (...); }; 你还可以提供合理的默认值。例如，此时在没有搜索参数的情况下导航到 /bookshelf 时，title 和 isComplete 将是未定义的。但是，如果你希望它们至少是标题的空字符串和 isComplete 的 false，你可以提供这些默认值，例如： import * as React from 'react'; import { Routes, Route, Link } from 'react-router-dom'; import { useQueryParams, StringParam, BooleanParam, withDefault } from 'use-query-params'; ... const Bookshelf = () =&gt; { const books = [...]; const [search, setSearch] = useQueryParams({ title: withDefault(StringParam, ''), isCompleted: withDefault(BooleanParam, false), }); ... return (...); }; 还有一件值得注意的事情要提到：目前，use-query-params 使用默认的“push in”模式，这意味着每次附加搜索参数时，它不会覆盖其他搜索参数。因此，你在更改其中之一的同时保留所有搜索参数。但是，如果这不是你想要的行为，你还可以更改模式（例如，更改为“push”），这样将不再保留以前的搜索参数（尽管这在我们的场景中没有意义）： const Bookshelf = () =&gt; { ... const handleTitle = (event) =&gt; { setSearch({ title: event.target.value }, 'push'); }; const handleIsCompleted = (event) =&gt; { setSearch({ isCompleted: event.target.checked }, 'push'); }; ... return (...); }; 除了我们在这里使用的两种数据类型转换之外，还有对数字、数组、对象等的转换。例如，如果你希望在 React 中有一个可选择的表，你可能希望将表中的每个选定行表示为数组中的标识符（在 use-query-params 中，它是 ArrayParam 转换）映射到实际 URL .然后你可以与另一个用户共享此 URL，该用户将从所选行开始。 使用 URL 作为状态是改善用户体验的方式。在处理单个或多个字符串状态时，React Router 的搜索参数为你提供了一个很好的体验。但是，一旦你想保留映射到 URL 的数据类型，你可能希望使用诸如 use-query-params 之类的库在 React 中进行复杂的 URL 状态管理。 参考 use-query-params ","link":"https://umeimmense.github.io/post/react-router-6sou-suo-can-shu"},{"title":"React Router 6：嵌套路由","content":"前言 本文教你如何在 React Router 6 中使用嵌套路由。嵌套路由是一个强大的功能。虽然大多数人认为 React Router 只会在页面之间路由使用，但它也允许用户根据当前路由交换视图的特定片段。例如，在用户页面上，会显示多个选项卡（例如个人资料、帐户）以浏览用户信息。通过单击这些选项卡，浏览器中的 URL 会发生变化，但不会替换整个页面，只会替换选项卡的内容。 下面我们将使用 React Router 重新创建这个场景。为了说明这是如何工作的，以及如何自己在 React 中逐步实现嵌套路由，我们将从以下示例开始： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;user&quot; element={&lt;User /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 在这个函数组件中，我们使用了 React Router 中的 Link 和 Route 组件，用于 home/ 和 user/ 路由。此外，我们有一个加载了 Home 组件的所谓的索引路由和一个加载了 NoMatch 组件的所谓的 No Match 路由。两者都作为备选路线。从这里开始，我们将了解嵌套路由的概念。 React Router 中的嵌套路由 我们将继续处理 User 组件，这是我们希望通过选项卡进行嵌套路由的地方。因此，我们将实例化一组新的 Link 组件（将是我们的无样式选项卡），用于将用户导航到他们的个人资料和他们的帐户。 const User = () =&gt; { return ( &lt;&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/user/profile&quot;&gt;Profile&lt;/Link&gt; &lt;Link to=&quot;/user/account&quot;&gt;Account&lt;/Link&gt; &lt;/nav&gt; &lt;/&gt; ); }; 我们在这里使用绝对路径将用户从他们的个人资料导航到他们的帐户，反之亦然，但是，我们也可以使用相对路径作为最佳实践。因为 User 组件位于 /user 路由中，所以 Link 组件可以预测它们的父路由（这里是：/user），并且只需将相对路径（这里：profile 和 account）附加到它（例如 /user/profile）： const User = () =&gt; { return ( &lt;&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;profile&quot;&gt;Profile&lt;/Link&gt; &lt;Link to=&quot;account&quot;&gt;Account&lt;/Link&gt; &lt;/nav&gt; &lt;/&gt; ); }; 此时，当我们尝试在 React 应用程序中单击这些链接之一时，我们将被困在我们的 No Match Route 中。这告诉我们，我们还没有将这些路由（此处：/user/profile 和 /user/account）映射到任何实际的路由组件。因此，我们将这两个新路由作为所谓的嵌套路由添加到我们的 /user 路由中： const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;user&quot; element={&lt;User /&gt;}&gt; &lt;Route path=&quot;profile&quot; element={&lt;Profile /&gt;} /&gt; &lt;Route path=&quot;account&quot; element={&lt;Account /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; Route 组件现在以一对一的关系映射到 Link 组件。但是，可以有多个 Link 组件链接到同一个路由，因此它实际上是一对多的关系。 在浏览器中对此进行测试时，我们将看到仅显示 User 组件，而不会显示其嵌套的 Profile 组件，也不会显示其嵌套的 Account 组件。我们缺少 React Router 的关键 Outlet 组件： import { Routes, Route, Link, Outlet } from 'react-router-dom'; ... const User = () =&gt; { return ( &lt;&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;profile&quot;&gt;Profile&lt;/Link&gt; &lt;Link to=&quot;account&quot;&gt;Account&lt;/Link&gt; &lt;/nav&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; Outlet 组件从父 Routes 的 Route 组件集合中使用其各自的组件（此处为 Profile 或 Account 组件）呈现匹配的子路由。 如果没有 /profile 和 /account 路由匹配（例如 /user/settings），你将只看到 User 组件出现。为避免这种情况，你可以添加索引和无匹配路由的组合。之后，默认路由将是 /profile 路由： const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/user&quot;&gt;User&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;user&quot; element={&lt;User /&gt;}&gt; &lt;Route index element={&lt;Profile /&gt;} /&gt; &lt;Route path=&quot;profile&quot; element={&lt;Profile /&gt;} /&gt; &lt;Route path=&quot;account&quot; element={&lt;Account /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 虽然 User 组件总是将选项卡呈现为导航，但其内容（Outlet）被匹配的嵌套路由（基于 /user/profile 或 /user/account 路由的 Profile 或 Account 组件）替换。如果在访问 /user 路由时这些路由都不匹配，应用程序将显示 Profile 组件（如果路由与 /user 完全匹配）或 NoMatch 组件（如果路由不匹配，例如 /user/setting）出现。 React router 中的 动态嵌套路由 在嵌套路由的下一个示例中，我们将从 App 组件中开始。这次我们不想像之前那样渲染静态嵌套路由（例如 /user/profile），而是基于标识符的动态嵌套路由（例如 /users/1 用于显示具有标识符 1 并因此匹配此路由的用户）。因此，我们将示例从单用户路由 (/user) 调整为多用户路由 (/user)。 const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; Users 组件成为 React 中的列表组件，因为它遍历每个用户并为其返回 JSX。在这种情况下，它不仅仅是一个列表，因为我们将 React Router 的 Link 组件添加到组合中。 Link 组件中的相对路径提示相应的嵌套（此处：/user.id嵌套在/users中）但动态（此处：/{user.id} 嵌套在 /users 中）但动态（此处：/user.id嵌套在/users中）但动态（此处：/{user.id}）路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 通过拥有这个新的动态嵌套路由，我们需要在 App 组件中为它创建一个匹配的嵌套路由组件。首先，由于它是 /users 路由的所谓嵌套路由（或子路由），我们可以将它嵌套在相应的父路由组件中。此外，由于它是所谓的动态路由，它使用定义为 :userId 的动态路由，而用户的标识符则动态匹配（例如，id 为 '1' 的用户将与 /users/1 匹配）： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav&gt;...&lt;/nav&gt; &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 这样，User 组件就变成了 Users 组件的嵌套路由。因此，再次在 Outlet 组件的帮助下渲染其嵌套路由是用户组件的责任——再次渲染匹配的子路由： import { Routes, Route, Link, Outlet } from 'react-router-dom'; ... const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt;...&lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 接下来，我们将声明缺少的 User 组件，只要用户的标识符在 URL 中匹配，该组件就会通过 Users 组件中的 Outlet 嵌套。在这个新组件中，我们可以使用 React Router 的 useParams Hook 从 URL 中获取相应的 userId（等于 :userId）： import { ... useParams, } from 'react-router-dom'; ... const User = () =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 我们已经看到了如何通过将一个 Route 组件（或多个 Route 组件）嵌套在另一个 Route 组件中来创建嵌套路由。前者是嵌套的子路由，后者是渲染封闭组件的父路由，该组件必须使用 Outlet 组件来渲染实际匹配的子路由。 此外，我们还看到了如何通过在路由的路径属性中使用冒号（例如：userId）来创建动态路由。本质上， :userId 充当任何标识符的星号。在我们的例子中，我们使用 Link 组件将用户导航到 /users/:userId 路由，其中​​ :userId 代表实际用户的标识符。最后，我们总是可以通过使用 React Router 的 useParams Hook 从 URL 中获取动态路径（称为参数或 params）。 如果你碰巧将 React Router 用于你的 React 应用程序，嵌套路由可以通过让你的用户访问你的应用程序非常特定的部分，同时将这些部分作为 URL 共享，从而极大地提升你的用户体验。 ","link":"https://umeimmense.github.io/post/react-router-6qian-tao-lu-you"},{"title":"初探 React Router 6 ","content":"前言 不久前，React Router 库更新到了第 6 版，随之而来的是一些有趣的变化，本文将讲述React Router 6的一些新特性及使用的案例。 接下来是一些准备工作： 首先需要创建一个新的 React 项目（例如 create-react-app）。然后，按照官方文档安装 React Router。 yarn add react-router-dom@latest 我们这里安装的是6.0.2版本。 2. 第一个实现细节将告诉我们的 React 应用程序我们想要使用 React Router。因此，在 React 项目的顶级文件（例如 index.js）中导入 Router 组件，其中 React 使用 ReactDOM API 挂载到 HTML： import React from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter } from 'react-router-dom'; import App from './App'; ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ); 从这里开始，我们将在 App.js 文件中继续我们的实现。 匹配路由 首先，我们将使用 React Router 的 Link 组件在我们的 App 组件中实现导航。我不建议使用内联样式，因此请根据你的 React 项目选择合适的样式策略和样式方法： import { Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; 当你在浏览器中启动 React 应用程序时，你应该能够单击两个 Link 组件，这些组件应该将你导航到各自的路由。单击这些链接时，可通过检查浏览器的当前 URL 来确认。接下来，我们需要使用 React Router 的 Route 组件将路由映射到实际渲染： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; 你可以通过检查它们各自的 to 和 path 属性来查看 Link 和 Route 组件之间的直接匹配。当路由匹配时，每个 Route 组件都会渲染一个 React 元素。由于我们在这里渲染一个 React 元素，我们也可以传递 React props。缺少的是相应功能组件的声明： const Home = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/main&gt; ); }; const Users = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/main&gt; ); }; 返回浏览器时，你应该能够在看到 Home 和 Users 组件的同时从一个页面导航到另一个页面（此处：从 /home 到 /users 路由）。基本上这就是 React Router 的本质：设置 Link 组件并将它们与 Route 组件匹配。链接与路由是多对一的关系，因此你的应用程序中可以有多个链接链接到同一个路由。 布局路由、索引路由、无匹配路由 接下来，你将看到新的 Home 和 Users 组件如何共享相同的布局。作为 React 开发人员，直觉上我们会从 Home 和 Users 组件中提取一个带有样式的新组件，以避免重复。在这个新组件中，我们将使用 React 的 children 属性将组件组合在一起。第一步，将样式提取到它自己的组件中： const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = ({ children }) =&gt; { return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;; }; 其次，在 App 组件中渲染它。通过使用 React 的子级，Layout 组件应该渲染匹配的封闭子路由： import { Routes, Route, Link } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Layout&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Layout&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = ({ children }) =&gt; { return &lt;main style={{ padding: '1rem 0' }}&gt;{children}&lt;/main&gt;; }; 但是你会看到这在 React Router 中是不允许的，你会得到一个异常说： 的所有组件子项必须是 或 &lt;React.Fragment&gt;。解决此问题的一种常见方法是在每个组件中单独使用 Layout 组件（类似于我们之前使用的）或在每个 Route 组件中（如下例所示）： const App = () =&gt; { return ( &lt;&gt; ... &lt;Routes&gt; &lt;Route path=&quot;home&quot; element={&lt;Layout&gt;&lt;Home /&gt;&lt;/Layout&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Layout&gt;&lt;Users /&gt;&lt;/Layout&gt;} /&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 然而，这给 React 应用程序增加了不必要的冗余。因此，我们将使用所谓的 Layout Route，而不是复制 Layout 组件，它不是实际的路由，而只是一种方法，可以让一组 Route 中的每个 Route 组件的元素具有相同的周围样式： const App = () =&gt; { return ( &lt;&gt; ... &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; 如你所见，可以将 Route 组件嵌套在另一个 Route 组件中——而前者成为所谓的嵌套路由。现在不再在 Layout 组件中使用 React 的子组件，而是使用 React Router 的 Outlet 组件作为等效组件： import { Routes, Route, Outlet, Link } from 'react-router-dom'; ... const Layout = () =&gt; { return ( &lt;main style={{ padding: '1rem 0' }}&gt; &lt;Outlet /&gt; &lt;/main&gt; ); }; 本质上，Layout 组件中的 Outlet 组件插入了父路由（这里：Layout 组件）的匹配子路由（这里：Home 或 Users 组件）。毕竟，使用 Layout Route 可以帮助你为集合中的每个 Route 组件提供相同的布局（例如，CSS 样式，HTML 结构）。 从这里开始，你可以更进一步，将 App 组件的所有实现细节（标题、导航）移动到这个新的 Layout 组件中。此外，我们可以与 NavLink 组件交换链接，以实现所谓的活动链接——向用户显示当前活动的路线。因此，当将新的 NavLink 组件与函数一起使用时，我们可以访问其style和 className props中的 isActive 标志： import { Routes, Route, Link, NavLink, Outlet } from 'react-router-dom'; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; ); }; const Navigation = () =&gt; { return ( &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; ); }; const Home = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/&gt; ); }; const Users = () =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/&gt; ); }; const Layout = () =&gt; { const style = ({ isActive }) =&gt; ({ fontWeight: isActive ? 'bold' : 'normal', }); return ( &lt;&gt; &lt;h1&gt;React Router&lt;/h1&gt; &lt;nav style={{ borderBottom: 'solid 1px', paddingBottom: '1rem', }} &gt; &lt;NavLink to=&quot;/home&quot; style={style}&gt;Home&lt;/NavLink&gt; &lt;NavLink to=&quot;/users&quot; style={style}&gt;Users&lt;/NavLink&gt; &lt;/nav&gt; &lt;main style={{ padding: '1rem 0' }}&gt; &lt;Outlet /&gt; &lt;/main&gt; &lt;/&gt; ); }; 接下来你可能已经注意到这个 React 应用程序缺少一个基本路由。虽然我们有 /home 和 /users 路由，但没有 / 路由。你也会在浏览器的开发人员工具中看到此警告：没有路由匹配位置“/”。因此，每当用户访问 / 路由时，我们都会创建一个所谓的索引路由作为回退。此回退路由的元素可以是新组件或任何已匹配的路由（例如，Home 应为路由 / 和 /home 呈现，如下例所示）： const App = () =&gt; { return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 当父路由匹配但没有子路由匹配时，你可以将索引路由视为默认路由。接下来，如果用户导航到不匹配的路由（例如 /about），我们将添加一个所谓的 No Match Route（也称为 Not Found Route），它相当于网站的 404 页面： const App = () =&gt; { return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; const NoMatch = () =&gt; { return (&lt;p&gt;There's nothing here: 404!&lt;/p&gt;); }; 到目前为止，在使用 Routes 组件作为 Route 组件集合的容器时，通过使用 Layout Routes、Index Routes 和 No Match Routes 展示了 React Router 的其他最佳实践。如你所见，也可以将 Route 组件嵌套到 Route 组件中。\b下面我们接着了解有关嵌套路由的更多信息。 动态且嵌套的路由 接下来我们将用实现细节来装饰用户组件。首先，我们将在我们的 App 组件中初始化一个项目列表（这里是：用户）。该列表只是示例数据，但它也可以在 React 中从远程 API 获取。其次，我们将用户作为props传递给用户组件： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;} /&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; Users 组件成为 React 中的列表组件，因为它遍历每个用户并为其返回 JSX。在这种情况下，它不仅仅是一个列表，因为我们将 React Router 的 Link 组件添加到组合中。 Link 组件中的相对路径提示相应的动态（此处：/user.id）尚未嵌套（此处：/{user.id}）尚未嵌套（此处：/user.id）尚未嵌套（此处：/{user.id} 嵌套在 /users 中）路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={`/users/${user.id}`}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 通过拥有这个新的动态嵌套路由，我们需要在 App 组件中为它创建一个匹配的嵌套路由组件。首先，由于它是 /users 路由的所谓嵌套路由（或子路由），我们可以将它嵌套在相应的父路由组件中。此外，由于它是所谓的动态路由，它使用定义为 :userId 的动态路由，而用户的标识符则动态匹配（例如，id 为 '1' 的用户将与 /users/1 匹配）： const App = () =&gt; { const users = [ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 之前，当我们介绍将 /home 和 /users 路由作为其子路由的父布局路由时，我们已经了解了嵌套路由。当我们进行此更改时，我们必须使用父路由中的 Outlet 组件来渲染匹配的子路由。同样的情况在这里再次发生，因为用户组件也必须渲染它的嵌套路由： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt;...&lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 接下来，我们将声明缺少的 User 组件，只要用户的标识符在 URL 中匹配，该组件就会通过 Users 组件中的 Outlet 嵌套。因此，我们可以使用 React Router 的 useParams Hook 从 URL 中获取相应的 userId（等于 :userId）： import { ... useParams, } from 'react-router-dom'; ... const User = () =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 我们再次看到了如何通过将一个 Route 组件（或多个 Route 组件）嵌套在另一个 Route 组件中来创建嵌套路由。前者是嵌套的子路由，后者是渲染封闭组件的父路由，该组件必须使用 Outlet 组件来渲染实际匹配的子路由。 我们还看到了如何通过在路由的路径属性（例如：userId）中使用冒号来创建动态路由。本质上， :userId 充当任何标识符的星号。在我们的例子中，我们使用 Link 组件将用户导航到 /users/:userId 路由，其中​​ :userId 代表实际用户的标识符。最后，我们总是可以通过使用 React Router 的 useParams Hook 从 URL 中获取动态路径（称为参数或 params）。 React Router中的相关链接 最新版本的 React Router 带有所谓的相对链接。我们将通过查看用户组件及其用于链接组件的绝对 /users/${user.id} 路径来研究这个概念。在之前版本的 React Router 中，需要指定整个路径。但是，在此版本中，你可以仅使用嵌套路径作为相对路径： const Users = ({ users }) =&gt; { return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt; {user.fullName} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; ); }; 由于 Users 组件用于 /users 路由，因此 Users 组件中的 Link 知道其当前位置，不需要创建绝对路径的整个顶级部分。相反，它知道 /users 并且只是附加 :userId 作为它的相对路径。 声明式和程序式导航 到目前为止，我们只在使用 Link 或 NavLink 组件时使用了声明式导航。但是，在某些情况下，你希望能够通过 JavaScript 以编程方式导航用户。我们将通过实现一个可以在 User 组件中删除用户的功能来展示这个场景。在删除后，用户应该从 User 组件导航到 Users 组件（从 /users/:userId 到 /users）。 我们将通过使用 React 的 useState Hook 创建一个有状态的 users 值来开始这个实现，然后实现一个事件处理程序，该处理程序使用标识符从用户中删除用户： import * as React from 'react'; ... const App = () =&gt; { const [users, setUsers] = React.useState([ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]); const handleRemoveUser = (userId) =&gt; { setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId)); }; return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;home&quot; element={&lt;Home /&gt;} /&gt; &lt;Route path=&quot;users&quot; element={&lt;Users users={users} /&gt;}&gt; &lt;Route path=&quot;:userId&quot; element={&lt;User onRemoveUser={handleRemoveUser} /&gt;} /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element={&lt;NoMatch /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; ); }; 在我们将事件处理程序作为回调处理程序传递给 User 组件后，我们可以在那里使用它作为内联处理程序来通过标识符删除特定用户： const User = ({ onRemoveUser }) =&gt; { const { userId } = useParams(); return ( &lt;&gt; &lt;h2&gt;User: {userId}&lt;/h2&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; onRemoveUser(userId)}&gt; Remove &lt;/button&gt; &lt;Link to=&quot;/users&quot;&gt;Back to Users&lt;/Link&gt; &lt;/&gt; ); }; 一旦用户被删除，我们可以使用 React Router 的 useNavigate Hook，它允许我们以编程方式将用户导航到另一个路由（这里：/users）： import * as React from 'react'; import { ... useNavigate, } from 'react-router-dom'; const App = () =&gt; { const navigate = useNavigate(); const [users, setUsers] = React.useState([ { id: '1', fullName: 'Robin Wieruch' }, { id: '2', fullName: 'Sarah Finnley' }, ]); const handleRemoveUser = (userId) =&gt; { setUsers((state) =&gt; state.filter((user) =&gt; user.id !== userId)); navigate('/users'); }; return (...); }; 在这种情况下，删除操作是同步发生的，因为用户只是客户端的一个有状态值。但是，如果用户是数据库中的实体，则必须发出异步请求才能删除它。一旦这个操作成功（例如：promise是 resolved时），用户就会被导航到 /users 路由。你可以通过在 React 中设置一个虚假的 API 来自己尝试这个场景，而不使用实际的服务器。 搜索参数 浏览器中的 URL 不仅包含路径，还包含一个可选的查询字符串（在 React Router 中称为搜索参数），它以键/值对的形式出现在 ? URL 中的分隔符。例如，/users?name=robin 将是一个带有一对搜索参数的 URL，其中键是名称，值是 robin。以下示例将其显示为实现： import * as React from 'react'; import { ... useSearchParams, } from 'react-router-dom'; ... const Users = ({ users }) =&gt; { const [searchParams, setSearchParams] = useSearchParams(); const searchTerm = searchParams.get('name') || ''; const handleSearch = (event) =&gt; { const name = event.target.value; if (name) { setSearchParams({ name: event.target.value }); } else { setSearchParams({}); } }; return ( &lt;&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;input type=&quot;text&quot; value={searchTerm} onChange={handleSearch} /&gt; &lt;ul&gt; {users .filter((user) =&gt; user.fullName .toLowerCase() .includes(searchTerm.toLocaleLowerCase()) ) .map((user) =&gt; ( &lt;li key={user.id}&gt; &lt;Link to={user.id}&gt;{user.fullName}&lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;Outlet /&gt; &lt;/&gt; ); }; 首先，我们使用 React Router 的 useSearchParams Hook 从 URL 中读取当前搜索参数（请参阅 searchParams 上的 get() 方法），同时还将搜索参数写入 URL（请参阅 setSearchParams() 函数）。虽然我们使用前者按键获取搜索参数（此处：“name”）来控制输入字段，但我们使用后者在 URL 中按键设置搜索参数。在输入字段中键入。在其核心，React Router 的 useSearchParams Hook 与 React 的 useState Hook 相同，区别在于该状态是 URL 状态，而不是 React 中的本地状态。最后我们使用搜索参数来过滤用户的实际列表以完成此功能。 毕竟，在你的 URL 中包含搜索参数可以让你与他人共享更具体的 URL。如果你在一个搜索黑色鞋子的电子商务网站上，你可能希望共享整个 URL（例如 myecommerce.com/shoes?color=black）而不仅仅是路径（例如 myecommerce.com/shoes）。 总结 React Router 是 React 最常用的第三方库之一。它的核心功能是将 Link 组件映射到 Route 组件，这使开发人员无需向 Web 服务器发出请求即可实现客户端路由。然而，除了这个核心功能之外，它还是一个成熟的路由库，它支持声明式嵌套路由、动态路由、导航、活动链接，还可以通过 URL 进行编程导航和搜索。 参考 react-router CRA ","link":"https://umeimmense.github.io/post/chu-tan-react-router-6"},{"title":" JavaScript 中的 Heap","content":"前言 之前我们已经研究了树数据结构的实现以及它的一些变体，例如 trie。在这篇文章中，我们将深入研究堆。它也称为优先级队列。 什么是堆？ 堆是树数据结构的一种变体，具有两个附加属性： 1.它是一棵完全二叉树：一棵完全二叉树的每一层都包含最大数量的节点，可能最后一层除外，它必须从左到右填充。完整的二叉树总是通过它的定义来平衡的。作为参考下图显示了什么时候可以将树称为完全二叉树： 2.每个节点都满足“堆属性”：堆属性本质上意味着对于任何给定的节点 C，如果 P 是 C 的父节点，则： 对于最大堆：P 的键应该大于或等于 C 的键。 对于最小堆：P 的键应该小于或等于 C 的键。 如何表示堆？ 我们通常从节点的类表示开始实现，然后将其与实际数据结构本身的类表示联系起来。我们也可以对堆做同样的事情。但是，有一种更简单的方法可以解决此问题，这是因为所有堆都必须遵守以下两个属性之一： 所有堆必须是完全二叉树 由于所有堆都必须是完全二叉树，并且我们知道完全二叉树中除最后一层外的所有级别都必须完全填充。此外，对于最后一层，所有子项必须从左到右方向填充，没有任何间隙。这个定义确保了一个由 n 个节点组成的完全二叉树只能有 1 种可能的形状。反过来，它允许我们使用数组来表示完整的二叉树。这意味着，堆也可以使用数组来表示。例如，我们可以将一个简单的堆表示为一个数组，如下图所示： 这里要注意的关键是父节点和子节点之间的关系。如果仔细观察上图，我们可以推断出以下内容： 如果节点位于数组中的索引 i 处，则假设结果索引位于数组的长度内： 它的左孩子将在第 (2i+1) 个位置 左孩子将在 (2i+2) 位置 如果一个节点被放置在数组中的索引 i 处，它的父节点将位于第 ((i-1)/2) 个索引处。 下图可以更轻松地使用上述信息： 具体实现 注意：在整个实现过程中，我们只会讨论最小堆。稍后我们将看到如何将相同的想法轻松扩展到最大堆。 在我们已经涵盖了表示的细节，让我们想出一个使用数据结构的接口。在堆数据结构的帮助下，我们希望能够实现三个关键点： 向堆中添加一个新键 从堆中删除最大或最小键（取决于它是最小堆还是最大堆） 从堆中获取最小键的最大值（取决于是最小堆还是最大堆） 第三个操作很简单。我们知道对于最小堆，数组中的第一项将是最小键，同样对于最大堆，数组中的第一项将是最大键。所以我们剩下两个操作的实现： // adds the provided newKey into the min-heap named &quot;heap&quot; function heappush(heap, newKey){} // removes the smallest key from the min-heap named &quot;heap&quot; function heappop(heap){} 实现heappush() 我们如何向堆中添加一个新键？假设我们首先将新键推送到数组中。推送新键仍然让我们遵守堆的第一个要求，即它必须是一个完整的二叉树。但是，我们需要确保它也遵守“堆属性”。 我们可以通过将push的项与其父项进行比较来做到这一点。如果父项大于的push的项，那么我们知道堆属性被违反，因此我们可以交换。我们可以继续进行这种交换，直到找到一个合法的父节点或者我们已经到达堆的顶部。 代码如下 function heappush(heap, newKey){ // push the new key heap.push(newKey); // get the current index of pushed key let curr = heap.length-1; // keep comparing till root is reached or we terminate in middle while(curr &gt; 0){ let parent = Math.floor((curr-1)/2) if( heap[curr] &lt; heap[parent] ){ // quick swap [ heap[curr], heap[parent] ] = [ heap[parent], heap[curr] ] // update the index of newKey curr = parent } else{ // if no swap, break, since we heap is stable now break } } } 实现 heappop() 使用 heappop() 我们需要删除堆的最顶层元素。意思是，对于最小堆，最小键将被删除，而对于最大堆，最大键将被删除。从数组的角度来看，它只是意味着我们应该删除数组的第一项。但是哪个节点应该成为根？如果我们随机选择被移除节点的左孩子或右孩子作为新的根节点，则不能保证遵循堆属性。我们可以按照以下步骤（对于最小堆）： 将根节点与最后一个节点交换（数组中的第一个元素与最后一个元素） 通过从数组中弹出最后一项来删除根节点 将新根节点的键与其子节点进行比较： 如果键小于它的两个子键，则堆是稳定的 否则，将Key与较小的子Key交换 重复步骤 3，直到到达最后一个子节点或建立堆属性。 本质上，我们遵循与 heappush() 类似的过程，除了我们试图以从上到下的方式建立堆属性，即从根开始并一直持续到最后一个孩子。在 heappush() 中，我们遵循相反的顺序，即从最后一个孩子开始，一直到根。 代码实现： function heappop(heap){ // swap root with last node const n = heap.length; [heap[0], heap[n-1]] = [ heap[n-1], heap[0]] // remove the root i.e. the last item (because of swap) const removedKey = heap.pop(); let curr = 0; // keep going till atleast left child is possible for current node while(2*curr + 1 &lt; heap.length){ const leftIndex = 2*curr+1; const rightIndex = 2*curr+2; const minChildIndex = (rightIndex &lt; heap.length &amp;&amp; heap[rightIndex] &lt; heap[leftIndex] ) ? rightIndex :leftIndex; if(heap[minChildIndex] &lt; heap[curr]){ // quick swap, if smaller of two children is smaller than the parent (min-heap) [heap[minChildIndex], heap[curr]] = [heap[curr], heap[minChildIndex]] curr = minChildIndex } else { break } } // finally return the removed key return removedKey; } 使用现有数组创建堆 从现有数组创建堆看起来非常简单。只需创建一个空堆，然后遍历数组的所有项并执行 heappush(): function heapify(arr){ const heap = [] for(let item of arr){ heappush(heap, item) } return heap; } 但是我们可以在这里做得更好吗？是的。首先，我们可以完全避免为新堆使用额外的空间。为什么不重新排列数组本身的元素，使其满足堆属性？为此，我们可以遵循与堆弹出类似的逻辑。我们可以查看第一个节点并与它的子节点进行比较，看看它是否是最小的节点，如果不是与较小的子节点交换。下面我们来实现一下： // follows pretty much the same logic as heappush, except minor modifications function percolateDown(heap, index){ let curr = index; // keep going down till heap property is established while(2*curr + 1 &lt; heap.length){ const leftIndex = 2*curr+1; const rightIndex = 2*curr+2; const minChildIndex = (rightIndex &lt; heap.length &amp;&amp; heap[rightIndex] &lt; heap[leftIndex] ) ? rightIndex :leftIndex; if(heap[minChildIndex] &lt; heap[curr]){ // quick swap, if smaller of two children is smaller than the parent (min-heap) [heap[minChildIndex], heap[curr]] = [heap[curr], heap[minChildIndex]] curr = minChildIndex } else { break } } 我们可以对数组中的所有元素使用 percolateDown() 函数，按照堆属性将所有元素按正确顺序排列： function heapify(heap){ for(let i in heap){ percolateDown(heap, i) } return heap } 这样就为我们节省了一个额外的数组。但是我们能做些什么来改善所花费的时间吗？是的。如果你仔细观察，我们实际上是在做一些重复的工作。假设堆中有 n 个节点，其中 x 是叶节点，那么这意味着我们只需要对 n-x 个节点执行 percolateDown()，因为到那时最后 x 个节点将在正确的位置。 那么在堆的数组表示中，我们应该执行 percolateDown() 操作到哪个索引？ 直到最后一个节点的父节点所在的索引。因为一旦最后一个节点的父节点被过滤掉，它也会处理最后一个节点。所以： 如果数组长度为 n 最后一个节点的索引是：n-1 它的父节点的索引是：Math.floor((n-1) - 1 / 2) = Math.floor(n/2 - 1) function heapify(heap){ const last = Math.floor(heap.length/2 - 1); for(let i = 0; i &lt;= last; i++){ percolateDown(heap, i) } return heap } 时间和空间复杂度 查看 heappush() 和 heapop() 操作，很明显我们在尝试添加或删除键时正在遍历树的高度。由于堆是一棵平衡树，因此高度是 log(n)，其中 n 是节点总数。因此，对于堆的推送和弹出操作，时间复杂度为 O(log(n))。 heapify() 操作的时间复杂度可能看起来像 Onlog(n)，因为每次调用都需要 O(log(n))。这个观察结果对于推导 heapify() 的时间复杂度的上限是正确的，但是，渐近（平均）时间复杂度为 O(n)。更多细节在这里。就空间复杂度而言，它是恒定的，因为额外的空间仅被诸如 curr、leftIndex 等大小恒定的变量占用。 最大堆 如果我们有 minHeap 的实现，我们也可以轻松地将它用作最大堆。我们只需要确保在向堆添加值时我们插入键的负数。它将确保堆充当所有键的负数的最小堆，这相当于所有实际键的最大堆。例如： 假设我们有一个数组 const x = [23, 454, 54, 29]; 可以使用以下方法创建最小堆： const heap = []; for(let el of x) heappush(heap, el); // min value const min = heappop(heap) 最大堆可以使用 const heap = []; for(let el of x) heappush(heap, -el); // max value const max = -heappop(heap) ","link":"https://umeimmense.github.io/post/javascript-zhong-de-dui"},{"title":"JavaScript 中的稀疏数组与密集数组的区别？","content":"前言 JavaScript 中的数组非常易于使用。但是，你应该注意一个细微差别：某些数组中可能存在漏洞。 在这篇文章中，我将描述 JavaScript 中稀疏数组和密集数组之间的区别。此外，你将找到创建稀疏数组的常用方法。 密集数组 JavaScript 中的数组是一个对象，表示元素的有序集合。数组中的元素有一个确切的顺序。你可以使用索引访问数组的第 n 项。 const names = ['Batman', 'Joker', 'Bane']; console.log(names[0]); // logs 'Batman' console.log(names[1]); // logs 'Joker' console.log(names[2]); // logs 'Bane' console.log(names.length); // logs 3 names[0] 访问索引 0（第一个元素）处的数组项。 数组还有一个属性长度，它表示数组中的项数。在前面的示例中，names.length 为 3，因为数组中的元素个数为 3。 上面创建的名称数组是一个密集数组：这意味着它包含每个索引处的元素，从 0 开始，直到 names.length - 1。 我们定义这是一个函数 isDense(array) ，用于确定数组是否在每个索引处都有元素： function isDense(array) { for (let index = 0; index &lt; array.length; index++) { if (!(index in array)) { return false; } } return true; } const names = ['Batman', 'Joker', 'Bane']; console.log(isDense(names)); // logs true 其中 index in array 确定数组是否在索引位置有一个元素。 这是一个有趣的问题：JavaScript 中的所有数组都是密集的吗？或者当 isDense(array) 返回 false 时可能有数组？ 稀疏数组 有些情况下 JavaScript 数组中可能存在漏洞。这样的数组被命名为稀疏数组。 例如，如果你使用数组字面量但省略指示项就会创建了一个稀疏数组： const names = ['Batman', , 'Bane']; console.log(names[0]); // logs 'Batman' console.log(names[1]); // logs undefined console.log(names[2]); // logs 'Bane' console.log(isDense(names)); // logs false ['Batman', , 'Bane'] 数组文字创建一个稀疏数组，在 1 索引处有一个缺失。如果你访问这个位置的值——names[1]——它的计算结果是 undefined。 要明确检查特定索引处是否有空缺，你可以这样写index in names中： const names = ['Batman', , 'Bane']; // No hole console.log(0 in names); // logs true // Hole console.log(1 in names); // logs false 当然，如果你在稀疏数组上运行 isDense() 它将返回 false： const names = ['Batman', , 'Bane']; console.log(isDense(names)); // logs false 现在你对稀疏数组有所了解。但是创建稀疏数组的常用方法是什么？ 创建稀疏数组的方法 数组字面量 在使用数组字面量时省略一个值会创建一个稀疏数组（注意记录器数组中的空词）： const names = ['Batman', , 'Bane']; console.log(names); // logs ['Batman', empty, 'Bane'] Array() 构造函数 调用 Array(length) 或 new Array(length)（带有一个数字参数）会创建一个完全稀疏的数组： const array = Array(3); console.log(isDense(array)); // logs false console.log(array); // logs [empty, empty, empty] 删除操作符 在数组上使用 delete array[index]运算符时： const names = ['Batman', 'Joker', 'Bane']; delete names[1]; console.log(isDense(names)); // logs false console.log(names); // logs ['Batman', empty, 'Bane'] 最初，names数组是密集的。 但是执行 delete names[1]会删除索引 1 处的元素并使 names 数组变得稀疏。 增加length属性 如果你增加数组的长度属性，那么你也会在数组中创建空缺： const names = ['Batman', 'Joker', 'Bane']; names.length = 5; console.log(isDense(names)); // logs false console.log(names); // logs ['Batman', 'Joker', 'Bane', empty, empty] 最初names数组有3个元素，是一个密集数组。 但是，将names.length 增加到 5 个元素会在 3 和 4 个索引处创建 2 个孔。 附带说明一下，减少 length 属性不会创建稀疏数组，而是从数组末尾删除元素。 数组方法和稀疏数组 稀疏数组的一个问题是许多数组内置方法只是跳过稀疏数组中的空缺。 例如， array.forEach(eachFunc) 不会在孔上调用 eachFunc ： const names = ['Batman', , 'Bane']; names.forEach(name =&gt; { console.log(name); }); // logs 'Batman' // logs 'Bane' 以同样的方式 array.map(mapperFunc)、array.filter(predicateFunc) 和更多函数跳过这些空缺位置。如果你不小心创建了一个稀疏数组，可能很难理解为什么数组方法不能按预期工作。 总结 在 JavaScript 中，数组可以是密集的或稀疏的。 如果每个索引处都有从 0 开始直到 array.length - 1 的元素，则数组是密集的。否则，如果任何索引处至少缺少一项，则数组是稀疏的。 虽然你不会过多地处理稀疏数组，但你应该了解可以创建一个数组的情况： 跳过数组 [1, , 3] 中的值时 使用 Array(length) 时 使用delete array[index] 当增加 array.length 属性时 稀疏数组的问题在于某些 JavaScript 函数（如 array.forEach()、array.map() 等）在迭代数组项时会跳过空缺值。 拓展 稀疏数组在访问元素的速度上比密集数组慢 const arr = new Array(200000) arr[19999] = 88 console.time('using[]') arr[19999] console.timeEnd('using[]') // using[]: 0.031982421875ms const ddd = [...new Array(200000)] ddd[19999] = 88 console.time('using[]') ddd[19999] console.timeEnd('using[]') // using[]: 0.010009765625ms 具体原因是，对于稀疏数组 V8 引擎访问对象是使用 散列表模式的，该种模式在访问时需要计算一遍哈希值，所以会比较慢，但散列表对于空间利用来说，效率更高。而密集数组，它是申请一段连续的内存空间，访问时可以直接通过「索引」来访问，所以速度比较快。 ","link":"https://umeimmense.github.io/post/javascript-zhong-de-xi-shu-shu-zu-yu-mi-ji-shu-zu-de-qu-bie"},{"title":"JavaScript 中的 Trie：什么是前缀树？","content":"前言 我们已经在三篇文章中介绍了树数据结构的基础知识。如果你还没有读过这些，我强烈建议先阅读前三篇文章： 使用递归和迭代算法遍历二叉树 使用父指针遍历二叉树 将树遍历算法应用于 DOM 介绍 Trie 是树数据结构的一种变体。它也被称为前缀树或搜索树的变体。就像 n 叉树数据结构一样，trie 可以有 n 个来自单亲的孩子。通常，trie 中的所有节点都会存储一些字符。假设我们只处理英语单词，下面是一个简单的 trie 可能看起来像： 需要注意的事项： 我们正在尝试使用树来尽可能高效地表示英语单词。 在上图中，从根节点到任何绿色节点的路径表示一个英文单词。例如： NULL-&gt;C-&gt;A-&gt;T: CAT NULL-&gt;D-&gt;O: DO NULL-&gt;D-&gt;O-&gt;G: DOG NULL-&gt;D-&gt;A-&gt;R-&gt;K: DARK NULL-&gt;A: A NULL-&gt;A-&gt;N: AN 每个节点最多可以有 26 个子节点（如果我们只处理英文字母）。我们有一个 NULL 节点作为根节点，因为一个单词可以以 26 个字母中的任何一个开头，因此我们需要一个虚拟节点，它可以将任何潜在的第一个字母作为子节点。 绿色节点，本质上代表“词尾”，同时从根遍历到该节点。 实现节点 现在，让我们尝试提出 Trie 节点的表示。回到树节点，这就是我们呈现它的方式： function Node(value){ this.value = value this.left = null this.right = null } 因此，我们可以对 Trie 遵循类似的想法，同时确保它满足我们在介绍部分讨论的要求。要了解 Trie 节点的要求，让我们放大任何节点： 所以现在更有意义了。这是最终的代码： function Node(value){ this.value = value this.isEndOfWord = false // false by default, a green node means this flag is true this.children = {} // children are stored as Map, where key is the letter and value is a TrieNode for that letter } 实现 Trie 数据结构 我们可以使用一个简单的 ES6 类来表示： class Trie{ constructor(){ this.root = new Node(null) } insert(word){ // TODO } search(word){ // TODO } } 所以我们已经准备好了大概。作为初始化的一部分，每个trie 都会创建它自己的根节点（NULL）。那么我们可以实现这两个方法如下： insert(word)：我们可以将单词拆分为字母，并为每个字母创建一个 Node()。然后我们可以开始将这些 Trie 节点中的每一个链接到根节点，以插入单词。最后，我们将最后插入的节点的 isEndOfWord 属性标记为 true。 search(word)：我们可以将单词拆分为字母。然后我们可以从根开始一个一个地寻找这些字母中的每一个。如果我们能够按顺序找到所有字母，那么我们可以返回 true 否则 false。 让我们直观地理解这两个操作以获得更好的上下文： 首先insert(CAR)然后insert(CAN): 首先search(CAR)然后search(CAN): 实现如下： class Trie{ constructor(){ this.root = new Node(null) } insert(word){ let current = this.root // iterate through all the characters of word for(let character of word){ // if node doesn't have the current character as child, insert it if(current.children[character] === undefined){ current.children[character] = new Node(character) } // move down, to insert next character current = current.children[character] } // mark the last inserted character as end of the word current.isEndOfWord = true } search(word){ let current = this.root // iterate through all the characters of word for(let character of word){ if(current.children[character] === undefined){ // could not find this character in sequence, return false return false } // move down, to match next character current = current.children[character] } // found all characters, return true if last character is end of a word return current.isEndOfWord } } 使用 Trie const trie = new Trie(); // insert few words trie.insert(&quot;CAT&quot;); trie.insert(&quot;DOG&quot;); // search something trie.search(&quot;MAT&quot;) // false trie.search(&quot;DOG&quot;) // true 空间复杂度 在最坏的情况下，所有插入单词的每个字符都可以占用 Trie 中的单个节点。所以这意味着最坏的空间复杂度可以是 (W*n)，其中 W 是每个单词的平均字符数，n 是 Trie 中的单词总数。 时间复杂度 插入：插入一个有n个字符的单词，只需要遍历n个字符，所以时间复杂度为O(n) 搜索：与插入类似，我们只需要遍历单词的所有字符即可进行搜索。所以时间复杂度是 O(n)，其中 n 是单词中的字符数。 现在，想一想，你还能如何在庞大的单词列表中搜索某个单词？ -可能使用数组？时间复杂度为 O(m)，其中 m 是单词总数，这很糟糕。 如何使用Map（或 JavaScript 中的对象）？这会将时间复杂度降低到 O(1)，但是找到具有特定前缀的单词列表有多快？它将是 O(m)。 Trie 不仅将时间复杂度降低到 O(n)（n = 单词中的字符数），而且您还可以有效地搜索具有前缀的单词列表，这对于任何以上两种方法。 应用 自动完成和预先输入：如果您在文本框中键入内容，并且看到具有相同前缀的潜在搜索列表，即自动完成小部件，那么这可能是由后台的 Trie 处理的。同样，Typeahead 也可以使用 Trie 来实现。 拼写检查器：我们可以使用 trie 创建拼写检查器，即给定一个单词列表，我们可以检查给定单词的拼写是否正确。 IP 路由（最长前缀匹配）：Internet 由多个路由器节点组成，它们决定应该发送的目标数据包。 Internet 上的每个路由器都需要将数据包发送到由给定 IP 目的地决定的适当目标节点。但是每个路由器如何使用给定的 IP 地址决定下一个目标路由器呢？这个问题可以使用IP路由来解决。这是一篇深入探讨这个主题的好文章。 ","link":"https://umeimmense.github.io/post/javascript-zhong-de-trieshi-me-shi-qian-zhui-shu"},{"title":"JavaScript 将树遍历算法应用于 DOM","content":"前言 到目前为止，我们已经了解了一些二叉树遍历的方法： 使用递归和迭代算法遍历二叉树 使用父指针遍历二叉树 在本文中，我们将把这些知识用于 n 叉树，即 DOM。我们将看到如何使用各种 CSS 选择器定位 DOM 元素，而无需使用内置 API，如 getElementById、getElementsByClassname 或 querySelector/querySelectorAll。因此，本文将阐明这些 API 可能如何在幕后工作。 DOM 遍历 借用 使用递归和迭代算法遍历二叉树的思路，我们来得出DOM的前序遍历算法： function walkPreOrder(node){ if(!node) return // do something here console.log(node) for(let child of node.children){ walkPreOrder(child) } } 我们可以修改这个算法使之来返回一个迭代器： function* walkPreOrder(node){ if(!node) return // do something here yield node for(let child of node.children){ yield* walkPreOrder(child) } } // USAGE for(let node of walkPreOrder(root)){ console.log(node) } 我们可以使用任何广度优先或深度优先算法（在之前的文章中讨论过）来遍历 DOM。 我们还假设正在处理具有以下 HTML 的文档： &lt;html&gt; &lt;head&gt; &lt;title&gt;DOM selection algorithm&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img id=&quot;profile&quot; src=&quot;xyz.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 通过 ID 定位节点 function locateById(nodeId){ // iterate through all nodes in depth first (preOrder) fashion // return the node as soon as it's found for(let node of walkPreOrder(document.body)){ if(node.id === nodeId){ return node } } return null } 我们可以使用 locateById() 函数如下： const img = locateById('profile') // returns the image node 通过\bClassName 定位节点 浏览器提供 document.getElementsByClassName() API 来实现此结果。我们如何实现类似的东西： function locateAllByClassName(className){ const result = [] for(let node of walkPreOrder(document.body)){ if(node.classList.contains(className)){ result.push(node) } } return result } // USAGE const elements = locateAllByClassName('row') 浏览器如何优化选择查询 选择 DOM 节点是 Web 应用程序相当常见的操作。为同一个选择器多次遍历树似乎不是最佳选择。浏览器通过使用记忆优化选择。 查看 mozilla 解析器的源代码，即函数 startTag 的摘录： // ID uniqueness @IdType String id = attributes.getId(); if (id != null) { LocatorImpl oldLoc = idLocations.get(id); if (oldLoc != null) { err(&quot;Duplicate ID \\u201C&quot; + id + &quot;\\u201D.&quot;); errorHandler.warning(new SAXParseException( &quot;The first occurrence of ID \\u201C&quot; + id + &quot;\\u201D was here.&quot;, oldLoc)); } else { idLocations.put(id, new LocatorImpl(tokenizer)); } } 我们可以看到这些节点 ID 保存在一个简单的哈希映射中。我们可以使用类似的方法来确保对同一 ID 的重复查询不需要完全遍历，相反，我们可以从 hashMap 中查找并返回它。 以下是我们的解决方案： function getSelectors(){ const idLocations = {} const classLocations = {} // updated selector functions function locateById(nodeId){ if(idLocations.hasOwnProperty(nodeId)) return idLocations[nodeId] for(let node of walkPreOrder(document.body)){ if(node.id === nodeId){ idLocations[nodeId]= node //memoize return node } } idLocations[nodeId]= null // memoize return null } function locateAllByClassName(className){ if(classLocations.hasOwnProperty(className)) return classLocations[className] const result = [] for(let node of walkPreOrder(document.body)){ if(node.classList.contains(className)){ result.push(node) } } classLocations[nodeId]= result return result } return { locateById, locateAllByClassName } } // USAGE const {locateById, locateAllByClassName} = getSelectors(); const result = locateAllByClassName('row') // returns array of elements const img = locateById('profile') // returns an element, if found 处理更复杂的选择器 让我们尝试实现类似 element.querySelector 的方法。以下是 MDN 的描述： The querySelector() method of the Element interface returns the first element that is a descendant of the element on which it is invoked that matches the specified group of selectors. 样例 const firstRow = document.querySelector('.container .row:first-child') 在这种情况下，我们可以将任何 CSS 选择器传递给函数，它应该能够遍历 DOM 为我们找到该元素。让我们看看它是如何实现的： // given a selector and root node, find that selector within the root node function select(selector, root){ for(let node of walkPreOrder(root)){ if(node.matches(selector)){ return node } } return null; } function myQuerySelector(path, node){ // if path is empty, nothing to find if(path.length === 0) return null; // if node is not provided, let's assume user wants to search within document.body let root = node || document.body; const selector = path[0]; // if there's only one selector in the path, just traverse using select function above if(path.length === 1) return select(selector, root); // else, either the current node matches the first selector in path or not // if first selector matches with current node, look through it's children for subsequent selectors only // else, look through it's children for the whole path const newPath = root.matches(selector) ? path.slice(1): path; for(let child of root.children){ const ans = myQuerySelector(newPath, child); if(ans) return ans } // nothing found return null; } // USAGE: const firstRow = myQuerySelector([&quot;.container&quot;, &quot;.row&quot;]) myQuerySelectorAll 的实现（类似于 element.querySelectorAll）也遵循相同的方法，稍作修改： function selectAll(selector, root){ let result = [] for(let node of walkPreOrder(root)){ if(node.matches(selector)){ result.push(node) } } return result; } function myQuerySelectorAll(path, node){ let result = []; if(path.length === 0) return result; let root = node || document.body; const selector = path[0]; if(path.length === 1) return selectAll(selector, root); const newPath = root.matches(selector) ? path.slice(1): path; for(let child of root.children){ result = [...result, ...myQuerySelectorAll(newPath, child)] } return result; } 进阶 我们可以使用本文开头描述的递归前序遍历方法来克隆任何树。让我们看看我们如何使用它来克隆任何 DOM 树，类似于 element.cloneNode(true) 所做的： 通过创建具有相同 tagName 的新节点然后复制属性来创建源节点的克隆。 对源节点的所有子节点递归调用 cloneTree 方法，并将返回的节点作为子节点附加到克隆节点。 function cloneTree(node){ if(!node) return const clonedNode = document.createElement(node.tagName.toLowerCase()) const attributes = node.getAttributeNames() attributes.forEach(attribute =&gt; { clonedNode.setAttribute(attribute, node.getAttribute(attribute)) }) for(const child of node.children){ clonedNode.append(cloneTree(child)) } return clonedNode } ","link":"https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom"},{"title":"JavaScript 中的 Tree 使用父指针高效遍历","content":"前言 在本系列的第一部分中，我们研究了遍历二叉树的递归和迭代方法。 在实际应用中，树节点有一个父节点是很常见的：一个指向父节点的指针，因此也称为父指针。让我们以浏览器中的 DOM 为例。假设我们使用以下命令选择任何节点： const element = document.querySelector(&quot;#id&quot;) 在本文中，我们将研究如何使用这些父指针来提高遍历效率。我稍后会解释我所说的“更高效”是什么意思。在下一篇文章中，我们还将了解如何使用此处学到的经验教训从头开始创建 myQuery 库。 更新节点定义 首先，我们需要更新Node 函数 function Node(value){ this.value = value this.left = null this.right = null this.parent = null // added parent field } 现在让我们看看如何使用这个新的 Node 定义来创建一个类似的树，就像我们在上一篇文章中所做的那样。 const root = new Node(2) const left = new Node(1) root.left = left left.parent = root const right = new Node(3) root.right = right right.parent = root 我们只需要确保父指针指向父节点。这是我们使用上述代码获得的最终树的视觉参考： ##寻找后继节点 前序后继 假设每个节点都有一个parent指针，如何找出二叉树中任何节点的 前序 后继？ 让我们试着分析一下这个问题： 首先，我们在这里处理前序，这意味着我们正在寻找以下顺序： root -&gt; left -&gt; right 这意味着如果我们已经在当前节点，我们想寻找左子节点作为后继节点。 如果根本没有左子节点怎么办？那么在这种情况下，我们会寻找合适的节点，如果在有左子节点，那就是后继节点。 如果没有左子节点或右子节点，那么我们需要回溯（继续向上走向父节点）。我们一直回溯，直到通过它的右子节点到达父级（因为这意味着 前序 对于父级下的整个子树是完整的，根据 #1 的定义）。 最终算法实现就是这样： function preOrderSuccessor(node){ if(!node) return if(node.left) return node.left if(node.right) return node.right let parent = node.parent while(parent &amp;&amp; parent.right === node) { node = node.parent parent = parent.parent } if(!parent) return null // we backtracked till root, so no successor return parent.right } 可以根据下图更好的理解 中序后继 首先，我们在这里处理中序遍历，这意味着我们正在寻找以下顺序： root -&gt; left -&gt; right 如果我们在当前节点，并且它右边有右子节点，那么我们可以通过在右子树上找到最左边的节点来获得后继节点。 如果没有右子节点，那么我们需要回溯（向上移动）。我们一直向上移动，直到通过它的右子节点到达父节点，因为这意味着已经遍历了整个子树（根据 #1 中的定义）。 一旦我们找到最近的父节点，它是通过它的左子节点找到的，它就会作为后继节点返回。为什么？因为这意味着它是一个已经探索了左树的节点，所以根据 #1 中的定义，节点本身现在是后继节点。 实现如下： function inOrderSuccessor(node){ if(!node) return if(node.right){ let current = node.right while(current &amp;&amp; current.left) current = current.left return current } let parent = node.parent while(parent &amp;&amp; parent.right === node) { root = node.parent parent = parent.parent } if(!parent) return null return parent } 后序后继 首先，我们在这里处理后序遍历，这意味着我们正在寻找以下顺序： left -&gt; right -&gt; root 所以，如果我们在任何节点上，就意味着它的左右子树已经被访问过了。这意味着我们需要查看父级的继任者。 如果我们从它的右子节点到达父母，这意味着父母本身就是继任者，根据#1 中的定义 如果我们从它的左子节点到达父母，这意味着接下来要探索父母的右子节点（根据#1 中的定义）。所以现在我们需要简单地返回父节点右子节点中最左边的节点作为后继节点。 实现如下： function postOrderSuccessor(node){ if(!node) return let parent = node.parent if(!parent) return null if(parent.right === node). return parent let current = parent.right while(current &amp;&amp; (current.left || current.right)){ current = (current.left || current.right) } return current } 使用后继算法更好地遍历 为什么我们需要使用父指针来提出遍历算法呢？这是一个值得思考的问题，因为我们已经提出了遍历树的递归和迭代方法，而且不需要父指针。 我们这样做的原因是因为我们之前的方法增加了空间复杂性。如果你还记得上一篇文章中我们需要使用一个或两个堆栈（取决于遍历方法）来使任何遍历算法工作。即使在递归方法中，虽然我们不直接使用堆栈，但递归本身基于调用堆栈，因此那里也使用了隐藏的内存中堆栈。问题是这个堆栈的大小会随着我们树的深度而增加，因此这不是最好的解决方案，因为我们有办法在花费更少空间的情况下完成相同的任务。通过使用父指针，我们可以完全摆脱这些堆栈，为我们节省大量空间，即从 O(logN) 的空间复杂度（其中 N 表示平衡树的大小）到 O(1)。让我们看看如何实现。 前序遍历 对于 前序遍历，我们从树的根部开始。之后，我们可以使用上面的算法继续获取前序后继以遍历整棵树： function preOrder(root){ // first node console.log(root.value); let current = root while(true){ const next = preOrderSuccessor(current) if(!next) break // do something console.log(next.value) current = next } } 中序遍历 对于 中序遍历，起始节点将是树的最左侧节点。此后，我们可以使用上述算法继续获取后继以遍历整棵树： function inOrder(root){ // start at the left most node while(root &amp;&amp; root.left){ root = root.left } // first node console.log(root.value); let current = node while(true){ const next = inOrderSuccessor(current) if(!next) break // do something console.log(current.value) current = next } } 后序遍历 非常类似于上面的中序遍历的方法： function postOrder(root){ // start at the left most node while(root &amp;&amp; root.left){ root = root.left } // first node console.log(root.value); let current = node while(true){ const next = postOrderSuccessor(current) if(!next) break // do something console.log(current.value) current = next } } 进阶 如果每个节点都有一个父指针，你能想出算法来寻找前任（inOrder、preOrder 和 postOrder）吗？ ","link":"https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li"},{"title":"JavaScript 中的 Tree","content":"前言 Tree是一种有趣的数据结构。它在各个领域都有广泛的应用。例如： DOM 是一种Tree状数据结构 我们操作系统中的目录和文件可以表示为Tree 家庭层次结构可以表示为Tree。 Tree的许多变体（如堆、BST 等）可用于解决与调度、图像处理、数据库等相关的问题。许多复杂的问题乍一看似乎与Tree无关，但可以被表示为一个Tree的问题。我们也会（在本系列的后面部分）解决这些问题，从而了解Tree如何使看似复杂的问题更容易理解和解决。 简介 二叉树实现节点非常简单 function Node(value){ this.value = value this.left = null this.right = null } // usage const root = new Node(2) root.left = new Node(1) root.right = new Node(3) 所以这几行代码将为我们创建一个二叉树，如下所示： 2 / \\ / \\ 1 3 / \\ / \\ null null null null 遍历 让我们从尝试遍历这些连接的树节点（或一棵树）开始。正如我们可以遍历数组一样，如果我们也可以“遍历”树节点。然而，树不是像数组那样的线性数据结构，所以遍历这些的方法不止一种。我们可以将遍历方法大致分为以下几类： 广度优先遍历 深度优先遍历 广度优先遍历（BFS） 在这种方法中，我们逐层遍历树。我们将从根开始，然后覆盖它的所有子级，然后覆盖所有 2 级子级，依此类推。例如对于上面的树，遍历会导致这样的结果： 2 / \\ / \\ 1 3 / \\ / \\ null null null null 2，1，3 下面是一个稍微复杂的树的插图，使这更容易理解： 为了实现这种形式的遍历，我们可以使用队列（先进先出）数据结构。以下是整个算法的过程： 初始化一个包含 root 的队列 从队列中删除第一项 将弹出项的左右节点推入队列 重复步骤 2 和 3，直到队列为空 下面是这个算法在实现后的样子： function walkBFS(root){ if(root === null) return const queue = [root] while(queue.length){ const item = queue.shift() // do something console.log(item) if(item.left) queue.push(item.left) if(item.right) queue.push(item.right) } } 我们可以稍微修改上面的算法实现为： function walkBFS(root){ if(root === null) return const queue = [root], ans = [] while(queue.length){ const len = queue.length, level = [] for(let i = 0; i &lt; len; i++){ const item = queue.shift() level.push(item) if(item.left) queue.push(item.left) if(item.right) queue.push(item.right) } ans.push(level) } return ans } 深度优先遍历（DFS） 在 DFS 中，我们取一个节点并继续探索它的子节点，直到深度耗尽为止。它可以通过以下方式之一完成： root node -&gt; left node -&gt; right node // pre-order traversal left node -&gt; root node -&gt; right node // in-order traversal left node -&gt; right node -&gt; root node // post-order traversal 所有这些遍历技术都可以递归和迭代实现。让我们进入实现细节： 前序遍历(Pre-Order traversal) 分析 root node -&gt; left node -&gt; right node 技巧: 我们可以使用这个简单的技巧来手动找出任何树的前序遍历：从根节点开始遍历整棵树，保持自己在左边。 实现 递归 function walkPreOrder(root){ if(root === null) return // do something here console.log(root.val) // recurse through child nodes if(root.left) walkPreOrder(root.left) if(root.right) walkPreOrder(root.right) } 迭代 前序遍历的迭代方法与 BFS 非常相似，不同之处在于我们使用堆栈而不是队列，并且我们首先将右节点推入堆栈： function walkPreOrder(root){ if(root === null) return const stack = [root] while(stack.length){ const item = stack.pop() // do something console.log(item) // Left child is pushed after right one, since we want to print left child first hence it must be above right child in the stack if(item.right) stack.push(item.right) if(item.left) stack.push(item.left) } } 中序遍历(In-Order traversal) 分析 下面是一棵树的中序遍历的过程： left node -&gt; root node -&gt; right node 技巧 我们可以使用这个简单的技巧来手动找出任何树的中序遍历：在树的底部水平放置一个平面镜，并获取所有节点的投影 实现 递归function walkInOrder(root){ if(root === null) return if(root.left) walkInOrder(root.left) // do something here console.log(root.val) if(root.right) walkInOrder(root.right) } - 迭代 这个算法乍一看可能有点神秘。但它相当直观。让我们这样看：在中序遍历中，最左边的孩子节点首先被打印，然后是根，然后是孩子节点。所以首先想到的是想出这样的东西： ```javascript const curr = root while(curr){ while(curr.left){ curr = curr.left // get to leftmost child } console.log(curr) // print it curr = curr.right // now move to right child } 在上述方法中，我们无法回溯，即返回导致最左侧节点的父节点。所以我们需要一个堆栈来记录这些。因此，我们修订后的方法可能如下所示： const stack = [] const curr = root while(stack.length || curr){ while(curr){ stack.push(curr) // keep recording the trail, to backtrack curr = curr.left // get to leftmost child } const leftMost = stack.pop() console.log(leftMost) // print it curr = leftMost.right // now move to right child } 现在我们可以使用上面的方法来制定最终的迭代算法： function walkInOrder(root){ if(root === null) return const stack = [] let current = root while(stack.length || current){ while(current){ stack.push(current) current = current.left } const last = stack.pop() // do something console.log(last) current = last.right } } 后序遍历（Post-Order traversal） 分析 下面是一棵树的中序遍历的过程： left node -&gt; right node -&gt; root node 技巧 对于任何树的快速手动后序遍历：一个接一个地提取所有最左边的孩子节点。 实现 让我们深入研究这种遍历的实际实现。 递归 function walkPostOrder(root){ if(root === null) return if(root.left) walkPostOrder(root.left) if(root.right) walkPostOrder(root.right) // do something here console.log(root.val) } 迭代 我们已经有了用于前序遍历的迭代算法。我们可以用那个吗？因为后序遍历似乎只是前序遍历的反向。让我们来看看： // PreOrder: root -&gt; left -&gt; right // Reverse of PreOrder: right -&gt; left -&gt; root // But PostOrder is: left -&gt; right -&gt; root 从上面分析可见有细微的差别。我们可以通过稍微修改我们的 前序遍历算法然后反转它应该给出 后序遍历结果来适应这一点。总体算法将是： // record result using root -&gt; right -&gt; left // reverse result left -&gt; right -&gt; root 使用与上述迭代前序遍历算法类似的方法，使用临时堆栈。 唯一的区别是 root -&gt; right -&gt; left 而不是 root -&gt; left -&gt; right 结果将遍历序列记录在一个array 结果的反转就是后序遍历 function walkPostOrder(root){ if(root === null) return [] const tempStack = [root], result = [] while(tempStack.length){ const last = tempStack.pop() result.push(last) if(last.left) tempStack.push(last.left) if(last.right) tempStack.push(last.right) } return result.reverse() } ","link":"https://umeimmense.github.io/post/javascript-zhong-de-tree"},{"title":"JavaScript 引擎如何提升其运行时的性能？","content":"前言 JavaScript 是一项令人印象深刻的技术。不是因为它设计得特别好，也不是因为世界上几乎所有可以访问互联网的设备都执行 JavaScript 程序。相反，JavaScript 令人印象深刻，是因为它的几乎每一个特性都使它成为优化的噩梦，但是它速度很快。 javascript 为什么会执行速度很快呢？这就是我们需要去深入探究的问题。 在本文中，我们将仔细研究不同 JavaScript 引擎用于实现良好运行时性能的一些技术，在研究过程中省略了一些细节，并简化了事情。本文的目标不是让您了解事物的确切运作方式，而是让您了解并理解引擎如何提升其运行时的一些基本知识。 执行模型 当您的浏览器下载 JavaScript 时，其首要任务是让它尽快运行。它通过将代码转换为字节码、虚拟机指令，然后将其移交给理解如何执行它们的解释器或虚拟机来实现。 您可能会问为什么浏览器会将 JavaScript 转换为虚拟机指令而不是实际的机器指令？这是个好问题。事实上，直到最近，V8（Chrome 的 JavaScript 引擎）还一直在做直接转换为机器指令的工作。 特定编程语言的虚拟机通常是更容易编译的目标，因为它与源语言的关系更密切。实际的机器有一个更通用的指令集，因此需要更多的工作来翻译编程语言以很好地处理这些指令。这种困难意味着编译需要更长的时间，同时也意味着 JavaScript 开始执行需要更长的时间。 例如，理解 JavaScript 的虚拟机也可能理解 JavaScript 对象。因此，执行像 object.x 这样的语句所需的虚拟指令可能是一两条指令。一台不了解 JavaScript 对象如何工作的实际机器需要更多的指令来确定 .x 在内存中的位置以及如何获取它。 虚拟机的问题在于它是虚拟的, 它是不存在的。指令不能直接执行，必须在运行时解释。解释代码总是比直接执行代码慢。 这里有一个问题需要权衡。需要在更快的编译时间与更快的运行时间中做一个选择。在许多情况下，更快的编译是一个很好的权衡。用户不太可能关心单个按钮的点击是否需要 20 或 40 毫秒的执行时间，尤其是当按钮只被按下一次时。快速编译 JavaScript，即使生成的代码执行速度较慢，也会让用户更快地查看页面并与页面交互。 有些情况在计算上是昂贵的。诸如游戏、语法高亮之类的场景。在这种情况下，编译和执行机器指令的时间加起来可能会减少总执行时间。那么 JavaScript 是如何处理这些情况的呢？ 经常被执行的代码 每当 JavaScript 引擎检测到某个函数执行了很多次时，它就会将该函数交给优化编译器。该编译器将虚拟机指令翻译成实际的机器指令。更重要的是，由于该函数已经运行了多次，优化编译器可以根据之前的运行做出一些假设。换句话说，它可以执行推测优化以生成更快的代码。 如果这些推测后来被证明是错误的，会发生什么？ JavaScript引擎可以简单地删除错误的函数，并还原为使用未优化版本。一旦该函数再运行几次，它就可以尝试再次将其传递给优化编译器，这一次它会提供更多可用于推测优化的信息。 既然我们知道频繁运行的函数在优化过程中使用来自先前执行的信息，接下来要探索的是这是什么类型的信息。 翻译问题 JavaScript 中的几乎所有东西都是对象。不幸的是，JavaScript 对象很难让机器处理。让我们看看下面的代码： function addFive(obj) { return obj.method() + 5; } 将函数转换为机器指令非常简单，就像从函数返回一样。但是机器不知道对象是什么，比如访问obj的method属性需要怎么翻译呢？ 如果知道 obj 是什么样子会很有帮助，但在 JavaScript 中我们永远无法确定。任何对象都可以添加或删除方法属性。即使method确实存在，我们实际上也不能确定它是否是一个函数，更不用说调用它之后的返回值了。 让我们尝试将上述代码转换为没有对象的 JavaScript 子集，来了解转换为机器指令可能是什么样的。 首先，我们需要一种表示对象的方法。我们还需要一种从其中检索值的方法。在机器代码中支持数组是比较的，所以我们可能会使用这样的表示： // An object like { method: function() {} } // could be represented as: // [ [ &quot;method&quot; ], // property names // [ function() {} ] ] // property values function lookup(obj, name) { for (var i = 0; i &lt; obj[0].length; i++) { if (obj[0][i] === name) return i; } return -1; } 参考上述的表示，我们可以尝试对 addFive 进行一个简单的实现 function addFive(obj) { var propertyIndex = lookup(obj, &quot;method&quot;); var property = propertyIndex &lt; 0 ? undefined : obj[1][propertyIndex]; if (typeof(property) !== &quot;function&quot;) { throw NotAFunction(obj, &quot;method&quot;); } var callResult = property(/* this */ obj); return callResult + 5; } 当然，这在 obj.method() 返回的不是数字的情况下不能运行，所以我们需要稍微调整一下实现： function addFive(obj) { var propertyIndex = lookup(obj, &quot;method&quot;); var property = propertyIndex &lt; 0 ? undefined : obj[1][propertyIndex]; if (typeof(property) !== &quot;function&quot;) { throw NotAFunction(obj, &quot;method&quot;); } var callResult = property(/* this */ obj); if (typeof(callResult) === &quot;string&quot;) { return stringConcat(callResult, &quot;5&quot;); } else if (typeof(callResult !== &quot;number&quot;) { throw NotANumber(callResult); } return callResult + 5; } 这是能运行的，但我希望很明显，如果我们能提前知道 obj 的结构是什么，以及方法的类型是什么，那么这段代码可以跳过几个步骤。 隐藏类 主流的 JavaScript 引擎都以某种方式跟踪对象是什么样的呢？在 Chrome 中，这个概念被称为隐藏类。 让我们从以下代码片段开始： var obj = {}; // empty object obj.x = 1; // shape has now changed to include a `x` property obj.toString = function() { return &quot;TODO&quot;; }; // shape changes delete obj.x; // shape changes again 如果我们将其转换为机器指令，我们将如何在添加和删除新属性时跟踪对象的样子？如果我们使用上一个示例将对象表示为数组的想法，它可能看起来像这样： var emptyObj__Class = [ null, // No parent hidden class [], // Property names [] // Property types ]; var obj = [ emptyObj__Class, // Hidden class of `obj` [] // Property values ]; var obj_X__Class = [ emptyObj__Class, // Contains same properties as empty object [&quot;x&quot;], // As well as one property called `x` [&quot;number&quot;] // Where `x` is a number ]; obj[0] = obj_X__Class; // Shape changes obj[1].push(1); // value of `x` var obj_X_ToString__Class = [ obj_X__Class, // Contains same properties as previous shape [&quot;toString&quot;], // And one property called `toString` [&quot;function&quot;] // Where `toString` is a function ]; obj[0] = obj_X_ToString__Class; // shape change obj[1].push(function() { return &quot;TODO&quot;; }); // `toString` value var obj_ToString__Class = [ null, // Starting from scratch when deleting `x` [&quot;toString&quot;], [&quot;function&quot;] ]; obj[0] = obj_ToString__Class; obj[1] = [obj[1][1]]; 如果我们要生成这样的虚拟机指令，我们现在就有了一种方法来跟踪对象在任何给定时间的样子。然而，这本身并不能真正帮助我们。我们需要将这些信息存储在有价值的地方。 内联缓存 每当 JavaScript 代码对对象执行属性访问时，JavaScript 引擎都会将该对象的隐藏类以及查找结果（属性名称到索引的映射）存储在缓存中。这些缓存被称为内联缓存，它们有两个重要目的： 在执行字节码时，如果所涉及的对象具有缓存中的隐藏类，它们会加速属性访问。 在优化期间，它们包含有关访问对象属性时所涉及的对象类型的信息，这有助于优化编译器生成特别适合这些类型的代码。 内联缓存对它们存储信息的隐藏类的数量有限制。这可以保留内存，但也确保在缓存中执行查找速度很快。如果从内联缓存中检索索引比从隐藏类中检索索引花费的时间更长，则缓存没有任何用处。 据我所知， Chrome在中，内联缓存最多会跟踪 4 个隐藏类。在此之后，内联缓存将被禁用，信息将存储在全局缓存中。全局缓存的大小也有限制，一旦达到限制，新条目将覆盖旧条目。 为了最好地利用内联缓存并帮助优化编译器，应该尝试编写仅对单一类型的对象执行属性访问的函数。不仅如此，生成的代码的性能将是次优的 内联 一种单独且重要的优化是内联。简而言之，这种优化用被调用函数的实现代替了函数调用。举个例子： function map(fn, list) { var newList = []; for (var i = 0; i &lt; list.length; i++) { newList.push(fn(list[i])); } return newList; } function incrementNumbers(list) { return map(function(n) { return n + 1; }, list); } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 内联后，代码最终可能看起来像这样： function incrementNumbers(list) { var newList = []; var fn = function(n) { return n + 1; }; for (var i = 0; i &lt; list.length; i++) { newList.push(fn(list[i])); } return newList; } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 这样做的一个好处是删除了函数调用。更大的好处是 JavaScript 引擎现在可以更深入地了解函数的实际作用。基于这个新版本，JavaScript 引擎可能会决定再次执行内联： function incrementNumbers(list) { var newList = []; for (var i = 0; i &lt; list.length; i++) { newList.push(list[i] + 1); } return newList; } incrementNumbers([1, 2, 3]); // returns [2, 3, 4] 另一个函数调用已被删除。更重要的是，优化器现在可能会推测 incrementNumbers 只会以数字列表作为参数被调用。它还可能决定内联 incrementNumbers([1, 2, 3]) 调用本身，并发现 list.length 为 3，这又可能导致： var list = [1, 2, 3]; var newList = []; newList.push(list[0] + 1); newList.push(list[1] + 1); newList.push(list[2] + 1); list = newList; 简而言之，内联可以实现跨函数边界无法执行的优化。 但是，可以内联的内容是有限的。由于代码重复，内联会导致更大的函数，这需要额外的内存。 JavaScript 引擎对一个函数在完全跳过内联之前可以达到的大小有一个预算。 一些函数调用也很难内联。特别是当一个函数作为参数传入时。 此外，作为参数传递的函数很难内联，除非它总是同一个函数。虽然这可能会让您觉得这是一件奇怪的事情，但由于内联，最终可能会出现这种情况。 结论 JavaScript 引擎有许多提高运行时性能的技巧，比这里介绍的要多得多。但是，本文中描述的优化适用于大多数浏览器，并且很容易验证它们是否被应用。因此，当我们尝试提高 Elm 的运行时性能时，我们将主要关注这些优化。 参考 What’s up with monomorphism Shapes and inline caches Optimizing prototypes ","link":"https://umeimmense.github.io/post/javascript-yin-qing-ru-he-ti-sheng-qi-yun-xing-shi-de-xing-neng"},{"title":"7 个可能需要的自定义 React Hook","content":"前言 本文主要编制了一份清单，列出了在项目中可能会需要用到的的七个Hooks。 1. useToggle 这个hook很常见，它用于在 true 和 false 之间切换布尔值。当我们想要显示/隐藏模式或打开/关闭侧边菜单时，它很有用。这个hook的基本版本如下所示： 实现v1 // useToggle.jsx import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); return [state, toggle]; }; export default useToggle; 案例1 import useToggle from './useToggle'; const App = () =&gt; { const [show, toggleShow] = useToggle(); return ( &lt;Modal show={show} onClose={toggleShow}&gt; &lt;h1&gt;Hello there&lt;/h1&gt; &lt;/Modal&gt; ); } 当我们想要显示/隐藏表中一行的模式时，可以稍微修改此hook以用于用例。我添加了一个 customToggle 方法，该方法将值设置为给定值，而不是切换先前的状态值。 实现v2 // useToggle.jsx modified import { useState, useCallback } from 'react'; const useToggle = (initialValue = false) =&gt; { const [state, setState] = useState(initialValue); const toggle = useCallback(() =&gt; { setState((state) =&gt; !state); }, []); const customToggle = useCallback((value) =&gt; { setState(value); }, []); return [state, toggle, customToggle]; }; export default useToggle; 案例2 假设我们在一个表格中有一堆行，我们想提供一个删除行的选项。单击删除按钮应打开一个确认模式。 对于这种类型的功能，我们需要状态中的两个变量。首先，保存一个布尔值来确定是否显示删除确认模式，其次保存必须显示删除模式的行 ID。 使用这个hook，我们可以用一个状态变量来完成。这是如何做到的： import useToggle from './useToggle'; // initial data const rows = [ { id: 1, name: 'John' }, { id: 2, name: 'Doe' } ]; const App = () =&gt; { // using hook const [delModal, toggleDelModal, setDelModalCustom] = useToggle(); return ( &lt;div&gt; &lt;table&gt; {rows.map(row =&gt; ( &lt;tr&gt; &lt;td&gt;{row.id}&lt;/td&gt; &lt;td&gt;{row.name}&lt;/td&gt; &lt;td onClick={() =&gt; setDelModalCustom(row.id)}&gt;Delete&lt;/td&gt; &lt;/tr&gt; ))} &lt;/table&gt; &lt;DeleteModal show={Boolean(delModal)} onClose={toggleDelModal} itemToDelete={delModal} // it will hold the current row id &gt; &lt;h1&gt; Are you sure you want to delete row with id {delModal} &lt;/h1&gt; &lt;/DeleteModal&gt; &lt;/div&gt; ); } 2. usePageBottom 使用此hook，你可以确定用户是否已滚动到页面底部。非常适合无限滚动的应用程序，当用户滚动到页面底部时，你需要获取更多数据。 // usePageBottom.jsx import { useState, useEffect } from 'react'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = () =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }; // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 案例 import usePageBottom from './usePageBottom'; const App = (props) =&gt; { // hook usage const scrolledBottom = usePageBottom(); return ( &lt;div className=&quot;App&quot; style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 节流版本（可选） 减少像窗口滚动事件这样多次触发的事件的通知是最佳实践，我们可以使用节流设置事件侦听器。我正在使用 lodash 的throttle；你也可以使用去debounce。 // usePageBottom with throttle import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const usePageBottom = () =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const offsetHeight = document.documentElement.offsetHeight; const innerHeight = window.innerHeight; const scrollTop = document.documentElement.scrollTop; // if current scroll from bottom is less than equal to 10px const reachingBottom = offsetHeight - (innerHeight + scrollTop) &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on window scroll useEffect(() =&gt; { window.addEventListener('scroll', handleScroll); return () =&gt; { window.removeEventListener('scroll', handleScroll); }; }, [handleScroll]); return reachedBottom; } 3. useElementBottom 就像页面底部一样，我们也可以确定用户是否已经滚动到元素的底部。在这个hook中，传递了对元素的引用，因此我们可以使用元素的高度和当前滚动位置来确定元素是否滚动到底部。 // useElementBottom.jsx import { useState, useEffect, useMemo } from 'react'; import { throttle } from 'lodash'; const useElementBottom = (element) =&gt; { const [reachedBottom, setReachedBottom] = useState(false); // event handler for determining if the user reached bottom const handleScroll = useMemo(() =&gt; { return throttle(() =&gt; { const { current } = element; // current holds the reference to element // if current scroll from bottom is less than equal to 10px const scrollBottom = current.scrollHeight - current.scrollTop - current.clientHeight; const reachingBottom = scrollBottom &lt;= 10; setReachedBottom(reachingBottom); }, 1000); }, []); // effect for binding event listener on element scroll useEffect(() =&gt; { const { current } = element; current.addEventListener('scroll', handleScroll); return () =&gt; current.removeEventListener('scroll', handleScroll); }, []); return reachedBottom; }; export default useElementBottom; 案例 import useElementBottom from './useElementBottom'; const App = (props) =&gt; { const element = useRef(); // hook usage const scrolledBottom = useElementBottom(element); return ( &lt;div ref={element} style={{ height: '150vh' }}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;p&gt;Scrolled to bottom {scrolledBottom}&lt;/p&gt; &lt;/div&gt; ); } 4. usePrevious 我们可以制作一个自定义hook来获取 prop 或 state 的先前值。使用 React 类组件，可以使用 componentDidUpdate 生命周期来获取之前的 prop 和 state 值。对于功能组件，我们可以使用自定义hook来完成，如下所示： // usePrevious.jsx import { useEffect, useRef } from 'react'; const usePrevious = (value) =&gt; { const ref = useRef(); // store current value in ref useEffect(() =&gt; { ref.current = value; }, [value]); // return previous value (happens before update in useEffect above) return ref.current; }; export default usePrevious; 我们使用 useRef hook来存储先前的值。我们的hook在 useEffect 中更新引用对象之前返回先前的值。 import usePrevious from './usePrevious'; const App = () =&gt; { const [count, setCount] = useState(0); const prevCount = usePrevious(count); return ( &lt;div&gt; &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; ); } 5. useWindowSize 这个hook返回窗口的宽度和高度。我们在调整窗口大小时设置了一个受限制的 set 事件侦听器，以便我们每次都能获得正确的宽度和高度。 // useWindowSize import { useState, useEffect, useCallback } from 'react'; import { throttle } from 'throttle'; const useWindowSize = () =&gt; { const [size, setSize] = useState({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); // throttled set listener that runs on window resize const throttledSetResizeListner = useCallback( throttle(() =&gt; { // set size in state setSize({ innerWidth: window.innerWidth, innerHeight: window.innerHeight, }); }, 1000), [] ); // effect for binding resize event on window useEffect(() =&gt; { // add throtelled set window resize event listener window.addEventListener('resize', throttledSetResizeListner); // remove throttled set window resize event listener return () =&gt; window.removeEventListener('resize', throttledSetResizeListner); }, [throttledSetResizeListner]); return size; }; export default useWindowSize; 案例 当你想根据窗口的宽度或高度在你的 JS 代码中做一些事情时，它很有用。 import useWindowSize from './useWindowSize'; const App = () =&gt; { const { innerWidth, innerHeight } = useWindowSize(); return ( &lt;div&gt; {innerWidth &lt;= 768 ? 'I am on small screen' : 'I am on large screen'} &lt;/div&gt; ); } 6. useEventListener 使用此hook可以轻松地将事件侦听器绑定到窗口或窗口元素。在hook的effect中，我们检查元素是否是来自 useRef 的引用。如果没有，我们将事件侦听器添加到全局窗口对象。 import { useEffect } from 'react'; const useEventListener = (event, handler, referencedElement) =&gt; { // effect for binding event handler to the element useEffect(() =&gt; { const element = referencedElement?.current || window; const isSupported = element &amp;&amp; element.addEventListener; if (!isSupported) return; // bind event to the element element.addEventListener(event, handler); return () =&gt; element.removeEventListener(event, handler); }, [referencedElement, event, handler]); return; }; export default useEventListener; import useEventListener from './useEventListener'; const App = (props) =&gt; { const element = useRef(); useEventListener('mouseover', handler, element); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div ref={element}&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 我们还可以使用相同的hook将事件添加到窗口 import useEventListener from './useEventListener'; const App = (props) =&gt; { // adding event listener on window scroll useEventListener('scroll', handler); const handler =&gt; () =&gt; { console.log('Event triggered'); } return ( &lt;div&gt; &lt;h1&gt;This is app&lt;/h1&gt; &lt;div&gt; ); } 7. useLocalStorageState 有时，可能需要在本地存储和状态之间同步一个值。这个hook的作用完全一样。我们正在使用 useState 并检查指定的键是否在本地存储中具有某个值，以便我们可以将其用作初始值。这允许我们在页面刷新时保持值与状态同步。 // useLocalStorageState import { useState, useEffect } from 'react'; const useLocalStorageState = (key, defaultValue) =&gt; { const [value, setValue] = useState(() =&gt; { let val; try { // if there is a value in local storage for given key, set it as initial state val = JSON.parse(localStorage.getItem(key) || String(defaultValue)); } catch (error) { // otherwise, set default value as initial state val = defaultValue; } return val; }); // effect to update local storage when state changes useEffect(() =&gt; { localStorage.setItem(key, JSON.stringify(value)); }, [value]); return [value, setValue]; }; export default useLocalStorageState; 当值更新时，会运行一个effect ，更新本地存储中的值。 案例 假设你想在本地存储中存储用户主题首选项 import useLocalStorageState from './useLocalStorageState'; const App = (props) =&gt; { // setting default theme to light const [theme, setTheme] = useLocalStorageState('theme', 'light'); return ( &lt;div&gt; &lt;p&gt;Current theme is {theme}&lt;/p&gt; &lt;button onClick={() =&gt; setTheme('dark')}&gt; Change theme to dark &lt;/button&gt; &lt;/div&gt; ); } 当你点击更改主题按钮时，状态和本地存储中的值都会更新。页面刷新后，你将获得存储在本地存储中的最后一个值。 结语 感谢你阅读到最后。我希望这些自定义hook对你有用。 ","link":"https://umeimmense.github.io/post/ke-neng-xu-yao-de-7-ge-zi-ding-yi-react-hook"},{"title":"10个常用的 JavaScript 使用技巧","content":"前言 编写简短、简洁和干净的 JavaScript 代码的技巧😎 JavaScript 有很多很酷的特性，大多数初学者和中级开发人员都不知道。本节挑选了 10 个在日常 JavaScript 项目中经常使用的技巧。 1. 有条件的向对象中添加属性 我们可以使用扩展运算符 ... 来有条件地向 JavaScript 对象快速添加属性。 const condition = true; const person = { id: 1, name: 'John Doe', ...(condition &amp;&amp; { age: 16 }), }; 如果每个操作数的计算结果都为true， &amp;&amp; 运算符将返回最后计算的表达式。因此返回一个对象 { age: 16 }，然后将其作为 person 对象的一部分。 如果条件为 false，则 JavaScript 将执行以下操作： const person = { id: 1, name: 'John Doe', ...(false), // evaluates to false }; // spreading false has no effect on the object console.log(person); // { id: 1, name: 'John Doe' } 2. 检查一个属性是否存在于一个对象中 我们可以使用in关键字来检查 JavaScript 对象中是否存在属性 const person = { name: 'John Doe', salary: 1000 }; console.log('salary' in person); // returns true console.log('age' in person); // returns false 3. 对象中的动态属性名称 使用动态键设置对象属性很简单。只需使用 ['key_name'] 符号添加属性 const dynamic = 'flavour'; var item = { name: 'Biscuit', [dynamic]: 'Chocolate' } console.log(item); // { name: 'Biscuit', flavour: 'Chocolate' } 同样的技巧也可用于使用动态键引用对象属性： const keyName = 'name'; console.log(item[keyName]); // returns 'Biscuit' 4. 使用动态键进行对象解构 你可能知道你可以解构一个变量并立即用 : 符号重命名它。但是你知道当你不知道键名或键名是动态的时，你也可以解构对象的属性吗？ 首先，让我们看看如何在解构（用别名解构）时重命名变量。 const person = { id: 1, name: 'John Doe' }; const { name: personName } = person; console.log(personName); // returns 'John Doe' 现在，让我们使用动态键来解构属性： const templates = { 'hello': 'Hello there', 'bye': 'Good bye' }; const templateName = 'bye'; const { [templateName]: template } = templates; console.log(template) // returns 'Good bye' 5. ?? 运算符 这 ??当你要检查变量是 null 还是 undefined 时，运算符很有用。当其左侧操作数为空或未定义时，它返回右侧操作数，否则返回其左侧操作数。 const foo = null ?? 'Hello'; console.log(foo); // returns 'Hello' const bar = 'Not null' ?? 'Hello'; console.log(bar); // returns 'Not null' const baz = 0 ?? 'Hello'; console.log(baz); // returns 0 在第三个示例中，返回 0 是因为即使 0 在 JavaScript 中被认为是假的，但它不是 null 或未定义的。你可能认为我们可以使用 ||运算符在这里，但这两者之间存在差异： const cannotBeZero = 0 || 5; console.log(cannotBeZero); // returns 5 const canBeZero = 0 ?? 5; console.log(canBeZero); // returns 0 6. ?. 可选链 我们都可能曾经遇到过TypeError：无法读取 null 的属性“foo”之类的错误。这对每个 JavaSript 开发人员来说都是头疼的问题。引入了可选链就是为了解决这个问题。让我们来看看： const book = { id:1, title: 'Title', author: null }; // normally, you would do this console.log(book.author.age) // throws error console.log(book.author &amp;&amp; book.author.age); // returns null (no error) // with optional chaining console.log(book.author?.age); // returns undefined // or deep optional chaining console.log(book.author?.address?.city); // returns undefined 你还可以使用具有以下功能的可选链： const person = { firstName: 'Haseeb', lastName: 'Anwar', printName: function () { return `${this.firstName} ${this.lastName}`; }, }; console.log(person.printName()); // returns 'Haseeb Anwar' console.log(persone.doesNotExist?.()); // returns undefined 7. 使用 !! 的布尔转换符 这 !!运算符可用于将表达式的结果快速转换为布尔值 true 或 false。就是这样： const greeting = 'Hello there!'; console.log(!!greeting) // returns true const noGreeting = ''; console.log(!!noGreeting); // returns false 8. 字符串和整数转换 使用 + 运算符快速将字符串转换为数字，如下所示： const stringNumer = '123'; console.log(+stringNumer); // returns integer 123 console.log(typeof +stringNumer); // returns 'number' 要将数字快速转换为字符串，请使用 + 运算符后跟空字符串 &quot;&quot;： const myString = 25 + ''; console.log(myString); // returns '25' console.log(typeof myString); // returns 'string' 这些类型转换非常方便，但它们的清晰度和代码可读性较差。因此，在生产中使用它们之前，你可能需要考虑一下。不过可以用才code golf中。 9. 检查数组中的假值 你熟悉 filter、some 和 every 数组方法。但你也应该知道，你可以仅使用布尔方法来测试真值： const myArray = [null, false, 'Hello', undefined, 0]; // filter falsy values const filtered = myArray.filter(Boolean); console.log(filtered); // returns ['Hello'] // check if at least one value is truthy const anyTruthy = myArray.some(Boolean); console.log(anyTruthy); // returns true // check if all values are truthy const allTruthy = myArray.every(Boolean); console.log(allTruthy); // returns false 这是它的工作原理。众所周知，这些数组方法采用回调函数，因此我们将布尔值作为回调函数传递。 Boolean 本身接受一个参数并根据参数的真实性返回true或 false。所以我们可以这样说： myArray.filter(val =&gt; Boolean(val)); 是不是和这个一样： myArray.filter(Boolean); 10.展平数组 原型 Array 上有一个方法 flat 可以让你从数组的数组中创建一个数组： const myArray = [{ id: 1 }, [{ id: 2 }], [{ id: 3 }]]; const flattedArray = myArray.flat(); // returns [ { id: 1 }, { id: 2 }, { id: 3 } 你还可以定义一个深度级别，指定嵌套数组结构应展平的深度。例如： const arr = [0, 1, 2, [[[3, 4]]]]; console.log(arr.flat(2)); // returns [0, 1, 2, [3,4]] 结语 感谢你阅读到最后。希望这些技巧对你日常开发有用。 ","link":"https://umeimmense.github.io/post/shi-ge-chang-yong-de-javascript-shi-yong-ji-qiao"}]}