<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JavaScript 中的 Trie：什么是前缀树？ | Cool Coding</title>
<link rel="shortcut icon" href="https://umeimmense.github.io/favicon.ico?v=1639981760777">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://umeimmense.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JavaScript 中的 Trie：什么是前缀树？ | Cool Coding - Atom Feed" href="https://umeimmense.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="前言
我们已经在三篇文章中介绍了树数据结构的基础知识。如果你还没有读过这些，我强烈建议先阅读前三篇文章：

使用递归和迭代算法遍历二叉树
使用父指针遍历二叉树
将树遍历算法应用于 DOM

介绍
Trie 是树数据结构的一种变体。它也被称为..." />
    <meta name="keywords" content="Algorithm,JavaScript" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://umeimmense.github.io">
  <img class="avatar" src="https://umeimmense.github.io/images/avatar.png?v=1639981760777" alt="">
  </a>
  <h1 class="site-title">
    Cool Coding
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://umeimmense.github.io/resume/" class="menu" target="_blank">
          简历
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/umeimmense/" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JavaScript 中的 Trie：什么是前缀树？
            </h2>
            <div class="post-info">
              <span>
                2021-12-10
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://umeimmense.github.io/tag/algorithm" class="post-tag">
                  # Algorithm
                </a>
              
                <a href="https://umeimmense.github.io/tag/javascript" class="post-tag">
                  # JavaScript
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="前言">前言</h2>
<p>我们已经在三篇文章中介绍了树数据结构的基础知识。如果你还没有读过这些，我强烈建议先阅读前三篇文章：</p>
<ul>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree/">使用递归和迭代算法遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-zhong-de-tree-shi-yong-fu-zhi-zhen-gao-xiao-bian-li/">使用父指针遍历二叉树</a></li>
<li><a href="https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom/">将树遍历算法应用于 DOM</a></li>
</ul>
<h2 id="介绍">介绍</h2>
<p>Trie 是树数据结构的一种变体。它也被称为前缀树或搜索树的变体。就像 n 叉树数据结构一样，trie 可以有 n 个来自单亲的孩子。通常，trie 中的所有节点都会存储一些字符。假设我们只处理英语单词，下面是一个简单的 trie 可能看起来像：<br>
<img src="https://umeimmense.github.io/post-images/1639386955366.jpeg" alt="" loading="lazy"><br>
需要注意的事项：</p>
<ol>
<li>
<p>我们正在尝试使用树来尽可能高效地表示英语单词。</p>
</li>
<li>
<p>在上图中，从根节点到任何绿色节点的路径表示一个英文单词。例如：</p>
<ul>
<li>NULL-&gt;C-&gt;A-&gt;T: CAT</li>
<li>NULL-&gt;D-&gt;O: DO</li>
<li>NULL-&gt;D-&gt;O-&gt;G: DOG</li>
<li>NULL-&gt;D-&gt;A-&gt;R-&gt;K: DARK</li>
<li>NULL-&gt;A: A</li>
<li>NULL-&gt;A-&gt;N: AN</li>
</ul>
</li>
<li>
<p>每个节点最多可以有 26 个子节点（如果我们只处理英文字母）。我们有一个 NULL 节点作为根节点，因为一个单词可以以 26 个字母中的任何一个开头，因此我们需要一个虚拟节点，它可以将任何潜在的第一个字母作为子节点。</p>
</li>
<li>
<p>绿色节点，本质上代表“词尾”，同时从根遍历到该节点。</p>
</li>
</ol>
<h2 id="实现节点">实现节点</h2>
<p>现在，让我们尝试提出 Trie 节点的表示。回到树节点，这就是我们呈现它的方式：</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.left = null
  this.right = null
}
</code></pre>
<p>因此，我们可以对 Trie 遵循类似的想法，同时确保它满足我们在介绍部分讨论的要求。要了解 Trie 节点的要求，让我们放大任何节点：<br>
<img src="https://umeimmense.github.io/post-images/1639387276741.jpeg" alt="" loading="lazy"><br>
所以现在更有意义了。这是最终的代码：</p>
<pre><code class="language-javascript">function Node(value){
  this.value = value
  this.isEndOfWord = false // false by default, a green node means this flag is true
  this.children = {} // children are stored as Map, where key is the letter and value is a TrieNode for that letter 
}
</code></pre>
<h2 id="实现-trie-数据结构">实现 Trie 数据结构</h2>
<p>我们可以使用一个简单的 ES6 类来表示：</p>
<pre><code class="language-javascript">class Trie{
  constructor(){
    this.root = new Node(null)
  }

  insert(word){
   // TODO
  }

  search(word){
   // TODO
  }

}
</code></pre>
<p>所以我们已经准备好了大概。作为初始化的一部分，每个trie 都会创建它自己的根节点（NULL）。那么我们可以实现这两个方法如下：</p>
<ul>
<li>insert(word)：我们可以将单词拆分为字母，并为每个字母创建一个 Node()。然后我们可以开始将这些 Trie 节点中的每一个链接到根节点，以插入单词。最后，我们将最后插入的节点的 isEndOfWord 属性标记为 true。</li>
<li>search(word)：我们可以将单词拆分为字母。然后我们可以从根开始一个一个地寻找这些字母中的每一个。如果我们能够按顺序找到所有字母，那么我们可以返回 true 否则 false。</li>
</ul>
<p>让我们直观地理解这两个操作以获得更好的上下文：</p>
<ul>
<li>首先insert(CAR)然后insert(CAN):<br>
<img src="https://umeimmense.github.io/post-images/1639387651437.jpeg" alt="" loading="lazy"></li>
<li>首先search(CAR)然后search(CAN):<br>
<img src="https://umeimmense.github.io/post-images/1639387657794.jpeg" alt="" loading="lazy"></li>
</ul>
<p>实现如下：</p>
<pre><code class="language-javascript">class Trie{
  constructor(){
    this.root = new Node(null)
  }

  insert(word){
    let current = this.root
    // iterate through all the characters of word
    for(let character of word){
         // if node doesn't have the current character as child, insert it
         if(current.children[character] === undefined){
             current.children[character] = new Node(character)
         }
        // move down, to insert next character
        current = current.children[character]  
    }
    // mark the last inserted character as end of the word
    current.isEndOfWord = true
  }

  search(word){
     let current = this.root
    // iterate through all the characters of word
    for(let character of word){
         if(current.children[character] === undefined){
             // could not find this character in sequence, return false
             return false
         }
        // move down, to match next character
        current = current.children[character]  
    }
     // found all characters, return true if last character is end of a word
    return current.isEndOfWord
  }
}
</code></pre>
<h2 id="使用-trie">使用 Trie</h2>
<pre><code class="language-javascript">const trie = new Trie();

// insert few words
trie.insert(&quot;CAT&quot;);
trie.insert(&quot;DOG&quot;);

// search something
trie.search(&quot;MAT&quot;) // false
trie.search(&quot;DOG&quot;) // true
</code></pre>
<h3 id="空间复杂度">空间复杂度</h3>
<p>在最坏的情况下，所有插入单词的每个字符都可以占用 Trie 中的单个节点。所以这意味着最坏的空间复杂度可以是 (W*n)，其中 W 是每个单词的平均字符数，n 是 Trie 中的单词总数。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>插入：插入一个有n个字符的单词，只需要遍历n个字符，所以时间复杂度为O(n)</li>
<li>搜索：与插入类似，我们只需要遍历单词的所有字符即可进行搜索。所以时间复杂度是 O(n)，其中 n 是单词中的字符数。</li>
</ul>
<p>现在，想一想，你还能如何在庞大的单词列表中搜索某个单词？<br>
-可能使用数组？时间复杂度为 O(m)，其中 m 是单词总数，这很糟糕。</p>
<ul>
<li>如何使用Map（或 JavaScript 中的对象）？这会将时间复杂度降低到 O(1)，但是找到具有特定前缀的单词列表有多快？它将是 O(m)。</li>
</ul>
<p>Trie 不仅将时间复杂度降低到 O(n)（n = 单词中的字符数），而且您还可以有效地搜索具有前缀的单词列表，这对于任何以上两种方法。</p>
<h2 id="应用">应用</h2>
<ul>
<li>自动完成和预先输入：如果您在文本框中键入内容，并且看到具有相同前缀的潜在搜索列表，即自动完成小部件，那么这可能是由后台的 Trie 处理的。同样，<a href="https://en.wikipedia.org/wiki/Typeahead">Typeahead</a> 也可以使用 Trie 来实现。</li>
<li>拼写检查器：我们可以使用 trie 创建拼写检查器，即给定一个单词列表，我们可以检查给定单词的拼写是否正确。</li>
<li>IP 路由（最长前缀匹配）：Internet 由多个路由器节点组成，它们决定应该发送的目标数据包。 Internet 上的每个路由器都需要将数据包发送到由给定 IP 目的地决定的适当目标节点。但是每个路由器如何使用给定的 IP 地址决定下一个目标路由器呢？这个问题可以使用IP路由来解决。<a href="https://www.lewuathe.com/longest-prefix-match-with-trie-tree.html">这是一篇深入探讨这个主题的好文章</a>。</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%8A%82%E7%82%B9">实现节点</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0-trie-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">实现 Trie 数据结构</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-trie">使用 Trie</a>
<ul>
<li><a href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">空间复杂度</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8">应用</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://umeimmense.github.io/post/javascript-jiang-shu-bian-li-suan-fa-ying-yong-yu-dom">
              <h3 class="post-title">
                JavaScript 将树遍历算法应用于 DOM
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://umeimmense.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
